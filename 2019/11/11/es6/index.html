<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ES6 | 学术渊</title>
  <meta name="keywords" content=" ES6 ">
  <meta name="description" content="ES6 | 学术渊">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="很抱歉，您所访问的地址并不存在">
<meta property="og:type" content="website">
<meta property="og:title" content="404">
<meta property="og:url" content="http:&#x2F;&#x2F;1512034032.github.io&#x2F;404.html">
<meta property="og:site_name" content="学术渊">
<meta property="og:description" content="很抱歉，您所访问的地址并不存在">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-11-07T03:15:57.684Z">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>小学徒</span>
</div>

<div class="icon">
    
        
        <a title="rss" href="/atom.xml" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-rss"></use>
                </svg>
            
        </a>
        
    
        
        <a title="github" href="https://github.com/1512034032" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
        <a title="email" href="mailto:1512034032@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1512034032&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(22)</small></div></li>
    
        
            
            <li><div data-rel="前端"><i class="fold iconfont icon-right"></i>前端<small>(12)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="Js">Js<small>(8)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
            <li><div data-rel="Node">Node<small>(6)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="Vue">Vue<small>(3)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="22">
<input type="hidden" id="yelog_site_word_count" value="44k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="Search..." autocomplete="off"id="local-search-input" >
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a class="color3">Js</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">Node</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">ajax</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">Vue</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">cookis</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">websocket</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">H5</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">ES6</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class=""
           href="/2019/11/13/react/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="React 基础">React 基础</span>
            <span class="post-date" title="2019-11-13 20:18:42">2019/11/13</span>
        </a>
        
        <a  class="前端 Js "
           href="/2019/11/11/JsAnimation/"
           data-tag="Js"
           data-author="" >
            <span class="post-title" title="js动画">js动画</span>
            <span class="post-date" title="2019-11-11 09:43:27">2019/11/11</span>
        </a>
        
        <a  class="前端 Js "
           href="/2019/11/11/MathAndDate/"
           data-tag="Js"
           data-author="" >
            <span class="post-title" title="Math&amp;&amp;Date">Math&amp;&amp;Date</span>
            <span class="post-date" title="2019-11-11 09:43:27">2019/11/11</span>
        </a>
        
        <a  class="前端 Js "
           href="/2019/11/11/es6/"
           data-tag="ES6"
           data-author="" >
            <span class="post-title" title="ES6">ES6</span>
            <span class="post-date" title="2019-11-11 09:43:27">2019/11/11</span>
        </a>
        
        <a  class="前端 Js "
           href="/2019/11/11/regular/"
           data-tag="Js"
           data-author="" >
            <span class="post-title" title="js正则">js正则</span>
            <span class="post-date" title="2019-11-11 09:43:27">2019/11/11</span>
        </a>
        
        <a  class="前端 Js "
           href="/2019/11/11/string/"
           data-tag="Js"
           data-author="" >
            <span class="post-title" title="字符串">字符串</span>
            <span class="post-date" title="2019-11-11 09:43:27">2019/11/11</span>
        </a>
        
        <a  class="前端 Js "
           href="/2019/11/11/array/"
           data-tag="Js"
           data-author="" >
            <span class="post-title" title="数组">数组</span>
            <span class="post-date" title="2019-11-11 09:43:27">2019/11/11</span>
        </a>
        
        <a  class="Node "
           href="/2019/11/08/websocket/"
           data-tag="websocket"
           data-author="" >
            <span class="post-title" title="websocket">websocket</span>
            <span class="post-date" title="2019-11-08 20:13:25">2019/11/08</span>
        </a>
        
        <a  class="Node "
           href="/2019/11/08/express-session/"
           data-tag="Node"
           data-author="" >
            <span class="post-title" title="express-session">express-session</span>
            <span class="post-date" title="2019-11-08 20:13:25">2019/11/08</span>
        </a>
        
        <a  class="Node "
           href="/2019/11/08/code/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="状态码">状态码</span>
            <span class="post-date" title="2019-11-08 19:05:13">2019/11/08</span>
        </a>
        
        <a  class="Node "
           href="/2019/11/08/serverContent-type/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="NodeJs 服务器 content-type类型处理">NodeJs 服务器 content-type类型处理</span>
            <span class="post-date" title="2019-11-08 16:54:34">2019/11/08</span>
        </a>
        
        <a  class="Node "
           href="/2019/11/08/CrossDomainIssues/"
           data-tag="Node"
           data-author="" >
            <span class="post-title" title="解决跨域问题">解决跨域问题</span>
            <span class="post-date" title="2019-11-08 16:51:53">2019/11/08</span>
        </a>
        
        <a  class="前端 Js "
           href="/2019/11/08/cookis/"
           data-tag="cookis"
           data-author="" >
            <span class="post-title" title="Cookis">Cookis</span>
            <span class="post-date" title="2019-11-08 16:37:56">2019/11/08</span>
        </a>
        
        <a  class="前端 "
           href="/2019/11/07/promise/"
           data-tag="Js"
           data-author="" >
            <span class="post-title" title="ES6---new Promise()讲解，Promise对象是用来干嘛的?">ES6---new Promise()讲解，Promise对象是用来干嘛的?</span>
            <span class="post-date" title="2019-11-07 15:23:03">2019/11/07</span>
        </a>
        
        <a  class="前端 Js "
           href="/2019/11/07/js/"
           data-tag="Js"
           data-author="" >
            <span class="post-title" title="js小知识点">js小知识点</span>
            <span class="post-date" title="2019-11-07 07:51:21">2019/11/07</span>
        </a>
        
        <a  class="前端 "
           href="/2019/11/06/html/"
           data-tag="H5"
           data-author="" >
            <span class="post-title" title="HTML">HTML</span>
            <span class="post-date" title="2019-11-06 19:15:21">2019/11/06</span>
        </a>
        
        <a  class="前端 "
           href="/2019/11/06/Swiper/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Swiper">Swiper</span>
            <span class="post-date" title="2019-11-06 14:02:06">2019/11/06</span>
        </a>
        
        <a  class="Vue "
           href="/2019/11/06/VueAnimation/"
           data-tag="Vue"
           data-author="" >
            <span class="post-title" title="Vue动画">Vue动画</span>
            <span class="post-date" title="2019-11-06 14:02:06">2019/11/06</span>
        </a>
        
        <a  class="前端 "
           href="/2019/11/06/ajax/"
           data-tag="ajax"
           data-author="" >
            <span class="post-title" title="ajax">ajax</span>
            <span class="post-date" title="2019-11-06 14:02:06">2019/11/06</span>
        </a>
        
        <a  class="Node "
           href="/2019/11/06/express/"
           data-tag="Node"
           data-author="" >
            <span class="post-title" title="express">express</span>
            <span class="post-date" title="2019-11-06 14:02:06">2019/11/06</span>
        </a>
        
        <a  class="Vue "
           href="/2019/11/06/Vuex/"
           data-tag="Vue"
           data-author="" >
            <span class="post-title" title="VueX">VueX</span>
            <span class="post-date" title="2019-11-06 14:02:06">2019/11/06</span>
        </a>
        
        <a  class="Vue "
           href="/2019/11/06/Vue/"
           data-tag="Vue"
           data-author="" >
            <span class="post-title" title="Vue">Vue</span>
            <span class="post-date" title="2019-11-06 14:02:06">2019/11/06</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-es6" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">ES6</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a href="javascript:" target="_blank" data-rel="前端 noopener">前端</a>/
            
                <a href="javascript:" target="_blank" data-rel="Js noopener">Js</a>
            
        </span>
        
        
        <span class="tag">
            
            <a href="javascript:" target="_blank" rel="noopener" class="color4">ES6</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2019-11-11 09:48:27'>2019-11-11 09:43</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:7.8k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6"><span class="toc-text">ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1：this关键字"><span class="toc-text">1：this关键字</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2：bind方法"><span class="toc-text">2：bind方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3：let-const"><span class="toc-text">3：let/const</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4：const命令"><span class="toc-text">4：const命令</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5：箭头函数-gt"><span class="toc-text">5：箭头函数 =&gt;</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6：变量解构（解构赋值）"><span class="toc-text">6：变量解构（解构赋值）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7：字符串扩展"><span class="toc-text">7：字符串扩展</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7-1：数组新增方法"><span class="toc-text">7.1：数组新增方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8：扩展运算符"><span class="toc-text">8：扩展运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#9：函数参数默认值"><span class="toc-text">9：函数参数默认值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#10：Symbol类型"><span class="toc-text">10：Symbol类型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#11：Set和Map结构"><span class="toc-text">11：Set和Map结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#12：Generators生成器函数"><span class="toc-text">12：Generators生成器函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#13：class的写法及继承"><span class="toc-text">13：class的写法及继承</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ul>
<li>重点知识<ul>
<li>this关键字以及bind</li>
<li>let/const</li>
<li>变量解构</li>
<li>箭头函数</li>
<li>模板字符串</li>
<li>class和继承</li>
</ul>
</li>
</ul>
<hr>
<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言</p>
<hr>
<h6 id="1：this关键字"><a href="#1：this关键字" class="headerlink" title="1：this关键字"></a>1：this关键字</h6><p><code>this</code>可以用在构造函数之中，表示实例对象。除此之外，<code>this</code>还可以用在别的场合。但不管是什么场合，<code>this</code>都有一个共同点：它总是返回一个对象简单说，<code>this</code>就是属性或方法“当前”所在的对象。</p>
<pre><code class="js">var person = {
    name: &#39;张三&#39;,
    describe: function (){
        return &#39;姓名：&#39;+ this.name;
    }
};
person.describe()// &quot;姓名：张三&quot;</code></pre>
<p>上面代码中，<code>this.name</code>表示<code>name</code>属性所在的那个对象。由于<code>this.name</code>是在<code>describe</code>方法中调用，而<code>describe</code>方法所在的当前对象是<code>person</code>，因此<code>this</code>指向<code>person</code>，<code>this.name</code>就是<code>person.name</code>。</p>
<p><code>this</code>主要有以下几个使用场合</p>
<p><strong>（1）全局环境</strong></p>
<pre><code class="js">//全局环境使用this，它指的就是顶层对象window。
this === window // true
function f() {
    console.log(this === window);
}
f() // true
//注：严格模式下 普通函数内部 this 等于 undefined</code></pre>
<p><strong>（2）构造函数</strong></p>
<p>构造函数中的<code>this</code>，指的是实例对象</p>
<pre><code class="js">function Person(p) {
    this.p = p;
};
var obj = new Person()</code></pre>
<p><strong>（3）对象的方法</strong></p>
<p>如果对象的方法里面包含<code>this</code>，<code>this</code>的指向就是方法运行时所在的对象。</p>
<pre><code class="js">var obj ={
    foo: function () {
        console.log(this);
    }
};
obj.foo() // obj </code></pre>
<hr>
<h6 id="2：bind方法"><a href="#2：bind方法" class="headerlink" title="2：bind方法"></a>2：bind方法</h6><p><code>bind</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数。</p>
<pre><code class="js">var dog ={
    name:&#39;wangcai&#39;,
    age:18,
    wang:function(){
        console.log(this)
    }
}
var person = {name:&#39;小明&#39;}
var func = dog.wang.bind(person)
func();//上面代码将person绑定到了func函数内部</code></pre>
<hr>
<h6 id="3：let-const"><a href="#3：let-const" class="headerlink" title="3：let/const"></a>3：<strong>let/const</strong></h6><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p>
<pre><code class="js">{
    let a = 10;  var b = 1;
}
a // ReferenceError: a is not defined.
b // 1</code></pre>
<p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p>
<p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p>
<pre><code class="js">var oLis = document.getElementsByTagName(&#39;li&#39;)
for (let i = 0; i &lt; oLis.length; i++) {
    // ...
    oLis[i].onclick = function(){
        console.log(i)// 0 1 2 3 4
    }
}
console.log(i);
// ReferenceError: i is not defined
//上面代码相当与产生了几个块级作用域
{
    var i=0;
    oLis[i].onclick = function(){
        console.log(i)
    }
}
{
    var i=1;
    oLis[i].onclick = function(){
        console.log(i)
    }
}</code></pre>
<p>上面代码中，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外引用就会报错。</p>
<p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景，let实际上为 JavaScript 新增了块级作用域<strong>。</strong></p>
<p><code>var</code>命令会发生”变量提升“现象，即变量可以在声明之前使用，值为<code>undefined</code>。</p>
<p>这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>
<p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<h6 id="4：const命令"><a href="#4：const命令" class="headerlink" title="4：const命令"></a>4：const命令</h6><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值</p>
<pre><code class="js">const PI = 3.1415;
PI // 3.1415
PI = 3;
// TypeError: Assignment to constant variable.</code></pre>
<p>上面代码表明改变常量的值会报错。</p>
<hr>
<h6 id="5：箭头函数-gt"><a href="#5：箭头函数-gt" class="headerlink" title="5：箭头函数 =&gt;"></a>5：箭头函数 =&gt;</h6><p>ES6 允许使用“箭头”（=&gt;）定义函数。</p>
<pre><code class="js">var f = v =&gt; v;// 等同于
var f = function (v) {
    return v;
};</code></pre>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<pre><code class="js">var f = () =&gt; 5;
// 等同于
var f = function () { 
    return 5 
};

var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2) {
    return num1 + num2;
};</code></pre>
<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。</p>
<pre><code class="js">var sum = (num1, num2) =&gt; { return num1 + num2; }</code></pre>
<p>箭头函数使得表达更加简洁。</p>
<pre><code class="js">const isEven = n =&gt; n % 2 == 0;const square = n =&gt; n * n;</code></pre>
<p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>
<p>箭头函数的一个用处是简化回调函数。</p>
<pre><code class="js">// 正常函数写法
[1,2,3].map(function (x) {  
    return x * x;
});
// 箭头函数写法
[1,2,3].map(x =&gt; x * x);
// 正常函数写法
var result = values.sort(function (a, b) {
    return a - b;
});
// 箭头函数写法
var result = values.sort((a, b) =&gt; a - b);</code></pre>
<p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。</p>
<hr>
<h6 id="6：变量解构（解构赋值）"><a href="#6：变量解构（解构赋值）" class="headerlink" title="6：变量解构（解构赋值）"></a>6：变量解构（解构赋值）</h6><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构</p>
<p>以前，为变量赋值，只能直接指定值。</p>
<pre><code class="js">let a = 1;
let b = 2;
let c = 3;</code></pre>
<p>ES6 允许写成下面这样。</p>
<pre><code class="js">let [a, b, c] = [1, 2, 3];</code></pre>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值<br>解构不仅可以用于数组，还可以用于对象</p>
<pre><code class="js">let { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;</code></pre>
<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值</p>
<pre><code class="js">let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;
let { foo} = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;</code></pre>
<h6 id="7：字符串扩展"><a href="#7：字符串扩展" class="headerlink" title="7：字符串扩展"></a>7：字符串扩展</h6><blockquote>
<p>模板字符串（template string）是增强版的字符串</p>
</blockquote>
<p>传统的 JavaScript 语言，输出模板通常是这样写的。</p>
<pre><code class="js">var a = 1
var b = 2;
var sum = a + b;
var res = a + &#39;+&#39; + b + &#39;的和是&#39; + c+&#39;&#39;;
console.log(res)
box.innerHTML = res;
var obj=  {name:&#39;zhangsan&#39;,age:18};
var str = &#39;姓名：&#39;+obj.name+&#39;年龄:&#39;+obj.age;
div.innerHTML = str;</code></pre>
<p>上面这种写法(拼字符串)相当繁琐不方便，ES6 引入了模板字符串解决这个问题。模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，可以在字符串中嵌入变量， 模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。</p>
<pre><code class="js">var a = 1
var b = 2;
var sum = a + b;
var res =`a+b的和是&lt;b&gt;{c}&lt;/b&gt;`;
console.log(res)
box.innerHTML = res;
var obj=  {name:&#39;zhangsan&#39;,age:18};
var str =`&lt;b&gt;姓名&lt;/b&gt;：{obj.name}年龄:{obj.age}`
div.innerHTML = str;</code></pre>
<p>上面代码中的模字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义</p>
<pre><code class="js">let greeting = `\`Yo\` World!`;</code></pre>
<p> 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中</p>
<pre><code class="js">oDiv.innerHTML = `
    &lt;ul&gt;  
    &lt;li&gt;first&lt;/li&gt;  
    &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;`</code></pre>
<p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p>
<pre><code class="js">et x = 1;let y = 2;
`${x} + ${y} = ${x + y}`
// &quot;1 + 2 = 3&quot;
`${x} + ${y * 2} = ${x + y * 2}`
// &quot;1 + 4 = 5&quot;
let obj = {x: 1, y: 2};
`${obj.x + obj.y}`</code></pre>
<p>模板字符串之中还能调用函数</p>
<pre><code class="js">function fn() {
    return &quot;Hello World&quot;;
}
`foo ${fn()} bar`
// foo Hello World bar</code></pre>
<p>字符串扩张方法</p>
<hr>
<p>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p>
<p>​    <code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</p>
<p>​    <code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</p>
<p>​    <code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</p>
<pre><code class="js">let s = &#39;Hello world!&#39;;
s.startsWith(&#39;Hello&#39;) // true
s.endsWith(&#39;!&#39;) // true
s.includes(&#39;o&#39;) // true</code></pre>
<p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复n次</p>
<pre><code class="js">&#39;x&#39;.repeat(3) // &quot;xxx&quot;
&#39;hello&#39;.repeat(2) // &quot;hellohello&quot;
&#39;na&#39;.repeat(0) // &quot;&quot;</code></pre>
<hr>
<h6 id="7-1：数组新增方法"><a href="#7-1：数组新增方法" class="headerlink" title="7.1：数组新增方法"></a>7.1：数组新增方法</h6><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（ES6 新增的数据结构 <code>Set</code> 和 <code>Map</code>）</p>
<p>下面是一个类似数组的对象，Array.from将它转为真正的数组</p>
<pre><code class="js">let arrayLike = {    
    &#39;0&#39;: &#39;a&#39;,    
    &#39;1&#39;: &#39;b&#39;,    
    &#39;2&#39;: &#39;c&#39;,    
    length: 3
};
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre>
<p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。</p>
<p>Array.from都可以将它们转为真正的数组<br>对象扩展<br>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<pre><code class="js">const foo = &#39;bar&#39;;
const baz = {foo};
baz // {foo: &quot;bar&quot;}
// 等同于
const baz = {foo: foo};</code></pre>
<p>除了属性简写，方法也可以简写。</p>
<pre><code class="js">const o = {  
    method() {    
        return &quot;Hello!&quot;;  
    }
};
// 等同于
const o = {  
    method: function() {    
        return &quot;Hello!&quot;;  
    }
};</code></pre>
<hr>
<h6 id="8：扩展运算符"><a href="#8：扩展运算符" class="headerlink" title="8：扩展运算符"></a>8：扩展运算符</h6><p>扩展运算符三个点（…）<br>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<pre><code class="js">let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }</code></pre>
<p>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</p>
<pre><code class="js">let foo = { ...[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] };
foo// {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;}</code></pre>
<p>对象的扩展运算符等同于使用Object.assign()方法。</p>
<pre><code class="js">let aClone = { ...a };
// 等同于
let aClone = Object.assign({}, a);</code></pre>
<pre><code class="js">function add(x, y) { 
    return x + y; 
} 
var numbers = [4, 38]; 
add(...numbers) //
//该运算符将一个数组，变为参数序列
 var arr1 = [&#39;a&#39;, &#39;b&#39;];
 var arr2 = [&#39;c&#39;];
 var arr3 = [&#39;d&#39;, &#39;e&#39;];// 合并数组
 [...arr1, ...arr2, ...arr3]</code></pre>
<hr>
<h6 id="9：函数参数默认值"><a href="#9：函数参数默认值" class="headerlink" title="9：函数参数默认值"></a>9：函数参数默认值</h6><p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>
<pre><code class="js">function log(x, y) {  
    y = y || &#39;World&#39;;  
    console.log(x, y);
}
log(&#39;Hello&#39;) // Hello World
log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
 //这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。</code></pre>
<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<pre><code class="js">function log(x, y = &#39;World&#39;) {  
    console.log(x, y);
}
log(&#39;Hello&#39;) // Hello World
log(&#39;Hello&#39;, &#39;China&#39;) // Hello China</code></pre>
<p>可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。</p>
<hr>
<h6 id="10：Symbol类型"><a href="#10：Symbol类型" class="headerlink" title="10：Symbol类型"></a>10：Symbol类型</h6><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>
<p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。</p>
<p>它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（<code>Boolean</code>）、字符串（<code>String</code>）、数值（<code>Number</code>）、对象（<code>Object</code>）</p>
<p>Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。</p>
<p>凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突</p>
<pre><code class="js">let s = Symbol();
typeof s// &quot;symbol&quot;</code></pre>
<p>上面代码中，变量<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是 Symbol 数据类型，而不是字符串之类的其他类型注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。</p>
<p>这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<pre><code class="js">let s1 = Symbol(&#39;foo&#39;);
let s2 = Symbol(&#39;bar&#39;);
s1 // Symbol(foo)
s2 // Symbol(bar)
s1.toString() // &quot;Symbol(foo)&quot;
s2.toString() // &quot;Symbol(bar)&quot;</code></pre>
<p>上面代码中，<code>s1</code>和<code>s2</code>是两个 Symbol 值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。<br>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p>
<pre><code class="js">// 没有参数的情况
let s1 = Symbol();
let s2 = Symbol();
s1 === s2 // false
// 有参数的情况
let s1 = Symbol(&#39;foo&#39;);
let s2 = Symbol(&#39;foo&#39;);
s1 === s2 // false</code></pre>
<p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的。Symbol 值也可以转为布尔值，但是不能转为数值</p>
<pre><code class="js">let sym = Symbol();
Boolean(sym) // true!
sym // false
if (sym) {
    // ...
}
Number(sym) // TypeError
sym + 2 // TypeError</code></pre>
<p>作为属性名的 Symbol由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性，能防止某一个键被不小心改写或覆盖。</p>
<pre><code class="js">// 第一种写法
let a = {};
a[mySymbol] = &#39;Hello!&#39;;
// 第二种写法
let a = {
    [mySymbol]: &#39;Hello!&#39;
};
// 以上写法都得到同样结果
a[mySymbol] // &quot;Hello!&quot;注意，Symbol 值作为对象属性名时，不能用点运算符。
const mySymbol = Symbol();
const a = {};
a.mySymbol = &#39;Hello!&#39;;
a[mySymbol] // undefined
a[&#39;mySymbol&#39;] // &quot;Hello!&quot;</code></pre>
<p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<pre><code class="js">let s = Symbol();
let obj = {
    [s]: function (arg) {
        ...
    }
};
obj[s];</code></pre>
<p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个 Symbol 值。</p>
<hr>
<h6 id="11：Set和Map结构"><a href="#11：Set和Map结构" class="headerlink" title="11：Set和Map结构"></a>11：Set和Map结构</h6><p>ES6 提供了新的数据结构 <code>Set</code>。</p>
<blockquote>
<p>它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p>
</blockquote>
<pre><code class="js">const s = new Set();
[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));
for (let i of s) {
    console.log(i);
}// 2 3 5 4</code></pre>
<p>上面代码通过<code>add</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。<br>Set 函数可以接受一个数组（获取dom的nodelist对象）作为参数，用来初始化。</p>
<pre><code class="js">// 例一
const set = new Set([1, 2, 3, 4, 4]);
[...set]// [1, 2, 3, 4]
// 例二
const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
items.size // 8
// 例三
const set = new Set(document.querySelectorAll(&#39;div&#39;));
set.size // 56</code></pre>
<p>上面代码也展示了一种去除数组重复成员的方法。</p>
<pre><code class="js">// 去除数组的重复成员
[...new Set(array)]</code></pre>
<p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。</p>
<p>Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p>
<pre><code class="js">let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set // Set {NaN}</code></pre>
<p>Set 结构的实例有以下属性</p>
<p>​    <code>constructor</code>：构造函数，默认就是<code>Set</code>函数。</p>
<p>​    <code>size</code>：返回<code>Set</code>实例的成员总数。</p>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。</p>
<ul>
<li>下面四个操作方法<ul>
<li>- add(value)：添加某个值，返回 Set 结构本身。</li>
<li>-delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>-has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>-clear()：清除所有成员，没有返回值。</li>
</ul>
</li>
</ul>
<pre><code class="js">s.add(1).add(2).add(2);// 注意2被加入了两次
s.size // 2
s.has(1) // true
s.has(2) // true
s.has(3) // false
s.delete(2);
s.has(2) // false</code></pre>
<p><code>Array.from</code>方法可以将 Set 结构转为数组。</p>
<pre><code class="js">const items = new Set([1, 2, 3, 4, 5]);
const array = Array.from(items);
Set 结构的实例默认可遍历
let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);
for (let x of set) {  console.log(x);}// red// green// blue</code></pre>
<p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p>
<pre><code class="js">set = new Set([1, 4, 9]);
set.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))// 1 : 1// 4 : 4// 9 : 9</code></pre>
<p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。</p>
<p>这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p>
<p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p>
<pre><code class="js">let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)];// [3, 5, 2]</code></pre>
<p><strong>map结构</strong></p>
<p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<p>ES6 提供了 <code>Map</code> 数据结构。</p>
<p>它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<p>Map 结构的实例有以下属性和操作方法。</p>
<p><strong>（1）size 属性</strong><br><code>size</code>属性返回 Map 结构的成员总数。</p>
<pre><code class="js">const map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);
map.size // 2</code></pre>
<p><strong>（2）set(key, value)</strong><br><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p>
<pre><code class="js">const m = new Map();
m.set(&#39;edition&#39;, 6)
// 键是字符串
m.set(262, &#39;standard&#39;)
// 键是数值
m.set(undefined, &#39;nah&#39;)
// 键是 undefined</code></pre>
<p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p>
<pre><code class="js">let map = new Map()
.set(1, &#39;a&#39;)
.set(2, &#39;b&#39;)
.set(3, &#39;c&#39;);</code></pre>
<p><strong>（3）get(key)</strong><br><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>
<pre><code class="js">const m = new Map();
const hello = function() {
    console.log(&#39;hello&#39;);
};
m.set(hello, &#39;Hello ES6!&#39;) // 键是函数
m.get(hello) // Hello ES6!</code></pre>
<p><strong>（4）has(key)</strong><br><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p>
<pre><code class="js">const m = new Map();
m.set(&#39;edition&#39;, 6);
m.set(262, &#39;standard&#39;);
m.set(undefined, &#39;nah&#39;);
m.has(&#39;edition&#39;)    // true
m.has(&#39;years&#39;)      // false
m.has(262)          // true
m.has(undefined)    // true</code></pre>
<p><strong>（5）delete(key)</strong><br><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p>
<pre><code class="js">const m = new Map();
m.set(undefined, &#39;nah&#39;);
m.has(undefined)    // true
m.delete(undefined)
m.has(undefined)      // false</code></pre>
<p><strong>（6）clear()</strong><br><code>clear</code>方法清除所有成员，没有返回值。</p>
<pre><code class="js">let map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);
map.size // 2
map.clear()
map.size // 0</code></pre>
<p>遍历map<br>需要特别注意的是，Map 的遍历顺序就是插入顺序</p>
<pre><code class="js">const map = new Map([  [&#39;F&#39;, &#39;no&#39;],  [&#39;T&#39;,  &#39;yes&#39;],]);
for (let [key, value] of map) {
    console.log(key, value);
}
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;</code></pre>
<h6 id="12：Generators生成器函数"><a href="#12：Generators生成器函数" class="headerlink" title="12：Generators生成器函数"></a>12：Generators生成器函数</h6><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p>
<p> Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>
<p> 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<ul>
<li>形式上，Generator 函数是一个普通函数，但是有两个特征。<ul>
<li>一是，<code>function</code>关键字与函数名之间有一个星号；</li>
<li>二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）</li>
</ul>
</li>
</ul>
<pre><code class="js">function* helloWorldGenerator() {
    yield &#39;hello&#39;;
    yield &#39;world&#39;;
    return &#39;ending&#39;;
}
var hw = helloWorldGenerator();</code></pre>
<p>上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p>
<p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。</p>
<p>不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象<br><strong>yield 表达式</strong><br>由于 Generator 函数返回的遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。</p>
<p><code>yield</code>表达式就是暂停标志。</p>
<p>（1）遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</p>
<p>（2）下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</p>
<p>（3）如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</p>
<p>（4）如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code></p>
<p>下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p>
<pre><code class="js">hw.next()// { value: &#39;hello&#39;, done: false }
hw.next()// { value: &#39;world&#39;, done: false }
hw.next()// { value: &#39;ending&#39;, done: true }
hw.next()// { value: undefined, done: true }</code></pre>
<p>上面代码一共调用了四次<code>next</code>方法。</p>
<blockquote>
<p>第一次调用，Generator 函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p>
</blockquote>
<blockquote>
<p>第二次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到下一个<code>yield</code>表达式。<code>next</code>方法返回的对象的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>world</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p>
</blockquote>
<blockquote>
<p>第三次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到<code>return</code>语句（如果没有<code>return</code>语句，就执行到函数结束）。<code>next</code>方法返回的对象的<code>value</code>属性，就是紧跟在<code>return</code>语句后面的表达式的值（如果没有<code>return</code>语句，则<code>value</code>属性的值为<code>undefined</code>），<code>done</code>属性的值<code>true</code>，表示遍历已经结束。</p>
</blockquote>
<blockquote>
<p>第四次调用，此时 Generator 函数已经运行完毕，<code>next</code>方法返回对象的<code>value</code>属性为<code>undefined</code>，<code>done</code>属性为<code>true</code>。以后再调用<code>next</code>方法，返回的都是这个值。</p>
</blockquote>
<p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。</p>
<p>以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。</p>
<p><code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p>
<hr>
<h6 id="13：class的写法及继承"><a href="#13：class的写法及继承" class="headerlink" title="13：class的写法及继承"></a>13：class的写法及继承</h6><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子</p>
<pre><code class="js">function Point(x, y) {
    this.x = x;
    this.y = y;
}
Point.prototype.toString = function () {
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
};
var p = new Point(1, 2);</code></pre>
<p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p>
<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。<br>通过<code>class</code>关键字，可以定义类。<br>基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<p>上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</p>
<pre><code class="js">//定义类
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
      toString() {
          return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;  
      }
}</code></pre>
<p>上面代码定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。也就是说，ES5 的构造函数<code>Point</code>，对应 ES6 的<code>Point</code>类的构造方法<br><code>point</code>类除了构造方法，还定义了一个<code>toString</code>方法。</p>
<p>注意，定义“类”的方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>
<pre><code class="js">//hasOwnProperty 可以用来判断对象是否有每一个属性
point.hasOwnProperty(&#39;x&#39;) // true
point.hasOwnProperty(&#39;y&#39;) // true</code></pre>
<p>ES6 的类，完全可以看作构造函数的另一种写法</p>
<pre><code class="js">class Point {
    // ...
}
typeof Point // &quot;function&quot;</code></pre>
<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数</p>
<p>类的属性名，可以采用表达式。</p>
<pre><code class="js">let methodName = &#39;getArea&#39;;
class Square {
    constructor(length){
        // ...
    }
      methodName {
        // ...
    }
}</code></pre>
<p>上面代码中，<code>Square</code>类的方法名<code>getArea</code>，是从表达式得到的。</p>
<p>类内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。<br>考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p>
<p><strong>constructor 方法</strong><br><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p>
<pre><code class="js">class Point {}
// 等同于
class Point {
    constructor() {

    }
}</code></pre>
<p>上面代码中，定义了一个空的类<code>Point</code>，JavaScript 引擎会自动为它添加一个空的<code>constructor</code>方法。<br><code>constructor</code>方法默认返回实例对象（即<code>this</code>）</p>
<p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p>
<pre><code class="js">class Foo {
    constructor() {

    }
}
Foo()// TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;</code></pre>
<p>生成类的实例对象的写法，与 ES5 完全一样，也是使用<code>new</code>命令。前面说过，如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错。</p>
<pre><code class="js">class Point {
    // ...
}
// 报错
var point = Point(2, 3);
// 正确
var point = new Point(2, 3);</code></pre>
<p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p>
<pre><code class="js">new Foo(); // ReferenceError
class Foo {}</code></pre>
<p>类方法<br>加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<pre><code class="js">class Foo {
    static classMethod() {
        return &#39;hello&#39;;
    }
}
Foo.classMethod() // &#39;hello&#39;
var foo = new Foo();
foo.classMethod()// TypeError: foo.classMethod is not a function</code></pre>
<p>上面代码中，Foo类的classMethod方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（<code>Foo.classMethod()</code>），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>
<p>类的继承Class 可以通过<code>extends</code>关键字实现继承 这比 ES5 的通过修改原型链（在后面章节会讲解）实现继承，要清晰和方便很多。</p>
<pre><code class="js">class Point {}
class ColorPoint extends Point {}</code></pre>
<p>上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。下面，我们在<code>ColorPoint</code>内部加上代码。</p>
<pre><code class="js">class ColorPoint extends Point {
    constructor(x, y, color) {
        super(x, y); // 调用父类的constructor(x, y)
        this.color = color;
    }
    toString() {
        return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()
    }
}</code></pre>
<p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。<br>ES6 要求，子类的构造函数必须执行一次<code>super</code>函数</p>
<p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p>
<pre><code class="js">class Point { /* ... */ }
class ColorPoint extends Point {
    constructor() {  }
}
let cp = new ColorPoint(); // ReferenceError</code></pre>
<p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super</code>方法，导致新建实例时报错。</p>
<p>需要注意的地方是，在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有<code>super</code>方法才能返回父类实例</p>
<pre><code class="js">class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}
class ColorPoint extends Point {
    constructor(x, y, color) {
        this.color = color; // ReferenceError
        super(x, y);
        this.color = color; // 正确
    }
}</code></pre>
<p>上面代码中，子类的<code>constructor</code>方法没有调用<code>super</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super</code>方法之后就是正确的。</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 1512034032@qq.com </span>
    </div>
</article>


<p>
    <a" class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>ES6</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">7.8k</span></p>
    <p><span class="copy-title">本文作者:</span><a title="小学徒">小学徒</a></p>
    <p><span class="copy-title">发布时间:</span>2019-11-11, 09:43:27</p>
    <p><span class="copy-title">最后更新:</span>2019-11-11, 09:48:27</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2019/11/11/es6/" title="ES6">http://1512034032.github.io/2019/11/11/es6/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2019 小学徒</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket"></a>
    </div>
</div>
<div class="acParent"></div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close" onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#Js','#Node','#ajax','#Vue','#cookis','#websocket','#H5','#ES6',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>






</html>
