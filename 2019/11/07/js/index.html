<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>js汇总 | 学术渊</title>
  <meta name="keywords" content="">
  <meta name="description" content="js汇总 | 学术渊">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta property="og:type" content="website">
<meta property="og:title" content="about">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;about&#x2F;index.html">
<meta property="og:site_name" content="学术渊">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-11-06T06:54:02.901Z">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>小学徒</span>
</div>

<div class="icon">
    
        
        <a title="rss" href="/atom.xml" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-rss"></use>
                </svg>
            
        </a>
        
    
        
        <a title="github" href="https://github.com/1512034032" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
        <a title="email" href="mailto:1512034032@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1512034032&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(9)</small></div></li>
    
        
            
            <li><div data-rel="前端"><i class="fold iconfont icon-right"></i>前端<small>(4)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="js">js<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="Node">Node<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="Vue">Vue<small>(3)</small></div>
                
            </li>
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="9">
<input type="hidden" id="yelog_site_word_count" value="37.4k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="Search..." autocomplete="off"id="local-search-input" >
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class="前端 "
           href="/2019/11/06/Swiper/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Swiper">Swiper</span>
            <span class="post-date" title="2019-11-06 14:02:06">2019/11/06</span>
        </a>
        
        <a  class="Node "
           href="/2019/11/06/Nodejs/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="nodejs">nodejs</span>
            <span class="post-date" title="2019-11-06 14:02:06">2019/11/06</span>
        </a>
        
        <a  class="Vue "
           href="/2019/11/06/Vuex/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="VueX">VueX</span>
            <span class="post-date" title="2019-11-06 14:02:06">2019/11/06</span>
        </a>
        
        <a  class=""
           href="/2019/11/05/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="第一篇博客">第一篇博客</span>
            <span class="post-date" title="2019-11-05 08:45:26">2019/11/05</span>
        </a>
        
        <a  class="前端 "
           href="/2019/11/06/ajax/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="ajax">ajax</span>
            <span class="post-date" title="2019-11-06 14:02:06">2019/11/06</span>
        </a>
        
        <a  class="Vue "
           href="/2019/11/06/Vue%E5%8A%A8%E7%94%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Vue动画">Vue动画</span>
            <span class="post-date" title="2019-11-06 14:02:06">2019/11/06</span>
        </a>
        
        <a  class="Vue "
           href="/2019/11/06/Vue/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Vue">Vue</span>
            <span class="post-date" title="2019-11-06 14:02:06">2019/11/06</span>
        </a>
        
        <a  class="前端 "
           href="/2019/11/06/html/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="HTML">HTML</span>
            <span class="post-date" title="2019-11-06 19:15:21">2019/11/06</span>
        </a>
        
        <a  class="前端 js "
           href="/2019/11/07/js/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="js汇总">js汇总</span>
            <span class="post-date" title="2019-11-07 07:51:21">2019/11/07</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-js" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">js汇总</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a href="javascript:" target="_blank" data-rel="前端 noopener">前端</a>/
            
                <a href="javascript:" target="_blank" data-rel="js noopener">js</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2019-11-07 08:12:42'>2019-11-07 07:51</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:25.9k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#js的基础介绍"><span class="toc-text">js的基础介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#数据类型"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#算术运算符"><span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#变量及命名规则"><span class="toc-text">变量及命名规则</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#switch结构"><span class="toc-text">switch结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#变量的声明提升"><span class="toc-text">变量的声明提升</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数组的概念"><span class="toc-text">数组的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#push-pop-末增-删"><span class="toc-text">push/pop(末增/删)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#concat合并"><span class="toc-text">concat合并</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#shift-unshift-首增-删"><span class="toc-text">shift/unshift(首增/删)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#slice复制"><span class="toc-text">slice复制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#splice删除"><span class="toc-text">splice删除</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#join分隔符"><span class="toc-text">join分隔符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#严格模式"><span class="toc-text">严格模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#eval作用域"><span class="toc-text">eval作用域</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#map方法-遍历"><span class="toc-text">map方法-遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#forEach-遍历"><span class="toc-text">forEach-遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#filter过滤"><span class="toc-text">filter过滤</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#reduce依次处理数组成员"><span class="toc-text">reduce依次处理数组成员</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#indexOf-lastIndexOf"><span class="toc-text">indexOf(),lastIndexOf()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#字符串的创建"><span class="toc-text">字符串的创建</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#slice复制1"><span class="toc-text">slice复制1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#substring复制2"><span class="toc-text">substring复制2</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#substr复制3"><span class="toc-text">substr复制3</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#indexOf-lastIndexOf查找下标"><span class="toc-text">indexOf,lastIndexOf查找下标</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#trim去除空格"><span class="toc-text">trim去除空格</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#toLowerCase-toUpperCase大小写"><span class="toc-text">toLowerCase,toUpperCase大小写</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#replace替换"><span class="toc-text">replace替换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ASCII码"><span class="toc-text">ASCII码</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math-amp-amp-Date"><span class="toc-text">Math&amp;&amp;Date</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Math"><span class="toc-text">Math</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#二、Math方法"><span class="toc-text">二、Math方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Math-abs"><span class="toc-text">Math.abs</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Math-max-min"><span class="toc-text">Math.max/min</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#随机数"><span class="toc-text">随机数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Date"><span class="toc-text">Date</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Date日期处理"><span class="toc-text">Date日期处理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Date静态方法"><span class="toc-text">Date静态方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定时器"><span class="toc-text">定时器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BOM-amp-amp-DOM"><span class="toc-text">BOM&amp;&amp;DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BOM"><span class="toc-text">BOM</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#BOM概念"><span class="toc-text">BOM概念</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DOM"><span class="toc-text">DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#滚动监听"><span class="toc-text">滚动监听</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#创建、添加"><span class="toc-text">创建、添加</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#替换"><span class="toc-text">替换</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM-1"><span class="toc-text">DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#属性节点"><span class="toc-text">属性节点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js正则"><span class="toc-text">js正则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6"><span class="toc-text">ES6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js动画"><span class="toc-text">js动画</span></a>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="js的基础介绍"><a href="#js的基础介绍" class="headerlink" title="js的基础介绍"></a>js的基础介绍</h3><ul>
<li>js的组成<ul>
<li>ECMAscript</li>
<li>BOM</li>
<li>DOM</li>
</ul>
</li>
</ul>
<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><ul>
<li><p>javascript的数据类型</p>
<ul>
<li>数值</li>
<li>字符串</li>
<li>布尔值</li>
<li>undefined</li>
<li>null</li>
<li>对象</li>
</ul>
</li>
<li><p>JavaScript的数据类型转换</p>
<ul>
<li>显性转换</li>
<li>隐性转换</li>
</ul>
</li>
</ul>
<h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><ul>
<li><p>算术运算符</p>
<ul>
<li>+  -   *  /      %</li>
</ul>
</li>
<li><p>赋值运算符</p>
<ul>
<li>=   +=  -=  *=   /=  %=</li>
</ul>
</li>
<li><p>关系运算符</p>
<ul>
<li>&gt;    &lt;   &gt;=   &lt;=   ==  !=    ===   !== </li>
</ul>
</li>
</ul>
<pre><code>var num = 3.11111
num.toFixed(3)

// toFixed(n) 保留n位小数</code></pre><h5 id="变量及命名规则"><a href="#变量及命名规则" class="headerlink" title="变量及命名规则"></a>变量及命名规则</h5><p>变量的声明和定义</p>
<pre><code>var  a = 10;</code></pre><p>var是关键字， a是变量名， </p>
<p>=是赋值符号 10是值<br>变量的命名规则<br>    变量是由数字、字母、下划线（_）和美元符号（$）的一种或者几种组成，且不能以数字开头,严格区分大小写。<br>    （驼峰法则，见名知义）<br>关键字</p>
<pre><code>script标签写在body结束标签之前
praseInt（1.67）取整为1,不四舍五入

let num = 1.8888;
console.log(num.toFixed(2));保留两位小数为1.89，并四舍五入

字符转转数字
parseInt() //数字，取整
parseFloat() //浮点数，小数
Number()//数字

数字转字符串
parseString</code></pre><p>##逻辑分支</p>
<p>####基本结构</p>
<pre><code>顺序结构
    从上到下执行
逻辑分支结构
    if语句
    switch语句
循环结构
    while循环
    for循环</code></pre><p>######逻辑分支结构if语句</p>
<pre><code>逻辑分支结构，选择结构
也叫条件语句

一 、if 结构（单分支）
if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，true表示真，false表示伪。
if (布尔值)
  语句;
// 或者
if (布尔值) 语句;

上面是if结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为true，就执行紧跟在后面的语句；如果结果为false，则跳过紧跟在后面的语句。</code></pre><p>######三目运算符</p>
<pre><code class="javascript">//!a 单目
//a+b 双目

//表达式1? 表达式2 : 表达式3
//如果表达式1为true，表达式2的值就是整个式子的值，反之表达式3就是整个式子的值
var a = 1;
let b = 0;
b = a == 1 ?2 : 3; //三目</code></pre>
<p>######二、八、十六进制</p>
<pre><code class="javascript">//二进制
    console.log(011)//1*2^0+1*2^1 = 3
//八进制（0-7）
    console.log(071)//1*8^0+7*8^1 = 071
//十六进制（0-9/a-f）
    console.log(0x11a)//10*16^0+1*16^1+1*16^2
//十进制转任意进制
//tostring(进制值)；
    let a = 100;
    console.log(aa.toString(2));
    console.log(aa.toString(8));
    console.log(aa.toString(16));</code></pre>
<h6 id="switch结构"><a href="#switch结构" class="headerlink" title="switch结构"></a>switch结构</h6><pre><code class="javascript">switch (变量名) {
  case &quot;变量值1&quot;:
    // ...当变量的值为变量值1的时候所执行的代码
    break;//跳出循环，不往下执行
  case &quot;变量值1&quot;:
    // ...当变量的值为变量值2的时候所执行的代码
    break;
  default:
    // ...除了上面的变量值的所有情况而执行的代码
}
//上面代码根据变量fruit的值，选择执行相应的case。
//如果所有case都不符合，则执行最后的default部分。
//注意：每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。

//case代码块之中没有break语句，导致不会跳出switch结构，而会一直执行下去。这种效果叫穿透。</code></pre>
<p>######NaN转换类型</p>
<pre><code class="javascript">console.log(parseInt(&quot;12px&quot;));//12 只转开头的整数
console.log(parseInt(&quot;aa12px&quot;));//NaN
console.log(Number(&quot;12px&quot;));//NaN ：not a number
console.log(NaN == NaN);//false
console.log(typeof NaN)//number
console.log(typeof typeof NaN)//string
console.log(typeof typeof aaa)//string
console.log(typeof typeof null)//string
console.log(typeof typeof undefined)//string
console.log(isNaN(NaN))//true
console.log(isNaN(&quot;11&quot;))//false
console.log(isNaN(&quot;11px&quot;))//true
/*
isNaN(x)
返回值
如果 x 是特殊的非数字值 NaN（或者能被转换为这样的值），返回的值就是 true。如果 x 是其他值,则返回 false。

说明
isNaN() 函数可用于判断其参数是否是 NaN，该值表示一个非法的数字（比如被 0 除后得到的结果）。

如果把 NaN 与任何值（包括其自身）相比得到的结果均是 false，所以要判断某个值是否是 NaN，不能使用 == 或 === 运算符。正因为如此，isNaN() 函数是必需的。
*/</code></pre>
<p>##循环语句</p>
<p>######while循环 </p>
<pre><code class="javascript">let i = 0;
while(i&lt;10){
    //执行的语句
}</code></pre>
<p>######do while循环</p>
<pre><code class="javascript">//先执行一次，再去判断条件
let i = 0;
do{
    i++;
}while{
    //执行的语句
}</code></pre>
<p>######for循环</p>
<pre><code class="javascript">for(var i=0;i&lt;10;i++){
    //执行的语句
}</code></pre>
<p>######break 和 continue </p>
<pre><code>break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。

break语句用于跳出代码块或结束循环。
continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。</code></pre><p>##函数</p>
<p>####函数的概念及创建</p>
<p>######函数的概念</p>
<pre><code>函数是一段可以反复调用的代码块。
作用：
    在程序设计中，常将一些常用的功能模块编写成函数，以减少重复编写程序段的工作量。
    提高代码的复用性、可读性等</code></pre><p>######函数的创建</p>
<pre><code class="javascript">函数的创建方式（函数的声明）
（1）function 命令
function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号。函数体放在大括号里面。
    function 函数名称() {
            //函数中要执行的代码;
     }
    function print() {
          console.log(1);
    }
上面的代码命名了一个print函数，以后使用print()这种形式，就可以调用相应的代码。这叫做函数的声明
（2）函数表达式
除了用function命令声明函数，还可以采用变量赋值的写法。
    var print = function() {
          console.log(1);
    };
这种写法将一个匿名函数（没有名字的函数）赋值给变量。这时，这个匿名函数又称函数表达式

（3）立即调用函数，即直接执行的函数：
(function(){

})()</code></pre>
<p>####函数的调用</p>
<pre><code class="javascript">函数的执行(调用)：
函数定义好之后，函数中的代码在程序运行过程中不会执行；
function print() {
     console.log(1);
}

通过函数名称调用函数，调用时执行函数中的代码；调用函数时，要使用圆括号运算符
function(){
    print();
}</code></pre>
<p>####事件</p>
<p>######鼠标事件</p>
<pre><code class="javascript">/*
onclick            鼠标单击
ondblclick        鼠标双击
onmousedown        鼠标按键按下
onmouseup        鼠标按键抬起
onmousemove        鼠标在元素上移动
onmouseout        鼠标移出
Onmouseenter    鼠标移入
*/</code></pre>
<p>######键盘事件</p>
<pre><code class="javascript">/* 
Onkeydown        键盘按键按下
Onkeyup            键盘按键抬起
onkeypress        键盘按键按住
*/</code></pre>
<p>######表单事件</p>
<pre><code class="javascript">/*
Onblur        失去焦点
Onfocus        获取焦点
Onchange    内容修改
*/</code></pre>
<p>####声明</p>
<p>######函数的声明</p>
<pre><code class="javascript">函数名后面是一对圆括号，里面是传入函数的参数
function 函数名称(参数列表){
    函数体中的代码;
}
函数定义的时候的参数，称为形参
function print(s) { 
  console.log(s);
}
function add(a,b) { 
  console.log(a+b);
}
参数的传递
    print（1）；

调用函数的时候，传入了 参数  1，1的值给了形参s。
函数调用时候传入的参数叫做实参</code></pre>
<h6 id="变量的声明提升"><a href="#变量的声明提升" class="headerlink" title="变量的声明提升"></a>变量的声明提升</h6><pre><code class="javascript">
函数内部会产生“变量提升”现象。在函数内部使用var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。

function foo(x) {
  if (x &gt; 100) {
    var tmp = x - 100;
  }
}

// 等同于
function foo(x) {
  var tmp;
  if (x &gt; 100) {
    tmp = x - 100;
  };
}
</code></pre>
<p>######arguments参数</p>
<pre><code class="javascript">由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。
arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。
var f = function (one) {
  console.log(arguments[0]);
  console.log(arguments[1]);
  console.log(arguments[2]);
}

f(1, 2, 3)
通过arguments对象的length属性，可以判断函数调用时到底带几个参数。</code></pre>
<p>####函数返回值</p>
<pre><code class="javascript">JavaScript 引擎遇到return语句，就直接返回return后面的那个表达式的值,后面即使还有语句，也不会得到执行。
也就是说，return语句所带的那个表达式，就是函数的返回值。

注、return语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回undefined。

function add(x, y) {
  return x + y; //返回x+y的和
}

var res = add(1, 1) ;//把函数的返回值 赋值给 变量res
console.log(res);//2</code></pre>
<p>######作用域</p>
<pre><code class="javascript">作用域:
作用域（scope）指的是变量存在的范围。
局部作用域和全局作用域
          在 ES5 的规范中，Javascript 只有两种作用域：
    一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；
    另一种是函数作用域，变量只在函数内部存在。

  函数外部声明的变量就是全局变量（global variable）
在函数内部定义的(使用var)变量，外部无法读取，顾称为“局部变量”（local variable）
var v = 1;//全局变量
function f() {
  var b = 2;//局部变量
  console.log(b);
  console.log(v);//它在函数内部可以读取全局变量，但是局部变量的不能再函数外部访问
}
f()
上面的代码表明，函数f内部可以读取全局变量v。
列子：</code></pre>
<p>######构造函数</p>
<pre><code class="js">构造函数及对象类型（了解）：
    面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。
    面向对象编程的第一步，就是要生成对象。对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成
    JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。
    构造函数就是一个普通的函数，但是有自己的特征和用法。

function Vehicle  () {
  this.price = 1000;
};
上面代码中，Vehicle就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。
构造函数的特点有两个。
         函数体内部使用了this关键字，代表了所要生成的对象实例。
生成对象的时候，必须使用new命令
new命令的作用，就是执行构造函数，返回一个实例对象。

function Vehicle  () {
  this.price = 1000;
};
var v = new Vehicle();
v.price // 1000
    上面代码通过new命令，让构造函数Vehicle生成一个实例对象，保存在变量v中。这个新生成的实例对象，从构造函数Vehicle得到了price属性。new命令执行时，构造函数内部的this，就代表了新生成的实例对象，this.price表示实例对象有一个price属性，值是1000。
function Dog(){

}</code></pre>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="数组的概念"><a href="#数组的概念" class="headerlink" title="数组的概念"></a>数组的概念</h4><p>######1- 数组的概念</p>
<pre><code class="javascript">数组的概念：
所谓数组，是有序的元素序列。（一组有序 数据）
JavaScript的Array可以包含任意数据类型。注：一般来说数组中元素的类型相同

数组的创建方式
1-字面量
var arr = [1, 2];//数组中有两个元素
arr.length ;//获取数组的长度
arr[i]//获取数组中的第i个元素，i称为数组的下标或者索引，下标从0开始
arr[0]//获取数组中的第一个元素    
arr[0] = 100;//修改数组中第一个元素的值为100 </code></pre>
<p>######2- 构造函数方式创建数组</p>
<pre><code class="javascript">Array是一个构造函数，可以用它生成新的数组
var arr = new Array(2);
arr.length // 2
arr[0]//undefined
上面代码中，Array构造函数的参数2，表示生成一个两个成员的数组。 

Array构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。
// 单个非数值（比如字符串、布尔值、对象等）作为参数，
// 则该参数是返回的新数组的成员
new Array(&#39;abc&#39;) // [&#39;abc&#39;]
// 多参数时，所有参数都是返回的新数组的成员
new Array(1, 2) // [1, 2]
new Array(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
可以看到，Array作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。
</code></pre>
<p>####数组的操作</p>
<pre><code class="javascript">数组的操作
//push/pop/unshift/shift</code></pre>
<h6 id="push-pop-末增-删"><a href="#push-pop-末增-删" class="headerlink" title="push/pop(末增/删)"></a>push/pop(末增/删)</h6><pre><code class="javascript">push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组
var arr = [];
arr.push(1)         // 1
arr.push(&#39;a&#39;)        // 2
arr.push(true, {})    // 4
arr        // [1, &#39;a&#39;, true, {}]



pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。
var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
arr.pop() // &#39;c&#39;
arr // [&#39;a&#39;, &#39;b&#39;]
对空数组使用pop方法，不会报错，而是返回undefined。
push和pop结合使用，就构成了“后进先出”的栈结构（stack）。
var arr = [];
arr.push(1, 2);
arr.push(3);//1,2,3
arr.pop();
arr // [1, 2]
上面代码中，3是最后进入数组的，但是最早离开数组。</code></pre>
<h6 id="concat合并"><a href="#concat合并" class="headerlink" title="concat合并"></a>concat合并</h6><pre><code class="js">concat  合并数组(不改变原数组)
var arr2=[1,3];
var arr3=[2,4];
arr2.concat(arr3);
//arr2不变，arr3变成1,2,3,4</code></pre>
<h6 id="shift-unshift-首增-删"><a href="#shift-unshift-首增-删" class="headerlink" title="shift/unshift(首增/删)"></a>shift/unshift(首增/删)</h6><pre><code class="javascript">shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。
var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.shift() // &#39;a&#39;
a // [&#39;b&#39;, &#39;c&#39;]




push和shift结合使用，就构成了“先进先出”的队列结构（queue）。
unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。
var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.unshift(&#39;x&#39;); // 4
a // [&#39;x&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre>
<h6 id="slice复制"><a href="#slice复制" class="headerlink" title="slice复制"></a>slice复制</h6><pre><code class="javascript">slice方法用于复制目标数组的一部分，返回一个新数组，原数组不变。
arr.slice(start, end);
它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。

var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.slice(0) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
a.slice(1) // [&quot;b&quot;, &quot;c&quot;]
a.slice(1, 2) // [&quot;b&quot;]
a.slice(2, 6) // [&quot;c&quot;]
a.slice() // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
//上面代码中，最后一个例子slice没有参数，实际上等于返回一个原数组的拷贝。

如果slice方法的参数是负数，则表示倒数计算的位置。
var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.slice(-2) // [&quot;b&quot;, &quot;c&quot;]
a.slice(-2, -1) // [&quot;b&quot;]
//上面代码中，-2表示倒数计算的第二个位置，-1表示倒数计算的第一个位置。

如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。
var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.slice(4) // []
a.slice(2, 1) // []

如果slice方法的参数是负数，则表示倒数计算的位置。
var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.slice(-2) // [&quot;b&quot;, &quot;c&quot;]
a.slice(-2, -1) // [&quot;b&quot;]
//上面代码中，-2表示倒数计算的第二个位置，-1表示倒数计算的第一个位置。

如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。
var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.slice(4) // []
a.slice(2, 1) // []</code></pre>
<h6 id="splice删除"><a href="#splice删除" class="headerlink" title="splice删除"></a>splice删除</h6><pre><code class="javascript">var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;];
a.splice(-4, 2) // [&quot;c&quot;, &quot;d&quot;]
//上面代码表示，从倒数第四个位置c开始删除两个成员。

如果只是单纯地插入元素，splice方法的第二个参数可以设为0。
var a = [1, 1, 1];
a.splice(1, 0, 2) // []  在 删除位置的前面添加了
a // [1, 2, 1, 1]

如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。
var a = [1, 2, 3, 4];
a.splice(2) // [3, 4]
a // [1, 2]</code></pre>
<p>######reverse/sort颠倒/排序</p>
<pre><code class="javascript">reverse方法用于颠倒排列数组元素，返回改变后的数组(还是原数组)。注意，该方法将改变原数组。
var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.reverse() // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
a // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]

sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。
[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;].sort();
// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
[4, 3, 2, 1].sort();
// [1, 2, 3, 4]
[11, 101].sort();
// [101, 11]
[10111, 1101, 111].sort();
// [10111, 1101, 111]
//上面代码的最后两个例子，需要特殊注意。sort方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。

如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。
[10111, 1101, 111].sort(function (a, b) {
  return a - b;//升序
})
// [111, 1101, 10111]
//上面代码中，sort的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面</code></pre>
<h6 id="join分隔符"><a href="#join分隔符" class="headerlink" title="join分隔符"></a>join分隔符</h6><pre><code class="javascript">//join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。
var a = [1, 2, 3, 4];
a.join(&#39; &#39;) // &#39;1 2 3 4&#39;
a.join(&#39; | &#39;) // &quot;1 | 2 | 3 | 4&quot;
a.join() // &quot;1,2,3,4&quot;

//如果数组成员是undefined或null或空位，会被转成空字符串。
[undefined, null].join(&#39;#&#39;)
// &#39;#&#39;

[&#39;a&#39;,, &#39;b&#39;].join(&#39;-&#39;)
// &#39;a--b&#39;</code></pre>
<p>####数组小总结</p>
<pre><code class="javascript">数组：储存一组有序的数据
数组的作用：一次性储存多个数据
数组的定义方式：
 1.构造函数定义数组：var 数组名 = new Array();
 2.字面量方式定义数组：var 数组名 = [];

var 数组名=new Array();//空数组
var 数组名=new Array(值);//数组定义了，有长度
var 数组名=new Array(值1，值2，值3...);//数组定义并且有多个数据
var 数组名=[];//空数组
var 数组名=[值1，值2，值3]；//有三个数据
数组元素：就是数组中储存的数据
数组长度：就是数组中元素的个数
数组索引(下标)：从0开始，到数组的长度减1结束
通过下标设置数组的元素值：数组名[索引]=值
通过下标访问数组的元素值：数组名[索引]

var arr1=new Array();//空数组
var arr2=new Array(5);//数组的长度为5
var arr3=new Array(1,2,3,4,5);//数组长度为5，并且有5个值
var arr4=[];//空数组
var arr5=[1,2,3]//三个值
var arr6=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,1,true];//数组内的值的类型可以不一样
var arr7=[];
//设置数组元素的值
arr7[0]=10;
arr7[1]=20;

方法：
push//数组尾部新增
pop//数组尾部删除
unshift//数组头部新增
shift//数组头部删除
slice//复制数组中的一部分
splice//删除数组中的一部分
reverse//颠倒数组
sort//排序
join//设置链接符号--分隔符，链接数组元素返回字符串</code></pre>
<p>##ES5严格模式、数组新增、字符串</p>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><pre><code class="js">//严格模式:
除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。
同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行。
设计目的
早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。
严格模式是从 ES5 进入标准的，主要目的有以下几个。
明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。
增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。
提高编译器效率，增加运行速度。
为未来新版本的 JavaScript 语法做好铺垫。
总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向

//启用方法:
进入严格模式的标志，是一行字符串use strict。
&#39;use strict&#39;;
老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。
严格模式可以用于整个脚本，也可以只用于单个函数
（1） 整个脚本文件
use strict放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。(严格地说，只要前面不是产生实际运行结果的语句，use strict可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。)
</code></pre>
<h6 id="eval作用域"><a href="#eval作用域" class="headerlink" title="eval作用域"></a>eval作用域</h6><pre><code class="js">创设 eval 作用域
正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。

正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，eval所生成的变量只能用于eval内部。

(function () {
  &#39;use strict&#39;;
  var x = 2;
  console.log(eval(&#39;var x = 5; x&#39;)) // 5
  console.log(x) // 2
})()
上面代码中，由于eval语句内部是一个独立作用域，所以内部的变量x不会泄露到外部</code></pre>
<p>####ES5数组新增方法</p>
<p>######静态方法isArray</p>
<pre><code class="javascript">静态方法
Array.isArray()
Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足。
var arr = [1, 2, 3];
typeof arr // &quot;object&quot;
Array.isArray(arr) // true
上面代码中，typeof运算符只能显示数组的类型是Object，而Array.isArray方法可以识别数组。</code></pre>
<p>######for in遍历</p>
<pre><code>for in 循环遍历</code></pre><h6 id="map方法-遍历"><a href="#map方法-遍历" class="headerlink" title="map方法-遍历"></a>map方法-遍历</h6><pre><code class="js">map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。

map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身。

[1, 2, 3].map(function(elem, index, arr) {
  return elem * index;
});
// [0, 2, 6]
上面代码中，map方法的回调函数有三个参数，elem为当前成员的值，index为当前成员的位置，arr为原数组（[1, 2, 3]）</code></pre>
<h6 id="forEach-遍历"><a href="#forEach-遍历" class="headerlink" title="forEach-遍历"></a>forEach-遍历</h6><pre><code class="js">//forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。
forEach的用法与map方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。
function log(element, index, array) {
  console.log(&#39;[&#39; + index + &#39;] = &#39; + element);
}
[2, 5, 9].forEach(log);
// [0] = 2
// [1] = 5
// [2] = 9

//注意，forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。
var arr = [1, 2, 3];
for (var i = 0; i &lt; arr.length; i++) {
  if (arr[i] === 2) break;
  console.log(arr[i]);
}</code></pre>
<h6 id="filter过滤"><a href="#filter过滤" class="headerlink" title="filter过滤"></a>filter过滤</h6><pre><code class="js">filter()
filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。
它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。

filter方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。
var res = [1, 2, 3, 4, 5].filter(function (elem, index, arr) {
  return index % 2 === 0;
});
res// [1, 3, 5]
上面代码返回偶数位置的成员组成的新数组。</code></pre>
<h6 id="reduce依次处理数组成员"><a href="#reduce依次处理数组成员" class="headerlink" title="reduce依次处理数组成员"></a>reduce依次处理数组成员</h6><pre><code class="js">reduce方法依次处理数组的每个成员，最终累计为一个值。reduce是从左到右处理（从第一个成员到最后一个成员）
reduce方法参数是一个函数,该函数接受以下两个参数。
1累积变量，默认为数组的第一个成员
2当前变量，默认为数组的第二个成员
var res = [1, 2, 3, 4, 5].reduce(function (a, b) {
  console.log(a, b);
  return a + b;
})
// 1 2
// 3 3
// 6 4
// 10 5
res//最后结果：15

上面代码中，reduce方法求出数组所有成员的和。第一次执行，a是数组的第一个成员1，b是数组的第二个成员2。第二次执行，a为上一轮的返回值3，b为第三个成员3。第三次执行，a为上一轮的返回值6，b为第四个成员4。第四次执行，a为上一轮返回值10，b为第五个成员5。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值15。</code></pre>
<h6 id="indexOf-lastIndexOf"><a href="#indexOf-lastIndexOf" class="headerlink" title="indexOf(),lastIndexOf()"></a>indexOf(),lastIndexOf()</h6><pre><code class="js">//indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。
var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.indexOf(&#39;b&#39;) // 1
a.indexOf(&#39;y&#39;) // -1
//indexOf方法还可以接受第二个参数，表示搜索的开始位置。
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].indexOf(&#39;a&#39;, 1) // -1
//上面代码从1号位置开始搜索字符a，结果为-1，表示没有搜索到。
------------------------------------------
lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。
var a = [2, 5, 9, 2];
a.lastIndexOf(2) // 3
a.lastIndexOf(7) // -1
注意，这两个方法不能用来搜索NaN的位置，即它们无法确定数组成员是否包含NaN。

[NaN].indexOf(NaN) // -1
[NaN].lastIndexOf(NaN) // -1
这是因为这两个方法内部，使用严格相等运算符（===）进行比较，
而NaN是唯一一个不等于自身的值</code></pre>
<p>####字符串</p>
<h6 id="字符串的创建"><a href="#字符串的创建" class="headerlink" title="字符串的创建"></a>字符串的创建</h6><pre><code class="js">字符串的创建方式
var s1 = &#39;abc&#39;;
var s2 = new String(&#39;abc&#39;);
typeof s1 // &quot;string&quot;
typeof s2 // &quot;object&quot;
所以,String对象也叫包装对象
除了用作构造函数，String对象还可以当作工具方法使用，将任意类型的值转为字符串。
String(true) // &quot;true&quot;
String(5) // &quot;5&quot;
上面代码将布尔值ture和数值5，分别转换为字符串

var a=&#39;abc&#39;;//字面量字符串
var b=``;

字符串实例的length属性返回字符串的长度。
&#39;abc&#39;.length // 3

字符串对象是一个类似数组的对象（很像数组，但不是数组）。
new String(&#39;abc&#39;)
// String {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3}
(new String(&#39;abc&#39;))[1] // &quot;b&quot;
上面代码中，字符串abc对应的字符串对象，有数值键（0、1、2）和length属性，所以可以像数组那样取值。</code></pre>
<p>####字符串方法</p>
<p>######charAt下标</p>
<pre><code class="js">charAt方法返回指定位置的字符，参数是从0开始编号的位置。
var s = new String(&#39;abc&#39;);
这个方法完全可以用数组下标替代。
&#39;abc&#39;.charAt(1) // &quot;b&quot;
&#39;abc&#39;[1] // &quot;b&quot;</code></pre>
<h6 id="slice复制1"><a href="#slice复制1" class="headerlink" title="slice复制1"></a>slice复制1</h6><pre><code class="js">slice方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。
&#39;JavaScript&#39;.slice(0, 4) // &quot;Java&quot;
如果省略第二个参数，则表示子字符串一直到原字符串结束。
如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。
如果第一个参数大于第二个参数，slice方法返回一个空字符串。 </code></pre>
<h6 id="substring复制2"><a href="#substring复制2" class="headerlink" title="substring复制2"></a>substring复制2</h6><pre><code class="js">substring方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。
如果省略第二个参数，则表示子字符串一直到原字符串的结束。
如果第二个参数大于第一个参数，substring方法会自动更换两个参数的位置。
&#39;JavaScript&#39;.substring(10, 4) // &quot;Script&quot;
// 等同于
&#39;JavaScript&#39;.substring(4, 10) // &quot;Script&quot;</code></pre>
<h6 id="substr复制3"><a href="#substr复制3" class="headerlink" title="substr复制3"></a>substr复制3</h6><pre><code>substr方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice和substring方法的作用相同。
substr方法的第一个参数是子字符串的开始位置（从0开始计算），第二个参数是子字符串的长度。
如果省略第二个参数，则表示子字符串一直到原字符串的结束。
&#39;JavaScript&#39;.substr(4) // &quot;Script&quot;
如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。
&#39;JavaScript&#39;.substr(-6) // &quot;Script&quot;</code></pre><h6 id="indexOf-lastIndexOf查找下标"><a href="#indexOf-lastIndexOf查找下标" class="headerlink" title="indexOf,lastIndexOf查找下标"></a>indexOf,lastIndexOf查找下标</h6><pre><code class="js">indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。
&#39;hello world&#39;.indexOf(&#39;o&#39;) // 4
&#39;JavaScript&#39;.indexOf(&#39;script&#39;) // -1
indexOf方法还可以接受第二个参数，表示从该位置开始向后匹配。
&#39;hello world&#39;.indexOf(&#39;o&#39;, 6) // 7
lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。

&#39;hello world&#39;.lastIndexOf(&#39;o&#39;) // 7
另外，lastIndexOf的第二个参数表示从该位置起向前匹配。
&#39;hello world&#39;.lastIndexOf(&#39;o&#39;, 6) // 4</code></pre>
<h6 id="trim去除空格"><a href="#trim去除空格" class="headerlink" title="trim去除空格"></a>trim去除空格</h6><pre><code class="js">trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。
&#39;  hello world  &#39;.trim()// &quot;hello world&quot;
该方法去除的不仅是空格，还包括制表符（\t、\v）、换行符（\n）和回车符（\r）。
&#39;\r\nabc \t&#39;.trim() // &#39;abc&#39;</code></pre>
<h6 id="toLowerCase-toUpperCase大小写"><a href="#toLowerCase-toUpperCase大小写" class="headerlink" title="toLowerCase,toUpperCase大小写"></a>toLowerCase,toUpperCase大小写</h6><pre><code class="js">toLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。它们都返回一个新字符串，不改变原字符串。
&#39;Hello World&#39;.toLowerCase()
// &quot;hello world&quot;
&#39;Hello World&#39;.toUpperCase()
// &quot;HELLO WORLD&quot;</code></pre>
<h6 id="replace替换"><a href="#replace替换" class="headerlink" title="replace替换"></a>replace替换</h6><pre><code class="js">replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。
&#39;aaa&#39;.replace(&#39;a&#39;, &#39;b&#39;) // &quot;baa&quot;
&#39;aaa&#39;.replace(/a/g, &#39;b&#39;) // &quot;bbb&quot;</code></pre>
<p>######split分割</p>
<pre><code class="js">split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。
&#39;a|b|c&#39;.split(&#39;|&#39;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。
&#39;a|b|c&#39;.split(&#39;&#39;) // [&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;]
//注：数组join可将数组转为字符串split，join可互换</code></pre>
<h6 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h6><pre><code class="js">ASCII码和字符集

字符串常见API(charCodeAt\fromCharCode)
charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。
&#39;abc&#39;.charCodeAt(1) // 98
上面代码中，abc的1号位置的字符是b，它的 Unicode 码点是98。
String.fromCharCode()
String对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。

String.fromCharCode() // &quot;&quot;
String.fromCharCode(97) // &quot;a&quot;
String.fromCharCode(104, 101, 108, 108, 111)
// &quot;hello&quot;

统计字符串中每个字符的个数</code></pre>
<p>####总结</p>
<pre><code class="js">ES5数组：
//方法:
            isArray//静态方法 判断数组
            map//遍历数组进行传值--有返回值
             forEach//遍历数组进行传值--无返回值
             filter//过滤
             reduce//依次处理数组元素
             indexOf,lastIndexOf//查找下标

字符串：
//创建 属性 方法:    
            //字面量
            var username = &#39;zhangsan&#39;
            //es6 模板字符串  中间可以使用${变量}
            let str = `
            afa
            asdfa 
            姓名是${username},年龄是${age}
            `;
            //字符串对象  包装对象 像数组  伪数组 
            let str2 = new String(&#39;aadsd&#39;)
//方法:
            charAt//下标
            slice//复制(取出)
            substring//复制(取出)
            substr//复制(取出)
            indexOf,lastIndexOf//查找下标
            trim//去除空格
            toLowerCase//大小写
            replace//替换
            split//分割</code></pre>
<h2 id="Math-amp-amp-Date"><a href="#Math-amp-amp-Date" class="headerlink" title="Math&amp;&amp;Date"></a>Math&amp;&amp;Date</h2><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><p>#####一、Math介绍</p>
<pre><code class="js">Math是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。

Math对象的属性，提供以下一些数学常数。（了解）
Math.E：常数e。
Math.PI：常数 Pi。</code></pre>
<h5 id="二、Math方法"><a href="#二、Math方法" class="headerlink" title="二、Math方法"></a>二、Math方法</h5><h6 id="Math-abs"><a href="#Math-abs" class="headerlink" title="Math.abs"></a>Math.abs</h6><pre><code class="js">//Math.abs方法返回参数值的绝对值。
Math.abs(1) // 1
Math.abs(-1) // 1</code></pre>
<h6 id="Math-max-min"><a href="#Math-max-min" class="headerlink" title="Math.max/min"></a>Math.max/min</h6><pre><code class="js">Math.max方法返回参数之中最大的那个值，Math.min返回最小的那个值。如果参数为空, Math.min返回Infinity, Math.max返回-Infinity。

Infinity 用于存放表示正无穷大的数值

Math.max(2, -1, 5) // 5
Math.min(2, -1, 5) // -1
Math.min() // Infinity  
Math.max() // -Infinity</code></pre>
<p>######Math.floor/ceil最大/最小整数值</p>
<pre><code class="js">Math.floor方法小于参数值的最大整数（地板值）。
Math.floor(3.2) // 3
Math.floor(-3.2) // -4

Math.ceil方法返回大于参数值的最小整数（天花板值）。
Math.ceil(3.2) // 4
Math.ceil(-3.2) // -3</code></pre>
<p>######Math.round四舍五入</p>
<pre><code class="js">Math.round方法用于四舍五入。
Math.round(0.1) // 0
Math.round(0.5) // 1
Math.round(0.6) // 1
Math.round(-1.1) // -1
Math.round(-1.5) // -1
Math.round(-1.6) // -2</code></pre>
<p>######Math.pow平方</p>
<pre><code class="js">Math.pow方法返回以第一个参数为底数、第二个参数为幂的指数值。
// 等同于 2 ** 2
Math.pow(2, 2) // 4
// 等同于 2 ** 3
Math.pow(2, 3) // 8</code></pre>
<p>######Math.sqrt平方根</p>
<pre><code class="js">Math.sqrt方法返回参数值的平方根。如果参数是一个负值，则返回NaN。
Math.sqrt(4) // 2
Math.sqrt(-4) // NaN

勾股定理复习

a^2+b^2=c^2</code></pre>
<p>######三角函数</p>
<pre><code class="js">Math对象还提供一系列三角函数方法
Math.sin()：返回参数的正弦（参数为弧度值）
Math.cos()：返回参数的余弦（参数为弧度值）
Math.tan()：返回参数的正切（参数为弧度值）
30*Math.PI/180   角度转为弧度

Math.sin(0) // 0
Math.cos(0) // 1
Math.tan(0) // 0
Math.sin(Math.PI / 2) // 1</code></pre>
<h6 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h6><pre><code class="js">Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。
Math.random() // 0.7151307314634323

任意范围的随机整数生成函数如下。
function getRandomInt(min, max) {
  return parseInt(Math.random() * (max - min + 1)) + min;
}
getRandomInt(1, 6) // 5</code></pre>
<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><pre><code class="js">作为构造函数时，Date对象可以接受多种格式的参数，返回一个该参数对应的时间实例。
// 参数为时间零点开始计算的毫秒数
new Date(1378218728000)（最常用）
// Tue Sep 03 2013 22:32:08 GMT+0800 (CST)
/ 参数为多个整数，
// 代表年、月、日、小时、分钟、秒、毫秒
new Date(2013, 0, 1, 0, 0, 0, 0)
// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)
参数也可以是一个字符串（最常用）
日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即YYYY-MM-DDTHH:mm:ss.sssZ格式
new Date(&#39;2013-2-15&#39;)
new Date(&#39;2013/2/15&#39;)
new Date(&#39;02/15/2013&#39;)
new Date(&#39;2013-FEB-15&#39;)
new Date(&#39;FEB, 15, 2013&#39;)
new Date(&#39;Feberuary, 15, 2013&#39;)
new Date(&#39;15 Feb 2013&#39;)
new Date(&#39;15, Feberuary, 2013&#39;) 
 上面多种日期字符串的写法，返回的都是同一个时间
</code></pre>
<h6 id="Date日期处理"><a href="#Date日期处理" class="headerlink" title="Date日期处理"></a>Date日期处理</h6><pre><code class="js">//获取:
            oDate.getDate()            //返回一个月中的某一天 (1 ~ 31)
            oDate.getDay()            //返回一周中的某一天 (0 ~ 6)
            oDate.getMonth()        //返回月份 (0 ~ 11)
            oDate.getFullYear()        //以四位数字返回年份
            oDate.getHours()        //返回当前小时（0-23）
            oDate.getMinutes()        //返回当前分钟 (0 ~ 59)
            oDate.getSeconds()        //返回当前秒(0 ~ 59)
            oDate.getMillisenconds()//返回当前毫秒(0 ~ 999)
            //注意，月份从0开始计算，但是，天数从1开始计算。另外，除了日期的默认值为1，小时、分钟、秒钟和毫秒的默认值都是0。
            new Date(2013, 15)
            // Tue Apr 01 2014 00:00:00 GMT+0800 (CST)

//设置：
            oDate.getTime()返回1970年1月1日至今的毫秒数
            oDate.setDate();        //设置月中的某一天 (1 ~ 31)
            oDate.setMonth();        //设置月份 (0 ~ 11)
            //例：oDate.setMonth(9);  alert(oDate.getMonth())
            oDate.setFullYear();    //设置年份（四位数）
            oDate.setHours();        //设置小时（0-23）
            oDate.setMinutes();        //设置分钟 (0 ~ 59)
            oDate.setSeconds();        //设置秒(0 ~ 59)
            oDate.setMillisenconds();//设置毫秒(0 ~ 999)
            oDate.setTime();        //设置1970年1月1日至今的毫秒数
            //这些参数如果超出了正常范围，会被自动折算。比如，如果月设为15，就折算为下一年的4月</code></pre>
<h6 id="Date静态方法"><a href="#Date静态方法" class="headerlink" title="Date静态方法"></a>Date静态方法</h6><pre><code class="js">Date.parse方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。
日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即YYYY-MM-DDTHH:mm:ss.sssZ格式，其中最后的Z表示时区。但是，其他格式也可以被解析，请看下面的例子。
Date.parse(&#39;Aug 9, 1995&#39;)
Date.parse(&#39;January 26, 2011 13:51:50&#39;)
Date.parse(&#39;Mon, 25 Dec 1995 13:30:00 GMT&#39;)
Date.parse(&#39;Mon, 25 Dec 1995 13:30:00 +0430&#39;)
Date.parse(&#39;2011-10-10&#39;)
Date.parse(&#39;2011-10-10T14:48:00&#39;)</code></pre>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><pre><code class="js">setInterval（func，time）
有两个参数，第一个参数是一个函数，第二个参数是时间间隔，单位是毫秒
每间隔time毫秒，会执行一次函数
setInterval的返回值是一个数字
function box（）{
    console.log(1)
}
var timer = setInerval(box,1000);
上面代码意思是，没间隔1000毫秒，box函数执行一次。
取消定时器的执行
如果想要取消定时器的执行我们需要拿到setInerval定时器函数的返回值，调用clearInterval，清除定时器
clearInterval（timer），调用之后box函数就不会再执行了！
</code></pre>
<h2 id="BOM-amp-amp-DOM"><a href="#BOM-amp-amp-DOM" class="headerlink" title="BOM&amp;&amp;DOM"></a>BOM&amp;&amp;DOM</h2><h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><h6 id="BOM概念"><a href="#BOM概念" class="headerlink" title="BOM概念"></a>BOM概念</h6><pre><code class="js">BOM的概念
提供了独立于页面内容而与浏览器进行交互的对象，其核心对象是window

在浏览器中，window对象（注意，w为小写）指当前的浏览器窗口。它也是所有对象的顶层对象。

“顶层对象”指的是最高一层的对象，所有其他对象都是它的下属。JavaScript规定，浏览器环境的所有全局变量，都是window对象的属性。

var a = 1;
window.a // 1

上面代码中，变量a是一个全局变量，但是实质上它是window对象的属性。声明一个全局变量，就是为window对象的同名属性赋值
</code></pre>
<p>######navigator.userAgent浏览器类型</p>
<pre><code class="js">//浏览器代理检测，可以检测出来用户使用的浏览器类型，也可以检测浏览器所在的操作系统
    navigator.userAgent
//判断浏览器类型
            var t = navigator.userAgent;
            if(t.indexOf(&#39;Trident&#39;)!= -1){
                console.log(&#39;ie内核&#39;)
            }else if(t.indexOf(&#39;Presto&#39;)!= -1){
                console.log(&#39;欧朋&#39;)
            }else if(t.indexOf(&#39;Chrome&#39;)!= -1){
                console.log(&#39;chrome &#39;)
            }else if(t.indexOf(&#39;Safari&#39;)!= -1){
                console.log(&#39;Safari &#39;)
            }else{
                console.log(&#39;其他&#39;)
            }</code></pre>
<p>######手机类型</p>
<pre><code class="js">//判断是移动端还是PC（重要）
//移动端
            var ua = navigator.userAgent.toLowerCase();
            if (ua.indexOf(&#39;mob&#39;) != -1) {
                console.log(&#39;手机&#39;);
                if (ua.indexOf(&#39;android&#39;) != -1) {
                    console.log(&#39;移动端 安卓&#39;);
                } else if (ua.indexOf(&#39;opod&#39;) != -1 ||
                    ua.indexOf(&#39;iphone&#39;) != -1 ||
                    ua.indexOf(&#39;ipad&#39;) != -1) {
                    console.log(&#39;移动端 苹果手机&#39;);
                }
            } else {
                console.log(&#39;非手机&#39;);
            }</code></pre>
<p>####localhost</p>
<p>######localhost对象</p>
<pre><code class="js">location对象包含有关当前 URL 的信息。
location对象是 Window 对象的一个部分，可通过 window.location 属性来访问。
属性：hash、host、hostname、href、pathname、port、protocol、search
href：        //设置或返回完整的 URL。（常用）
hash：        //设置或返回从井号 (#) 开始的 URL（锚）。
search：        //设置或返回从问号 (?) 开始的 URL（查询部分？id=1&amp;name=abb）。（常用）
host        //设置或返回主机名和当前 URL 的端口号。
hostname    //设置或返回当前 URL 的主机名。
pathname    //设置或返回当前 URL 的路径部分。
port        //设置或返回当前 URL 的端口号。
protocol    //设置或返回当前 URL 的协议。</code></pre>
<p>######location对象 方法</p>
<pre><code class="js">location对象 方法：assign(url), replace(url) , reload()
assign()            //加载新的文档。
reload()            //重新加载当前文档。
replace()            //用新的文档替换当前文档。
window.open();        //打开一个新的浏览器窗口。
window.close();        //关闭浏览器窗口。
alert(arg1)            //显示带有一段消息和一个确认按钮的警告框。
prompt(arg1,arg2)    //显示可提示用户输入的对话框。
confirm(arg1)         //（偶尔）显示带有一段消息以及确认按钮和取消按钮的对话框。

history对象：
   history对象保存着用户上网的历史记录,从窗口被 打开的那一刻算起.
   后退一页  history.go(-1)     history.back()
   前进一页  history.go(1)      history.forward()
   前进两页  history.go(2) 


window.onload：
    load事件发生在文档在浏览器窗口加载完毕时。window.onload属性可以指定这个事件的回调函数。
    window.onload = function() {
        console.log(&#39;页面加载完毕&#39;)
    };
</code></pre>
<p>####定时器和延时器</p>
<pre><code class="js">定时器和延时器：
JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由setTimeout()和setInterval()这两个函数来完成。</code></pre>
<p>######1、延时器</p>
<pre><code class="js">延时器：
    setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。
    var timerId = setTimeout(func, delay);
上面代码中，setTimeout函数接受两个参数，第一个参数func是将要推迟执行的函数名，第二个参数delay是推迟执行的毫秒数。
            console.log(1);
            //推迟执行
            setTimeout(function(){
                console.log(2)
            },1000);
            console.log(3);</code></pre>
<p>######2、定时器</p>
<pre><code class="js">定时器：
    setInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。

            var timer = setInterval(function() {
                console.log(2);
            }, 1000)

    上面代码中，每隔1000毫秒就输出一个2，会无限运行下去，直到关闭当前窗口。</code></pre>
<p>######3、清除定时器</p>
<pre><code class="js">清除定时器：
    setTimeout和setInterval函数，都返回一个整数值，表示计数器编号。将该整数传入clearTimeout和clearInterval函数，就可以取消对应的定时器。
            var id1 = setTimeout(f, 1000);
            var id2 = setInterval(f, 1000);
clearTimeout(id1);
clearInterval(id2);
上面代码中，回调函数f不会再执行了，因为两个定时器都被取消了。</code></pre>
<h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><h6 id="滚动监听"><a href="#滚动监听" class="headerlink" title="滚动监听"></a>滚动监听</h6><pre><code class="js">document.scrollingElement
document.scrollingElement属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。
这个属性返回的文档的根元素document.documentElement（即&lt;html&gt;）。
获取可视区域距离页面顶部的距离
document.scrollingElement.scrollTop;
设置滚动条的距离页面顶面的距离
document.scrollingElement.scrollTop = 0
或者也可以像下面
    获取
  scrollTop = document.scrollingElement.scrollTop
  scrollTop=document.documentElement.scrollTop  || document.body.scrollTop
设置
document.documentElement.scrollTop  = 0
 document.body.scrollTop = 0；</code></pre>
<p>####DOM的基本操作(查询、创建、添加，修改，删除)</p>
<p>######查询</p>
<pre><code class="js">document.getElementById
//方法返回匹配指定id属性的元素节点。如果没有发现匹配的节点，则返回null。
document.getElementsByClassName
//方法返回一个类似数组的对象（HTMLCollection实例），包括了所有class名字符合指定条件的元素（兼容问题，低版本ie）
document.getElementsByTagName
//方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（HTMLCollection实例）
document.querySelector
//方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。
document.querySelectorAll方法与querySelector用法类似，区别是返回一个NodeList对象，包含所有匹配给定选择器的节点。</code></pre>
<pre><code class="js">var id = document.getElementById(&quot;id&quot;);//id
var box = document.getElementsByClassName(&quot;box&quot;);//class
var div = document.getElementsByTagName(&quot;div&quot;);//标签名
var el1 = document.querySelector(&#39;.myclass&#39;);//css选择器
elementList = document.querySelectorAll(&#39;.myclass&#39;);//css选择器都可以</code></pre>
<h6 id="创建、添加"><a href="#创建、添加" class="headerlink" title="创建、添加"></a>创建、添加</h6><pre><code class="js">//创建：
document.createElement方法用来生成元素节点，并返回该节点。
var newDiv = document.createElement(&#39;div&#39;);
createElement方法的参数为元素的标签名，即元素节点的tagName属性，对于 HTML 网页大小写不敏感，即参数为div或DIV返回的是同一种节点
//添加：
oDiv.appendChild(newDiv);
把newDiv添加到oDiv内部的最后面
Element.innerHTML属性返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括&lt;HTML&gt;和&lt;body&gt;元素。
如果将innerHTML属性设为空，等于删除所有它包含的所有节点。
</code></pre>
<h6 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h6><pre><code class="js">//两个参数 新元素 老元素
box.replaceChild(&quot;newNode&quot;,&quot;oldNode&quot;)</code></pre>
<p>######删除</p>
<pre><code class="js">var el = document.getElementById(&#39;mydiv&#39;);
el.remove();
box.removeChild(oldNode)</code></pre>
<p>DOM节点类型(元素和文本)</p>
<blockquote>
<p>DOM节点类型(元素和文本)</p>
<p>DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。</p>
<p>Element：网页的各种HTML标签（比如<body>、<a>等）<br>Text：标签之间或标签包含的文本  （创建Text）<br>注释也是节点 </p>
<p>通过 nodeType属性可以查看类型<br>如果节点是一个元素节点，nodeType 属性返回 1。<br>如果节点是属性节点, nodeType 属性返回 2。<br>如果节点是一个文本节点，nodeType 属性返回 3。<br>如果节点是一个注释节点，nodeType 属性返回 8</p>
</blockquote>
<p>######文档碎片</p>
<pre><code class="js"> 文档碎片  document.createDocumentFragment()  作为容器使用，可以避免频繁操作dom</code></pre>
<h2 id="DOM-1"><a href="#DOM-1" class="headerlink" title="DOM"></a>DOM</h2><h4 id="属性节点"><a href="#属性节点" class="headerlink" title="属性节点"></a>属性节点</h4><p>######属性节点 </p>
<pre><code>    Element.className
    className属性用来读写当前元素节点的class属性。它的值是一个字符串，每个class之间用空格分割。</code></pre><pre><code class="js">// HTML 代码 &lt;div class=&quot;one two three&quot; id=&quot;myDiv&quot;&gt;&lt;/div&gt;
var div = document.getElementById(&#39;myDiv&#39;);
div.className
// &quot;one two three&quot;</code></pre>
<p>######Element.style</p>
<pre><code class="js">每个元素节点都有style用来读写该元素的行内样式信息
不过，连词号需要变成骆驼拼写法。
var divStyle = document.querySelector(&#39;div&#39;).style;
divStyle.backgroundColor = &#39;red&#39;;
divStyle.border = &#39;1px solid black&#39;;
divStyle.width = &#39;100px&#39;;
divStyle.height = &#39;100px&#39;;
divStyle.fontSize = &#39;10em&#39;;

divStyle.backgroundColor // red
divStyle.border // 1px solid black
divStyle.height // 100px
divStyle.width // 100px
Element.style返回的只是行内样式，并不是该元素的全部样式。通过样式表设置的样式，或者从父元素继承的样式，无法通过这个属性得到。元素的全部样式要通过window.getComputedStyle()得到。</code></pre>
<p>######获取属性和设置属性（自定义属性）</p>
<blockquote>
<p>Element.getAttribute方法接受一个字符串作为参数，返回同名属性的值。如果没有该属性，则返回null。</p>
</blockquote>
<pre><code class="js">var mydiv = document.getElementById(&#39;mydiv&#39;);
var id = mydiv.getAttribute(&#39;id&#39;);</code></pre>
<blockquote>
<p>Element.setAttribute方法用于为当前节点设置属性。如果属性已经存在，将更新属性值，否则将添加该属性。该方法没有返回值。</p>
</blockquote>
<pre><code class="js">// HTML 代码为
// &lt;button&gt;Hello World&lt;/button&gt;
var b = document.querySelector(&#39;button&#39;);
b.setAttribute(&#39;name&#39;, &#39;myButton&#39;);
b.setAttribute(&#39;disabled&#39;, true);</code></pre>
<blockquote>
<p>Element.removeAttribute方法移除指定属性。该方法没有返回值。</p>
</blockquote>
<pre><code class="js">document.getElementById(&#39;div1&#39;).removeAttribute(&#39;id&#39;)</code></pre>
<blockquote>
<p>outerHTML/innerText</p>
</blockquote>
<pre><code class="js">outerHTML 
outerHTML  包括整个标签，而不仅限于标签内部的内容

innerText
innerText只获取元素内的文本内容，html标签将被忽略</code></pre>
<p>######获取孩子节点  childNodes和children</p>
<ul>
<li>Element.children属性返回一个类似数组的对象（HTMLCollection实例），包括当前元素节点的所有子元素。如果当前元素没有子元素，则返回的对象包含零个成员</li>
<li>这个属性与Node.childNodes属性的区别是，它只包括元素类型的子节点，不包括其他类型的子节点。而childNodes属性包含空白节点</li>
</ul>
<p>#####offsetWidth/offsetHeight</p>
<ul>
<li>Element.offsetHeight属性返回一个整数，表示元素的 CSS 垂直高度（单位像素），包括元素本身的高度、padding 和 border</li>
<li>Element.offsetWidth属性表示元素的 CSS 水平宽度（单位像素），其他都与Element.offsetHeight一致。<br>这两个属性都是只读属性<br>如果元素的 CSS 设为不可见（比如display: none;），则返回0</li>
<li>Element.offsetParent属性返回最靠近当前元素的、并且 CSS 的position属性不等于static的上层元素。</li>
</ul>
<pre><code class="html">&lt;div style=&quot;position: absolute;&quot;&gt;
  &lt;p&gt;
    &lt;span&gt;Hello&lt;/span&gt;
  &lt;/p&gt;
&lt;/div&gt;</code></pre>
<blockquote>
<p>上面代码中，span元素的offsetParent属性就是div元素。</p>
</blockquote>
<blockquote>
<p>该属性主要用于确定子元素位置偏移的计算基准，<br>Element.offsetTop和Element.offsetLeft就是offsetParent元素计算的。</p>
</blockquote>
<blockquote>
<p>offsetLeft/offsetTop</p>
</blockquote>
<blockquote>
<p>Element.offsetLeft返回当前元素左上角相对于Element.offsetParent节点的水平位移，Element.offsetTop返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移</p>
</blockquote>
<p>####事件</p>
<ul>
<li><p>鼠标事件</p>
<ul>
<li>onclick:用户单击鼠标按钮</li>
<li>ondblclick:当用户双击主鼠标按钮时触发</li>
<li>onmousedown:当用户按下鼠标还未弹起时触发</li>
<li>onmouseup：当用户释放鼠标按钮时触发</li>
<li>onmouseover：当鼠标移到某个元素上方时触发</li>
<li>onmouseout：当鼠标移出某个元素上方时触发</li>
<li>onmousemove：当鼠标指针在元素上移动时触发</li>
</ul>
</li>
<li><p>HTML 事件</p>
<ul>
<li>onload：当页面或者资源完全加载后在 window 上面触发</li>
<li>onselect：当用户选择文本框(input 或 textarea)中的一个或多个字符触发</li>
<li>onchange：当文本框(input 或 textarea)内容改变且失去焦点后触发</li>
<li>onfocus：当页面或者元素获得焦点时在 window 及相关元素上面触发</li>
<li>onblur：当页面或元素失去焦点时在 window 及相关元素上触发</li>
<li>onresize：当窗口或框架的大小变化时在 window 或框架上触发</li>
<li>onscroll：当用户滚动带滚动条的元素时触发</li>
</ul>
</li>
<li><p>键盘事件keyup、keydown、keypress</p>
<ul>
<li>onkeydown：当用户按下键盘上任意键触发，如果按住不放，会重复触发</li>
<li>onkeypress：当用户按下键盘上的字符键触发，如果按住不放，会重复触发</li>
<li>onkeyup：当用户释放键盘上的键触发</li>
<li>组合键ctrkey、altkey、shiftkey</li>
<li>altKey属性，bool类型，表示发生事件的时候alt键是否被按下</li>
<li>ctrlKey属性，bool类型，表示发生事件的时候ctrl键是否被按下</li>
<li>shiftKey属性，bool类型，表示发生事件的时候shift键是否被按下 </li>
<li>keyCode/which兼容</li>
<li>事件源（事件在哪个元素上产生）</li>
</ul>
</li>
</ul>
<p>####事件对象</p>
<ul>
<li><p>当触发某个事件时，会产生一个事件对象，这个对象包含着所有与事件有关的信息 。包括导致事件的元素、事件的类型、以及其它与特定事件相关的信息。</p>
</li>
<li><p>通过事件绑定的执行函数是可以得到一个隐藏参数的 。说明，浏览器会自动分配一个参数，这个参数其实就是 event 对象。</p>
</li>
</ul>
<p>Event对象获取方式    （兼容性）</p>
<pre><code class="js">el.onclick=function(evt){
    let e = evt || window.event
}</code></pre>
<ul>
<li><p>属性</p>
<ul>
<li><p>event.button属性<br>当前事件触发时哪个鼠标按键被点击</p>
</li>
<li><p>clientX、clientY属性<br>鼠标在可视区X坐标和Y坐标，即距离左边框和上边框的距离</p>
</li>
<li><p>screenX、screenY属性<br>鼠标在屏幕区X坐标和Y坐标，即距离左屏幕和上屏幕的距离</p>
</li>
<li><p>offsetX、offsetY属性<br>鼠标相对于事件源的X坐标和Y坐标</p>
</li>
<li><p>pageX、pageY<br>鼠标相对于文档的X坐标和Y坐标</p>
</li>
</ul>
</li>
</ul>
<pre><code class="js">console.log(evt.clientX,evt.clientY);</code></pre>
<p>事件的冒泡</p>
<blockquote>
<p>事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。</p>
</blockquote>
<p>阻止事件冒泡</p>
<pre><code class="js">//阻止事件冒泡
e.stopPropagation();
//低版本ie
e.cancelBubble = true</code></pre>
<p>事件默认行为及阻止方式</p>
<blockquote>
<p>浏览器的默认行为 </p>
<p>JavaScript事件本身所具有的属性，例如a标签的跳转，Submit按钮的提交，右键菜单，文本框的输入等。 </p>
<p>阻止默认行为的方式<br> w3c的方法是<code>e.preventDefault()</code></p>
<p>IE则是使用<code>e.returnValue = false;</code></p>
<p> <code>return false;</code></p>
<p>自定义右键菜单 <code>oncontextmenu</code></p>
</blockquote>
<ul>
<li><p>DOM2级事件处理程序</p>
<ul>
<li><p>添加事件监听器：</p>
<ul>
<li><p>ele.addEventListener(事件名，处理函数，布尔值)<br>现代浏览器（IE9、10、11 | ff, chorme, safari, opera）</p>
</li>
<li><p>注意：事件名不带on，处理函数为函数引用，布尔值代表冒泡(内到外)或捕获（外到内）<br>element.addEventListener(“click”,function(){},false);//false 事件冒泡<br>element.addEventListener(“click”,function(){},true);//true事件捕获<br>  移除事件监听器：removeEventListener(事件名，处理函数)</p>
</li>
<li><p>IE8及以下的事件监听器：attachEvent(事件名，处理函数)，detachEvent(事件名，处理函数)<br>注意：事件名带on</p>
</li>
</ul>
</li>
<li><p>事件委托机制:</p>
<ul>
<li><p>拖拽效果<br>拖拽原理<br>三个事件：onmousedown、onmousemove、onmouseup<br>实现思路：</p>
<p>1：给目标元素添加onmousedown事件，拖拽的前提是在目标元素按下鼠标左键。</p>
<p>2：当onmousedown发生以后，此刻给document添加onmousemove事件，意味着此刻鼠标在网页的移动都将改变目标元素的位置。</p>
<p>3：在onmousemove事件中，设定目标元素的left和top，公式：<br>目标元素的left = 鼠标的clientX – （鼠标和元素的横坐标差，即offsetX）<br>目标元素的top = 鼠标的clientY– （鼠标和元素的纵坐标差，即offsetY）。</p>
<p>4：当onmousedown发生以后，此刻给document添加onmouseup事件，意味着此刻鼠标在网页的任意位置松开鼠标，都会放弃拖拽的效果。</p>
<p>5：在onmouseup事件中，取消document的onmousemove事件即可。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="js正则"><a href="#js正则" class="headerlink" title="js正则"></a>js正则</h2><ul>
<li>####1：正则的概念</li>
</ul>
<blockquote>
<p>正则表达式(regular expression)是一个描述字符规则的对象。可以用来检查一个字符串是否含有某个子字符串，将匹配的子字符串做替换或者从某个字符串中取出符合某个条件的子串等。</p>
</blockquote>
<p>为什么要用正则：</p>
<blockquote>
<p>前端往往有大量的表单数据校验工作，采用正则表达式会使得数据校验的工作量大大减轻。常用效果：邮箱、手机号、身份证号等。</p>
</blockquote>
<ul>
<li>####2：创建方式</li>
</ul>
<p>第一种方式：</p>
<pre><code class="js">var reg = new RegExp(“study”，“ig”);   // 第二个参数为修饰符</code></pre>
<p> i：表示忽略大小写ignore。</p>
<p>g：表示全局匹配，查找所有匹配而非在找到第一个匹配后停止 global。</p>
<p>第二种方式：</p>
<pre><code class="js">var reg = /study/ig;</code></pre>
<ul>
<li>####3：正则对象方法</li>
</ul>
<p>test： 正则实例对象的<code>test</code>方法返回一个布尔值，表示当前模式是否能匹配参数字符串</p>
<pre><code>/cat/.test(&#39;cats and dogs&#39;) // true</code></pre><p>上面代码验证参数字符串之中是否包含<code>cat</code>，结果返回<code>true</code>。</p>
<p>如果正则表达式带有<code>g</code>修饰符，则每一次<code>test</code>方法都从上一次结束的位置开始向后匹配</p>
<pre><code class="js">var r = /x/g;var s = &#39;x_x&#39;;
r.lastIndex // 0
r.test(s) // true
r.lastIndex // 2
r.test(s) // true
r.lastIndex // 4
r.test(s) // false</code></pre>
<p>上面代码的正则表达式使用了<code>g</code>修饰符，表示是全局搜索，会有多个结果。接着，三次使用<code>test</code>方法，每一次开始搜索的位置都是上一次匹配的后一个位置。</p>
<p>带有<code>g</code>修饰符时，可以通过正则对象的<code>lastIndex</code>属性指定开始搜索的位置</p>
<pre><code class="js">var r = /x/g;
var s = &#39;x_x&#39;;
r.lastIndex = 4;
r.test(s) // false</code></pre>
<p>上面代码指定从字符串的第五个位置开始搜索，这个位置是没有字符的，所以返回<code>false</code>。</p>
<p>exec：用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为null。</p>
<pre><code class="js">var s = &#39;x_x&#39;;
var r1 = /x/;
var r2 = /y/;
r1.exec(s) // [&quot;x&quot;]
r2.exec(s) // null</code></pre>
<p>上面代码中，正则对象<code>r1</code>匹配成功，返回一个数组，成员是匹配结果；正则对象<code>r2</code>匹配失败，返回<code>null</code>。</p>
<ul>
<li>####4：字符串函数</li>
</ul>
<p>replace： 按照给定的正则表达式进行替换，返回替换后的字符串。</p>
<p>​        字符串对象的<code>replace</code>方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。</p>
<pre><code class="js">str.replace(search, replacement)</code></pre>
<p>正则表达式如果不加<code>g</code>修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。</p>
<pre><code class="js">&#39;aaa&#39;.replace(&#39;a&#39;, &#39;b&#39;) // &quot;baa&quot;
&#39;aaa&#39;.replace(/a/, &#39;b&#39;) // &quot;baa&quot;
&#39;aaa&#39;.replace(/a/g, &#39;b&#39;) // &quot;bbb&quot;
//上面代码中，最后一个正则表达式使用了g修饰符，导致所有的b都被替换掉了。</code></pre>
<p>match： 字符串实例对象的<code>match</code>方法对字符串进行正则匹配，返回匹配结果。</p>
<pre><code class="js">var s = &#39;_x_x&#39;;
var r1 = /x/;
var r2 = /y/;
s.match(r1) //[&quot;x&quot;]
s.match(r2) // null
//从上面代码可以看到，字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回null。</code></pre>
<p>如果正则表达式带有<code>g</code>修饰符，则该方法与正则对象的<code>exec</code>方法行为不同，会一次性返回所有匹配成功的结果</p>
<pre><code class="js">var s = &#39;abba&#39;;
var r = /a/g;
s.match(r) // [&quot;a&quot;, &quot;a&quot;]
r.exec(s) // [&quot;a&quot;]</code></pre>
<p>search：检索与正则表达式相匹配的值。返回字符串中第一个与正则表达式相匹配的子串的起始位置。如果没有找到则返回-1。</p>
<pre><code class="js">&#39;_x_x&#39;.search(/x/)// 1
//上面代码中，第一个匹配结果出现在字符串的1号位置。</code></pre>
<ul>
<li>####5：正则表达式构成</li>
</ul>
<p>大部分字符在正则表达式中，就是字面的含义，比如<code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的<code>a</code>和<code>b</code>），那么它们就叫做“字面量字符”。</p>
<pre><code class="js">/dog/.test(&#39;old dog&#39;) // true</code></pre>
<p>上面代码中正则表达式的<code>dog</code>，就是字面量字符，所以<code>/dog/</code>匹配<code>old dog</code>，因为它就表示<code>d</code>、<code>o</code>、<code>g</code>三个字母连在一起。</p>
<p>除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”，主要有以下几个</p>
<p>正则表达式是由普通字符（例如字符a到z）以及特殊字符（称为元字符）组成的文字模式。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>
<p>元字符—限定符：</p>
<p>限定符可以指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。</p>
<ul>
<li>​            *：匹配前面的子表达式零次或多次。</li>
<li>​            +：匹配前面的子表达式一次或多次。</li>
<li>​            ？：匹配前面的子表达式零次或一次。</li>
<li>​            {n}：匹配确定n次。</li>
<li>​            {n,}：至少匹配n次。</li>
<li>​            {n, m}：最少匹配n次且最多匹配m次。</li>
</ul>
<pre><code class="js">// t 出现0次或1次
/t?est/.test(&#39;test&#39;) // true
/t?est/.test(&#39;est&#39;) // true
// t 出现1次或多次
/t+est/.test(&#39;test&#39;) // true
/t+est/.test(&#39;ttest&#39;) // true
/t+est/.test(&#39;est&#39;) // false
// t 出现0次或多次/test
/t*est(&#39;test&#39;) // true
/t*est/.test(&#39;ttest&#39;) // true
/t*est/.test(&#39;tttest&#39;) // true
/t*est/.test(&#39;est&#39;) // true

/lo{2}k/.test(&#39;look&#39;) // true
/lo{2,5}k/.test(&#39;looook&#39;) // true
//上面代码中，第一个模式指定o连续出现2次，第二个模式指定o连续出现2次到5次之间</code></pre>
<p>元字符—字符匹配符：</p>
<p>字符匹配符用于匹配某个或某些字符。</p>
<p>[xyz]：字符集合。匹配所包含的任意一个字符。</p>
<pre><code class="js">/[abc]/.test(&#39;hello world&#39;) // false
/[abc]/.test(&#39;apple&#39;) // true
//上面代码中，字符串hello world不包含a、b、c这三个字母中的任一个，所以返回false；字符串apple包含字母a，所以返回true</code></pre>
<p>[^xyz]： 表示除了<code>x</code>、<code>y</code>、<code>z</code>之外都可以匹配。</p>
<pre><code class="js">/abc/.test(&#39;hello world&#39;) // true
/abc/.test(&#39;bbc&#39;) // false
//上面代码中，字符串hello world不包含字母a、b、c中的任一个，所以返回true；字符串bbc不包含a、b、c以外的字母，所以返回false。</code></pre>
<p>[a-z]：字符范围。匹配指定范围内的任意字符。</p>
<p><code>[abc]</code>可以写成<code>[a-c]</code>，<code>[0123456789]</code>可以写成<code>[0-9]</code>，同理<code>[A-Z]</code>表示26个大写字母。</p>
<pre><code class="js">/[a-z]/.test(&#39;b&#39;) // true</code></pre>
<p>这样也可以：[0-9]、[0-9a-z]、[0-9a-zA-Z]</p>
<p>[0-9a-zA-Z]  表示数字0-9，大小字母</p>
<p>[^a-z]：表示不包含小写字母。</p>
<blockquote>
<p>\d 匹配0-9之间的任一数字，相当于[0-9]。</p>
</blockquote>
<blockquote>
<p>\D 匹配所有0-9以外的字符，相当于[^0-9]。</p>
</blockquote>
<blockquote>
<p>\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。</p>
</blockquote>
<blockquote>
<p>\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。 </p>
</blockquote>
<blockquote>
<p>\s 匹配空格（包括换行符、制表符、空格符等）。 </p>
</blockquote>
<blockquote>
<p>\S 匹配非空格的字符。</p>
</blockquote>
<blockquote>
<p>.：匹配除”\n”之外的任何单个字符。</p>
</blockquote>
<p>元字符—定位符：</p>
<p>定位符可以将一个正则表达式固定在一行的开始或结束。也可以创建只在单词内或只在单词的开始或结尾处出现的正则表达式。</p>
<p>^：匹配输入字符串的开始位置。</p>
<p>$：匹配输入字符串的结束位置。</p>
<pre><code class="js">// test必须出现在开始位置
/^test/.test(&#39;test123&#39;) // true

// test必须出现在结束位置
/test$/.test(&#39;new test&#39;) // true

// 从开始位置到结束位置只有test
/^test/.test(&#39;test&#39;) // true
/^test/.test(&#39;test test&#39;) // false</code></pre>
<p>元字符—转义符：</p>
<p>\：用于匹配某些特殊字符。</p>
<p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配<code>+</code>，就要写成<code>\+</code>。</p>
<pre><code class="js">/1+1/.test(&#39;1+1&#39;)// false
/1+1/.test(&#39;1+1&#39;)// true
//上面代码中，第一个正则表达式之所以不匹配，因为加号是元字符，不代表自身。第二个正则表达式使用反斜杠对加号转义，就能匹配成功。</code></pre>
<p>元字符—选择匹配符：</p>
<p><code>|</code>：可以匹配多个规则。竖线符号（<code>|</code>）在正则表达式中表示“或关系”（OR），即<code>cat|dog</code>表示匹配<code>cat</code>或<code>dog</code>。</p>
<pre><code class="js">/11|22/.test(&#39;911&#39;) // true
//上面代码中，正则表达式指定必须匹配11或22
// 匹配fred、barney、betty之中的一个
/fred|barney|betty/</code></pre>
<p>应用：</p>
<ol>
<li>掌握正则的创建方式。</li>
<li>掌握正则表达式的语言。</li>
</ol>
<p>常用正则</p>
<blockquote>
<p>邮政编码检测</p>
</blockquote>
<pre><code class="js">/^\d{6}$/</code></pre>
<blockquote>
<p>文件格式监测</p>
</blockquote>
<pre><code class="js">/^.+.(jpeg|png|gif|jpg)$/</code></pre>
<blockquote>
<p>字符串首尾去空格。</p>
</blockquote>
<pre><code class="js">var str = &#39;      avaasdf &#39;;
var reg = /^\s+|\s+$/g;        
console.log(str.replace(reg,&#39;&#39;))</code></pre>
<blockquote>
<p>邮件格式监测。</p>
</blockquote>
<pre><code class="js">/^\w+[-+.]\w@([a-z0-9A-Z\u2E80-\u9FFF]-?)+(.\w{2,6})+/</code></pre>
<blockquote>
<p>手机号监测</p>
</blockquote>
<pre><code class="js">/^(13[0-9]|14[0-9]|15[0-9]|18[0-9]|17[0-9])\d{8}$/</code></pre>
<blockquote>
<p>身份证监测</p>
</blockquote>
<pre><code class="js">/(^\d{15}|^\d{18})|^\d{17}X$/</code></pre>
<blockquote>
<p>中文监测</p>
<p>unicode编码中文监测</p>
</blockquote>
<pre><code class="js">/^[\u2E80-\u9FFF]+$/</code></pre>
<blockquote>
<p>用户名监测（规则数字字母下划线-组成，3-16位）</p>
</blockquote>
<pre><code class="js">/^[a-z0-9_-]{3,16}$/</code></pre>
<p>####正则分组</p>
<pre><code class="js">//1-什么是分组
var reg = /(\d{2})/
reg.test(&#39;12&#39;);  //true
// 这里reg中的(/d{2})就表示一个分组，匹配两位数字
/*
/hahaha/
/(ha){3}/
这两个表达式是等效的，但有了分组之后可以更急简洁
*/

//2- 捕获型 分组 ()
// 被正则表达式捕获(匹配)到的字符串会被暂存起来，其中，由分组捕获到的字符串会从1开始编号，于是我们可以引用这些字符串：
var reg = /(\d{4})-(\d{2})-(\d{2})/;
var dateStr = &#39;2018-04-18&#39;;
reg.test(dateStr);  //true
//引用捕获到的内容使用 $1 代表第一个分组的捕获到的内容
RegExp.$1   //2018
RegExp.$2   //04
RegExp.$3   //18

// 3-非捕获型 (?:)
// 有的时候只是为了分组并不需要捕获的情况下就可以使用非捕获型分组
var reg = /(?:\d{4})-(\d{2})-(\d{2})/
var date = &#39;2012-12-21&#39;
reg.test(date)
RegExp.$1 // 12
RegExp.$2 // 21

// 4- 结合replace方法做字符串自定义替换
var dateStr = &#39;2018/04/18&#39;;
var reg = /(\d{4})\/(\d{2})\/(\d{2})/;
dateStr = dateStr.replace(reg, &#39;$1-$2-$3&#39;) //&quot;2018-04-18&quot;
//不过这里需要注意的是/是需要用\转义的


// 5- 结合正则exec方法来使用
//通俗来说，分组就是在正则表达式中用（）包起来的内容代表了一个分组
        var s;
        var re = new RegExp(&quot;d(b+)(d)&quot;, &quot;ig&quot;);
        var str = &quot;cdbBdbsbdbdz&quot;;
        var arr = re.exec(str);
        console.log(arr)
/*
0: &quot;dbBd&quot;  正则整体匹配到的字符
1: &quot;bB&quot;    第一个小括号(分组)匹配到的字符
2: &quot;d&quot;     第二个小括号（分组）匹配到的字符
*/
    //  第一个分组的结果也可以用 RegExp.$1   获取
        s = &quot;$1 contains: &quot; + RegExp.$1 + &quot;\n&quot;;
        s += &quot;$2 contains: &quot; + RegExp.$2 + &quot;\n&quot;;
        console.log(s)

// 6- 结合字符串match方法使用
        var str = &quot;http://www.taobao.com:80/cuxiao/hongbao.html&quot;;
        var patt1 = /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/;
        arr = str.match(patt1);
        console.log(arr);
/*
0: &quot;http://www.taobao.com:80/cuxiao/hongbao.html&quot;  整个正则匹配到的字符串
1: &quot;http&quot;     第一个分组 匹配到的字符串
2: &quot;www.taobao.com&quot;   第二个分组 匹配到的字符串
3: &quot;:80&quot;      第三个分组 匹配到的字符串
4: &quot;/cuxiao/hongbao.html&quot;   第四个分组 匹配到的字符串
*/
        //第一个分组的结果也可以用 RegExp.$1   获取
        console.log(RegExp.$1)//http


// 7- 阿里 常见面试题
//把url参数转对象
        var parseQuery = function (query) {
            var reg = /([^=&amp;\s]+)[=\s]*([^&amp;\s]*)/g;
            var obj = {};
            while (reg.exec(query)) {
                obj[RegExp.$1] = RegExp.$2;
            }
            console.log(obj)
            return obj;
        }
parseQuery(&quot;userID=JeoOrCXxyiOFxbYaGL40kw&amp;userPwd=sdFo2ziUw8HyLRKd4i6GAQ&amp;userName=aa&quot;)</code></pre>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ul>
<li>重点知识<ul>
<li>this关键字以及bind</li>
<li>let/const</li>
<li>变量解构</li>
<li>箭头函数</li>
<li>模板字符串</li>
<li>class和继承</li>
</ul>
</li>
</ul>
<hr>
<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言</p>
<hr>
<p>######1：this关键字</p>
<p><code>this</code>可以用在构造函数之中，表示实例对象。除此之外，<code>this</code>还可以用在别的场合。但不管是什么场合，<code>this</code>都有一个共同点：它总是返回一个对象简单说，<code>this</code>就是属性或方法“当前”所在的对象。</p>
<pre><code class="js">var person = {
    name: &#39;张三&#39;,
    describe: function (){
        return &#39;姓名：&#39;+ this.name;
    }
};
person.describe()// &quot;姓名：张三&quot;</code></pre>
<p>上面代码中，<code>this.name</code>表示<code>name</code>属性所在的那个对象。由于<code>this.name</code>是在<code>describe</code>方法中调用，而<code>describe</code>方法所在的当前对象是<code>person</code>，因此<code>this</code>指向<code>person</code>，<code>this.name</code>就是<code>person.name</code>。</p>
<p><code>this</code>主要有以下几个使用场合</p>
<p><strong>（1）全局环境</strong></p>
<pre><code class="js">//全局环境使用this，它指的就是顶层对象window。
this === window // true
function f() {
    console.log(this === window);
}
f() // true
//注：严格模式下 普通函数内部 this 等于 undefined</code></pre>
<p><strong>（2）构造函数</strong></p>
<p>构造函数中的<code>this</code>，指的是实例对象</p>
<pre><code class="js">function Person(p) {
    this.p = p;
};
var obj = new Person()</code></pre>
<p><strong>（3）对象的方法</strong></p>
<p>如果对象的方法里面包含<code>this</code>，<code>this</code>的指向就是方法运行时所在的对象。</p>
<pre><code class="js">var obj ={
    foo: function () {
        console.log(this);
    }
};
obj.foo() // obj </code></pre>
<hr>
<p>######2：bind方法</p>
<p><code>bind</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数。</p>
<pre><code class="js">var dog ={
    name:&#39;wangcai&#39;,
    age:18,
    wang:function(){
        console.log(this)
    }
}
var person = {name:&#39;小明&#39;}
var func = dog.wang.bind(person)
func();//上面代码将person绑定到了func函数内部</code></pre>
<hr>
<p>######3：<strong>let/const</strong></p>
<p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p>
<pre><code class="js">{  
    let a = 10;  var b = 1;
}
a // ReferenceError: a is not defined.
b // 1</code></pre>
<p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p>
<p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p>
<pre><code class="js">var oLis = document.getElementsByTagName(&#39;li&#39;)
for (let i = 0; i &lt; oLis.length; i++) {
    // ...
    oLis[i].onclick = function(){
        console.log(i)// 0 1 2 3 4
    }
}
console.log(i);
// ReferenceError: i is not defined
//上面代码相当与产生了几个块级作用域
{
    var i=0;
    oLis[i].onclick = function(){
        console.log(i)
    }
}
{
    var i=1;
    oLis[i].onclick = function(){
        console.log(i)
    }
}</code></pre>
<p>上面代码中，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外引用就会报错。</p>
<p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景，let实际上为 JavaScript 新增了块级作用域<strong>。</strong></p>
<p><code>var</code>命令会发生”变量提升“现象，即变量可以在声明之前使用，值为<code>undefined</code>。</p>
<p>这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>
<p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<p>######4：const命令</p>
<p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值</p>
<pre><code class="js">const PI = 3.1415;
PI // 3.1415
PI = 3;
// TypeError: Assignment to constant variable.</code></pre>
<p>上面代码表明改变常量的值会报错。</p>
<hr>
<p>######5：箭头函数 =&gt;</p>
<p>ES6 允许使用“箭头”（=&gt;）定义函数。</p>
<pre><code class="js">var f = v =&gt; v;// 等同于
var f = function (v) {
    return v;
};</code></pre>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<pre><code class="js">var f = () =&gt; 5;
// 等同于
var f = function () { 
    return 5 
};

var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2) {
    return num1 + num2;
};</code></pre>
<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。</p>
<pre><code class="js">var sum = (num1, num2) =&gt; { return num1 + num2; }</code></pre>
<p>箭头函数使得表达更加简洁。</p>
<pre><code class="js">const isEven = n =&gt; n % 2 == 0;const square = n =&gt; n * n;</code></pre>
<p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>
<p>箭头函数的一个用处是简化回调函数。</p>
<pre><code class="js">// 正常函数写法
[1,2,3].map(function (x) {  
    return x * x;
});
// 箭头函数写法
[1,2,3].map(x =&gt; x * x);
// 正常函数写法
var result = values.sort(function (a, b) {
    return a - b;
});
// 箭头函数写法
var result = values.sort((a, b) =&gt; a - b);</code></pre>
<p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。</p>
<hr>
<p>######6：变量解构（解构赋值）</p>
<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构</p>
<p>以前，为变量赋值，只能直接指定值。</p>
<pre><code class="js">let a = 1;
let b = 2;
let c = 3;</code></pre>
<p>ES6 允许写成下面这样。</p>
<pre><code class="js">let [a, b, c] = [1, 2, 3];</code></pre>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值<br>解构不仅可以用于数组，还可以用于对象</p>
<pre><code class="js">let { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;</code></pre>
<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值</p>
<pre><code class="js">let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;
let { foo} = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;</code></pre>
<p>######7：字符串扩展</p>
<blockquote>
<p>模板字符串（template string）是增强版的字符串</p>
</blockquote>
<p>传统的 JavaScript 语言，输出模板通常是这样写的。</p>
<pre><code class="js">var a = 1
var b = 2;
var sum = a + b;
var res = a + &#39;+&#39; + b + &#39;的和是&#39; + c+&#39;&#39;;
console.log(res)
box.innerHTML = res;
var obj=  {name:&#39;zhangsan&#39;,age:18};
var str = &#39;姓名：&#39;+obj.name+&#39;年龄:&#39;+obj.age;
div.innerHTML = str;</code></pre>
<p>上面这种写法(拼字符串)相当繁琐不方便，ES6 引入了模板字符串解决这个问题。模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，可以在字符串中嵌入变量， 模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。</p>
<pre><code class="js">var a = 1
var b = 2;
var sum = a + b;
var res =`a+b的和是&lt;b&gt;{c}&lt;/b&gt;`;
console.log(res)
box.innerHTML = res;
var obj=  {name:&#39;zhangsan&#39;,age:18};
var str =`&lt;b&gt;姓名&lt;/b&gt;：{obj.name}年龄:{obj.age}`
div.innerHTML = str;</code></pre>
<p>上面代码中的模字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义</p>
<pre><code class="js">let greeting = `\`Yo\` World!`;</code></pre>
<p> 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中</p>
<pre><code class="js">oDiv.innerHTML = `
    &lt;ul&gt;  
    &lt;li&gt;first&lt;/li&gt;  
    &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;`</code></pre>
<p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p>
<pre><code class="js">et x = 1;let y = 2;
`${x} + ${y} = ${x + y}`
// &quot;1 + 2 = 3&quot;
`${x} + ${y * 2} = ${x + y * 2}`
// &quot;1 + 4 = 5&quot;
let obj = {x: 1, y: 2};
`${obj.x + obj.y}`</code></pre>
<p>模板字符串之中还能调用函数</p>
<pre><code class="js">function fn() {  
    return &quot;Hello World&quot;;
}
`foo ${fn()} bar`
// foo Hello World bar</code></pre>
<p>字符串扩张方法</p>
<hr>
<p>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p>
<p>​    <code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</p>
<p>​    <code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</p>
<p>​    <code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</p>
<pre><code class="js">let s = &#39;Hello world!&#39;;
s.startsWith(&#39;Hello&#39;) // true
s.endsWith(&#39;!&#39;) // true
s.includes(&#39;o&#39;) // true</code></pre>
<p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复n次</p>
<pre><code class="js">&#39;x&#39;.repeat(3) // &quot;xxx&quot;
&#39;hello&#39;.repeat(2) // &quot;hellohello&quot;
&#39;na&#39;.repeat(0) // &quot;&quot;</code></pre>
<hr>
<p>######7.1：数组新增方法</p>
<p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（ES6 新增的数据结构 <code>Set</code> 和 <code>Map</code>）</p>
<p>下面是一个类似数组的对象，Array.from将它转为真正的数组</p>
<pre><code class="js">let arrayLike = {    
    &#39;0&#39;: &#39;a&#39;,    
    &#39;1&#39;: &#39;b&#39;,    
    &#39;2&#39;: &#39;c&#39;,    
    length: 3
};
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre>
<p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。</p>
<p>Array.from都可以将它们转为真正的数组<br>对象扩展<br>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<pre><code class="js">const foo = &#39;bar&#39;;
const baz = {foo};
baz // {foo: &quot;bar&quot;}
// 等同于
const baz = {foo: foo};</code></pre>
<p>除了属性简写，方法也可以简写。</p>
<pre><code class="js">const o = {  
    method() {    
        return &quot;Hello!&quot;;  
    }
};
// 等同于
const o = {  
    method: function() {    
        return &quot;Hello!&quot;;  
    }
};</code></pre>
<hr>
<p>######8：扩展运算符</p>
<p>扩展运算符三个点（…）<br>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<pre><code class="js">let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }</code></pre>
<p>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</p>
<pre><code class="js">let foo = { ...[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] };
foo// {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;}</code></pre>
<p>对象的扩展运算符等同于使用Object.assign()方法。</p>
<pre><code class="js">let aClone = { ...a };
// 等同于
let aClone = Object.assign({}, a);</code></pre>
<pre><code class="js">function add(x, y) { 
    return x + y; 
} 
var numbers = [4, 38]; 
add(...numbers) //
//该运算符将一个数组，变为参数序列
 var arr1 = [&#39;a&#39;, &#39;b&#39;];
 var arr2 = [&#39;c&#39;];
 var arr3 = [&#39;d&#39;, &#39;e&#39;];// 合并数组
 [...arr1, ...arr2, ...arr3]</code></pre>
<hr>
<p>######9：函数参数默认值</p>
<p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>
<pre><code class="js">function log(x, y) {  
    y = y || &#39;World&#39;;  
    console.log(x, y);
}
log(&#39;Hello&#39;) // Hello World
log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
 //这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。</code></pre>
<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<pre><code class="js">function log(x, y = &#39;World&#39;) {  
    console.log(x, y);
}
log(&#39;Hello&#39;) // Hello World
log(&#39;Hello&#39;, &#39;China&#39;) // Hello China</code></pre>
<p>可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。</p>
<hr>
<p>######10：Symbol类型     </p>
<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。  </p>
<p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。</p>
<p>它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（<code>Boolean</code>）、字符串（<code>String</code>）、数值（<code>Number</code>）、对象（<code>Object</code>）</p>
<p>Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。</p>
<p>凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突</p>
<pre><code class="js">let s = Symbol();
typeof s// &quot;symbol&quot;</code></pre>
<p>上面代码中，变量<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是 Symbol 数据类型，而不是字符串之类的其他类型注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。</p>
<p>这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<pre><code class="js">let s1 = Symbol(&#39;foo&#39;);
let s2 = Symbol(&#39;bar&#39;);
s1 // Symbol(foo)
s2 // Symbol(bar)
s1.toString() // &quot;Symbol(foo)&quot;
s2.toString() // &quot;Symbol(bar)&quot;</code></pre>
<p>上面代码中，<code>s1</code>和<code>s2</code>是两个 Symbol 值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。<br>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p>
<pre><code class="js">// 没有参数的情况
let s1 = Symbol();
let s2 = Symbol();
s1 === s2 // false
// 有参数的情况
let s1 = Symbol(&#39;foo&#39;);
let s2 = Symbol(&#39;foo&#39;);
s1 === s2 // false</code></pre>
<p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的。Symbol 值也可以转为布尔值，但是不能转为数值</p>
<pre><code class="js">let sym = Symbol();
Boolean(sym) // true!
sym // false
if (sym) {
    // ...
}
Number(sym) // TypeError
sym + 2 // TypeError</code></pre>
<p>作为属性名的 Symbol由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性，能防止某一个键被不小心改写或覆盖。</p>
<pre><code class="js">// 第一种写法
let a = {};
a[mySymbol] = &#39;Hello!&#39;;
// 第二种写法
let a = {  
    [mySymbol]: &#39;Hello!&#39;
};
// 以上写法都得到同样结果
a[mySymbol] // &quot;Hello!&quot;注意，Symbol 值作为对象属性名时，不能用点运算符。
const mySymbol = Symbol();
const a = {};
a.mySymbol = &#39;Hello!&#39;;
a[mySymbol] // undefined
a[&#39;mySymbol&#39;] // &quot;Hello!&quot;</code></pre>
<p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<pre><code class="js">let s = Symbol();
let obj = {  
    [s]: function (arg) {
        ... 
    }
};
obj[s];</code></pre>
<p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个 Symbol 值。</p>
<hr>
<p>######11：Set和Map结构</p>
<p>ES6 提供了新的数据结构 <code>Set</code>。</p>
<blockquote>
<p>它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p>
</blockquote>
<pre><code class="js">const s = new Set();
[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));
for (let i of s) {  
    console.log(i);
}// 2 3 5 4</code></pre>
<p>上面代码通过<code>add</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。<br>Set 函数可以接受一个数组（获取dom的nodelist对象）作为参数，用来初始化。</p>
<pre><code class="js">// 例一
const set = new Set([1, 2, 3, 4, 4]);
[...set]// [1, 2, 3, 4]
// 例二
const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
items.size // 8
// 例三
const set = new Set(document.querySelectorAll(&#39;div&#39;));
set.size // 56</code></pre>
<p>上面代码也展示了一种去除数组重复成员的方法。</p>
<pre><code class="js">// 去除数组的重复成员
[...new Set(array)]</code></pre>
<p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。</p>
<p>Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p>
<pre><code class="js">let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set // Set {NaN}</code></pre>
<p>Set 结构的实例有以下属性</p>
<p>​    <code>constructor</code>：构造函数，默认就是<code>Set</code>函数。</p>
<p>​    <code>size</code>：返回<code>Set</code>实例的成员总数。</p>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。</p>
<ul>
<li>下面四个操作方法<ul>
<li>- add(value)：添加某个值，返回 Set 结构本身。</li>
<li>-delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>-has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>-clear()：清除所有成员，没有返回值。</li>
</ul>
</li>
</ul>
<pre><code class="js">s.add(1).add(2).add(2);// 注意2被加入了两次
s.size // 2
s.has(1) // true
s.has(2) // true
s.has(3) // false
s.delete(2);
s.has(2) // false</code></pre>
<p><code>Array.from</code>方法可以将 Set 结构转为数组。</p>
<pre><code class="js">const items = new Set([1, 2, 3, 4, 5]);
const array = Array.from(items);
Set 结构的实例默认可遍历
let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);
for (let x of set) {  console.log(x);}// red// green// blue</code></pre>
<p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p>
<pre><code class="js">set = new Set([1, 4, 9]);
set.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))// 1 : 1// 4 : 4// 9 : 9</code></pre>
<p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。</p>
<p>这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p>
<p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p>
<pre><code class="js">let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)];// [3, 5, 2]</code></pre>
<p><strong>map结构</strong></p>
<p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<p>ES6 提供了 <code>Map</code> 数据结构。</p>
<p>它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<p>Map 结构的实例有以下属性和操作方法。</p>
<p><strong>（1）size 属性</strong><br><code>size</code>属性返回 Map 结构的成员总数。</p>
<pre><code class="js">const map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);
map.size // 2</code></pre>
<p><strong>（2）set(key, value)</strong><br><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p>
<pre><code class="js">const m = new Map();
m.set(&#39;edition&#39;, 6)
// 键是字符串
m.set(262, &#39;standard&#39;)
// 键是数值
m.set(undefined, &#39;nah&#39;)
// 键是 undefined</code></pre>
<p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p>
<pre><code class="js">let map = new Map()
.set(1, &#39;a&#39;)
.set(2, &#39;b&#39;)
.set(3, &#39;c&#39;);</code></pre>
<p><strong>（3）get(key)</strong><br><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>
<pre><code class="js">const m = new Map();
const hello = function() {
    console.log(&#39;hello&#39;);
};
m.set(hello, &#39;Hello ES6!&#39;) // 键是函数
m.get(hello) // Hello ES6!</code></pre>
<p><strong>（4）has(key)</strong><br><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p>
<pre><code class="js">const m = new Map();
m.set(&#39;edition&#39;, 6);
m.set(262, &#39;standard&#39;);
m.set(undefined, &#39;nah&#39;);
m.has(&#39;edition&#39;)    // true
m.has(&#39;years&#39;)      // false
m.has(262)          // true
m.has(undefined)    // true</code></pre>
<p><strong>（5）delete(key)</strong><br><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p>
<pre><code class="js">const m = new Map();
m.set(undefined, &#39;nah&#39;);
m.has(undefined)    // true
m.delete(undefined)
m.has(undefined)      // false</code></pre>
<p><strong>（6）clear()</strong><br><code>clear</code>方法清除所有成员，没有返回值。</p>
<pre><code class="js">let map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);
map.size // 2
map.clear()
map.size // 0</code></pre>
<p>遍历map<br>需要特别注意的是，Map 的遍历顺序就是插入顺序</p>
<pre><code class="js">const map = new Map([  [&#39;F&#39;, &#39;no&#39;],  [&#39;T&#39;,  &#39;yes&#39;],]);
for (let [key, value] of map) {
    console.log(key, value);
}
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;</code></pre>
<p>######12：Generators生成器函数</p>
<p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p>
<p> Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>
<p> 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<ul>
<li>形式上，Generator 函数是一个普通函数，但是有两个特征。<ul>
<li>一是，<code>function</code>关键字与函数名之间有一个星号；</li>
<li>二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）</li>
</ul>
</li>
</ul>
<pre><code class="js">function* helloWorldGenerator() {
    yield &#39;hello&#39;;
    yield &#39;world&#39;;
    return &#39;ending&#39;;
}
var hw = helloWorldGenerator();</code></pre>
<p>上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p>
<p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。</p>
<p>不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象<br><strong>yield 表达式</strong><br>由于 Generator 函数返回的遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。</p>
<p><code>yield</code>表达式就是暂停标志。</p>
<p>（1）遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</p>
<p>（2）下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</p>
<p>（3）如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</p>
<p>（4）如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code></p>
<p>下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p>
<pre><code class="js">hw.next()// { value: &#39;hello&#39;, done: false }
hw.next()// { value: &#39;world&#39;, done: false }
hw.next()// { value: &#39;ending&#39;, done: true }
hw.next()// { value: undefined, done: true }</code></pre>
<p>上面代码一共调用了四次<code>next</code>方法。</p>
<blockquote>
<p>第一次调用，Generator 函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p>
</blockquote>
<blockquote>
<p>第二次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到下一个<code>yield</code>表达式。<code>next</code>方法返回的对象的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>world</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p>
</blockquote>
<blockquote>
<p>第三次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到<code>return</code>语句（如果没有<code>return</code>语句，就执行到函数结束）。<code>next</code>方法返回的对象的<code>value</code>属性，就是紧跟在<code>return</code>语句后面的表达式的值（如果没有<code>return</code>语句，则<code>value</code>属性的值为<code>undefined</code>），<code>done</code>属性的值<code>true</code>，表示遍历已经结束。</p>
</blockquote>
<blockquote>
<p>第四次调用，此时 Generator 函数已经运行完毕，<code>next</code>方法返回对象的<code>value</code>属性为<code>undefined</code>，<code>done</code>属性为<code>true</code>。以后再调用<code>next</code>方法，返回的都是这个值。</p>
</blockquote>
<p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。</p>
<p>以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。</p>
<p><code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p>
<hr>
<p>######13：class的写法及继承</p>
<p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子</p>
<pre><code class="js">function Point(x, y) {
    this.x = x;
    this.y = y;
}
Point.prototype.toString = function () {
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
};
var p = new Point(1, 2);</code></pre>
<p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p>
<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。<br>通过<code>class</code>关键字，可以定义类。<br>基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<p>上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</p>
<pre><code class="js">//定义类
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
      toString() {
          return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;  
      }
}</code></pre>
<p>上面代码定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。也就是说，ES5 的构造函数<code>Point</code>，对应 ES6 的<code>Point</code>类的构造方法<br><code>point</code>类除了构造方法，还定义了一个<code>toString</code>方法。</p>
<p>注意，定义“类”的方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>
<pre><code class="js">//hasOwnProperty 可以用来判断对象是否有每一个属性
point.hasOwnProperty(&#39;x&#39;) // true
point.hasOwnProperty(&#39;y&#39;) // true</code></pre>
<p>ES6 的类，完全可以看作构造函数的另一种写法</p>
<pre><code class="js">class Point {
    // ...
}
typeof Point // &quot;function&quot;</code></pre>
<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数</p>
<p>类的属性名，可以采用表达式。</p>
<pre><code class="js">let methodName = &#39;getArea&#39;;
class Square {
    constructor(length){
        // ...
    }
      methodName {
        // ...
    }
}</code></pre>
<p>上面代码中，<code>Square</code>类的方法名<code>getArea</code>，是从表达式得到的。</p>
<p>类内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。<br>考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p>
<p><strong>constructor 方法</strong><br><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p>
<pre><code class="js">class Point {}
// 等同于
class Point {
    constructor() {

    }
}</code></pre>
<p>上面代码中，定义了一个空的类<code>Point</code>，JavaScript 引擎会自动为它添加一个空的<code>constructor</code>方法。<br><code>constructor</code>方法默认返回实例对象（即<code>this</code>）</p>
<p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p>
<pre><code class="js">class Foo {
    constructor() {

    }
}
Foo()// TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;</code></pre>
<p>生成类的实例对象的写法，与 ES5 完全一样，也是使用<code>new</code>命令。前面说过，如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错。</p>
<pre><code class="js">class Point {
    // ...
}
// 报错
var point = Point(2, 3);
// 正确
var point = new Point(2, 3);</code></pre>
<p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p>
<pre><code class="js">new Foo(); // ReferenceError
class Foo {}</code></pre>
<p>类方法<br>加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<pre><code class="js">class Foo {  
    static classMethod() {    
        return &#39;hello&#39;;  
    }
}
Foo.classMethod() // &#39;hello&#39;
var foo = new Foo();
foo.classMethod()// TypeError: foo.classMethod is not a function</code></pre>
<p>上面代码中，Foo类的classMethod方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（<code>Foo.classMethod()</code>），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>
<p>类的继承Class 可以通过<code>extends</code>关键字实现继承 这比 ES5 的通过修改原型链（在后面章节会讲解）实现继承，要清晰和方便很多。</p>
<pre><code class="js">class Point {}
class ColorPoint extends Point {}</code></pre>
<p>上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。下面，我们在<code>ColorPoint</code>内部加上代码。</p>
<pre><code class="js">class ColorPoint extends Point {
    constructor(x, y, color) {
        super(x, y); // 调用父类的constructor(x, y)
        this.color = color;
    }
    toString() {
        return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()
    }
}</code></pre>
<p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。<br>ES6 要求，子类的构造函数必须执行一次<code>super</code>函数</p>
<p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p>
<pre><code class="js">class Point { /* ... */ }
class ColorPoint extends Point {
    constructor() {  }
}
let cp = new ColorPoint(); // ReferenceError</code></pre>
<p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super</code>方法，导致新建实例时报错。</p>
<p>需要注意的地方是，在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有<code>super</code>方法才能返回父类实例</p>
<pre><code class="js">class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}
class ColorPoint extends Point {
    constructor(x, y, color) {
        this.color = color; // ReferenceError
        super(x, y);
        this.color = color; // 正确
    }
}</code></pre>
<p>上面代码中，子类的<code>constructor</code>方法没有调用<code>super</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super</code>方法之后就是正确的。</p>
<h2 id="js动画"><a href="#js动画" class="headerlink" title="js动画"></a>js动画</h2><p>####运动也可以叫做动画</p>
<p>######1：运动原理</p>
<p>通过连续不断的改变物体的位置，而发生移动变化。</p>
<p>使用<code>setInterval</code>实现。</p>
<p>匀速运动：速度值一直保持不变。</p>
<p>多物体同时运动：将定时器绑设置为对象的一个属性。</p>
<p>注：物体每次运动都应该把之前的定时器清除掉。</p>
<pre><code class="js">//box为绝对定位
var speedX = 2
box.timer = setInterval(function(){
    box.style.left = box.offsetLeft + speedX +&#39;px&#39;;
},80)</code></pre>
<p>######2：边界处理</p>
<p>遇到边界是应该停止掉还是反弹，方向相反。</p>
<p>改变物体运动方向：将物体的速度值取反。</p>
<pre><code class="js">//边界属性  浏览器视口宽高
//返回当前视口的高度（即浏览器窗口的高度）
console.log(document.documentElement.clientHeight)
console.log(document.documentElement.clientWidth)
// 网页总高度     body默认有margin，记得重置console.log(document.body.clientHeight)
console.log(document.body.clientWidth)</code></pre>
<pre><code class="js">var speedX = 2 
box.timer = setInterval(function(){
    box.style.left = box.offsetLeft + speedX +&#39;px&#39;;
    //左右边界
    if(box.offsetLeft &lt;=0 || box.offsetLeft &gt;= cWidth - box.offsetWidth){
        speedX = -speedX;
    }
},80)</code></pre>
<p>######3：加速减速</p>
<p>加速：速度越来越快。</p>
<p>减速：速度越来越慢。</p>
<pre><code class="js">box.timer = setInterval(function() {
    speedX = speedX + 2;
    div.style.left = div.offsetLeft + speedX + &#39;px&#39;;
}, 50);</code></pre>
<p>######4：抛物线</p>
<p>水平方向有一速度，垂直方向有一速度，并做自由落体。</p>
<pre><code class="js">var speedY = 0;
var speedX = 10;
// x 方向  匀速
// y 方向  匀加速
box.timer = setInterval(function() {
    speedY += 9.8
    box.style.left = box.offsetLeft + speedX + &#39;px&#39;;
    box.style.top = box.offsetTop + speedY + &#39;px&#39;;
}, 80)</code></pre>
<p>######5：透明度的变换</p>
<p>box逐渐消失</p>
<pre><code class="js">//使用css将box的opacity 设置为1
var op = 1;box.timer = setInterval(function() {
    op = op - 0.01;
    div.style.opacity = op
    //或者
    //div.style.opacity = getComputedStyle(div).opacity - 0.01;
}, 80);</code></pre>
<p>######6：缓冲运动</p>
<p>速度一开始很大，然后慢慢变小，比较类似自然界中的缓冲运动</p>
<pre><code class="js">//一开始box 在 （0，0）位置，我们将box运动到（300,0）位置
var target = 300; //目标位置
box.timer = setInterval(function() {
    //target - div.offsetLeft 是元素距离目标的路程，随着越来越靠近目标，这个值就越来越小，如果把这个值当做速度，速度一开始很大，然后慢慢变小，比较类似自然界中的缓冲运动。如果把这个值直接当速度，一下子就到，所以除以8以后当做速度
    var speed = (target - div.offsetLeft) / 8;
    //所以要对速度向上取整得到速度1，当speed小于0.375的时候，div就不会移动了
    speed = Math.ceil(speed);
    box.style.left = div.offsetLeft + speed + &#39;px&#39;;
    if(box.offsetLeft == target) {
        //到达目标清除定时器
        clearInterval(box.timer);
    }
}, 30);
</code></pre>
<p>考虑到运动的时候可能往前，也可以能往后，增加判断</p>
<pre><code class="js">//一开始box 在 （0，0）位置，我们将box运动到（300,0）位置
var target = 300; //目标位置
div.timer = setInterval(function() {
    var speed = (target - div.offsetLeft) / 8;
    //当speed小于0.375的时候，div就不会移动了
    //所以要对速度向上取整或者向下取整
    if(speed &gt; 0) {
        //speed大于0 说明是往前运动
        //当speed小于0.375的时候，div就不会移动了
        //所以要对速度向上取整或者向下取整
        speed = Math.ceil(speed);
    } else {
        //speed大于0 说明是往后运动
        speed = Math.floor(speed);
    }
    div.style.left = div.offsetLeft + speed + &#39;px&#39;;
    if(div.offsetLeft == target) {
        clearInterval(div.timer);
    }
}, 30);</code></pre>
<p>上面代码封装为函数</p>
<pre><code class="js">function animate(div,targetX) {
    var target = targetX;
    div.timer =  setInterval(function () {
        var speed = (target - div.offsetTop)/8;
        speed = (speed&gt;0? Math.ceil(speed): Math.floor(speed));
        div.style.top = div.offsetTop + speed +&#39;px&#39;;
        if(div.offsetTop == target){
            clearInterval(div.timer);
        }
    },30);
}</code></pre>
<p>######7：多属性缓冲运动函数封装</p>
<p>上面的封装只能固定的在x方向做动画</p>
<p>如果想让一个div 从一个点运动到另一个点，怎么办？</p>
<p>比如从（0，0）到（100，200）这个时候我们把第二个参数改为一个这样的对象<code>{left:100;top:200}</code></p>
<pre><code class="js">function animate(div, obj) {
    //{left:100;top:200}
    //{left:100}
    clearInterval(div.timer);
    div.timer = setInterval(function() {
        var flag = true; //假设已经到了目的地
        for(var key in obj) {
            console.log(key) //left   top
            console.log(obj[key]) //300
            var target = obj[key]; //目标值
            // getComputedStyle[&#39;left&#39;]  元素left 属性 当前值
            var speed = (target - parseInt(getComputedStyle(div)[key])) / 8;                          speed = (speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed));                              div.style[key] = parseInt(getComputedStyle(div)[key]) + speed + &#39;px&#39;;
            if(parseInt(getComputedStyle(div)[key]) != target) {
                flag = false;
            }
        }
        //必须等到所有的 属性都到达目的地 才能结束定时器
        if(flag == true) {
            clearInterval(div.timer);
        }
    }, 30);
}</code></pre>
<p>上面咱们就封装了一个运动函数，也可以叫运动框架，说白了，就是封装一次以后，我们再做一些动画就非常方便！前人栽树后人乘凉，便是框架的好处！</p>
<p>如果想让框架支持透明度动画怎么办呢？无非是增加更多的判断运动框架最终封装见<code>animateBak.js</code></p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>


<p>
    <a href="javascript:void(0)" target="_blank" rel="noopener" class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>js汇总</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">25.9k</span></p>
    <p><span class="copy-title">本文作者:</span><a href="javascript:void(0)" target="_blank" rel="noopener" title="小学徒">小学徒</a></p>
    <p><span class="copy-title">发布时间:</span>2019-11-07, 07:51:21</p>
    <p><span class="copy-title">最后更新:</span>2019-11-07, 08:12:42</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2019/11/07/js/" title="js汇总">http://yoursite.com/2019/11/07/js/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2019 Yelog</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket"></a>
    </div>
</div>
<div class="acParent"></div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close" href="javascript:void(0)" target="_blank" rel="noopener" onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': [],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
