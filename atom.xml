<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学术渊</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://1512034032.github.io/"/>
  <updated>2019-11-13T12:29:29.521Z</updated>
  <id>http://1512034032.github.io/</id>
  
  <author>
    <name>小学徒</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React 基础</title>
    <link href="http://1512034032.github.io/2019/11/13/react/"/>
    <id>http://1512034032.github.io/2019/11/13/react/</id>
    <published>2019-11-13T12:18:42.000Z</published>
    <updated>2019-11-13T12:29:29.521Z</updated>
    
    <content type="html"><![CDATA[<h4 id="纯组件"><a href="#纯组件" class="headerlink" title="纯组件"></a>纯组件</h4><pre><code>import React ,{useState,useEffect} from &#39;react&#39;;const Chun = (props)=&gt;{    return (        &lt;div&gt;纯组件&lt;/div&gt;    )}export default Chun;</code></pre><h4 id="组件接收属性值的传递"><a href="#组件接收属性值的传递" class="headerlink" title="组件接收属性值的传递"></a>组件接收属性值的传递</h4><pre><code class="jsx">import React,{Component} from &#39;react&#39;class Home extends Component{    render(){        return(            &lt;div&gt;{接收到的值：this.props.name}&lt;/div&gt;        )    }}ReactDOM.render(&lt;Home name=&quot;title&quot;/&gt;,document.getElementById(&#39;app)) //利用自定义属性传值,可以是字符串、对象、函数...</code></pre><h4 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h4><pre><code>import React,{Component} from &#39;react&#39;export default class Control extends Component{    constructor(props){        super(props)        this.state = {            val:111        }    }    tap(e){        console.log(e.target.value)        this.setState({            val:e.target.value        })    }    render(){        return (            &lt;div&gt;                &lt;input type=&quot;text&quot; ref=&quot;ipt&quot; value={this.state.val} onChange={(e)=&gt;this.tap(e)}/&gt;            &lt;/div&gt;        )    }}</code></pre><h4 id="父子组件之间的传值"><a href="#父子组件之间的传值" class="headerlink" title="父子组件之间的传值"></a>父子组件之间的传值</h4><ol><li>数据从父组件流向子组件</li><li>子组件数据流向父组件</li></ol><ul><li>操作dom<ul><li>ref获取dom元素  ref给dom添加该属性</li><li>通过this.refs.ref的值获取dom</li></ul></li></ul><h4 id="父向子传值"><a href="#父向子传值" class="headerlink" title="父向子传值"></a>父向子传值</h4><p>子组件</p><pre><code>import React,{Component} from &#39;react&#39;export default class Child extends Component{    constructor(props){        super(props)    }    render(){        return (            &lt;div&gt;                &lt;h2&gt;子组件&lt;/h2&gt;                &lt;p&gt;父组件数据：{this.props.name}&lt;/p&gt;            &lt;/div&gt;        )    }}</code></pre><p>父组件</p><pre><code>import React,{Component} from &#39;react&#39;import Child from &#39;./Child&#39;export default class Parent extends Component{    constructor(props){        super(props)        this.state = {            str:&quot;&quot;        }    }    tap(){        console.log(this.refs.ipt.value)        this.setState({str:this.refs.ipt.value})        this.refs.ipt.value=&#39;&#39;    }    render(){        return(            &lt;div&gt;                &lt;h2&gt;父组件&lt;/h2&gt;                &lt;button onClick={()=&gt;this.tap()}&gt;发送给子组件&lt;/button&gt;                &lt;input type=&quot;text&quot; ref=&quot;ipt&quot;/&gt;                &lt;hr/&gt;                &lt;Child name={this.state.str}/&gt;            &lt;/div&gt;        )    }}</code></pre><h4 id="子向父传值"><a href="#子向父传值" class="headerlink" title="子向父传值"></a>子向父传值</h4><p>子组件</p><pre><code>import React,{Component} from &#39;react&#39;export default class Child1 extends Component{    constructor(props){        super(props)    }    tap(){        // this.props.name == function        // this.props.name() == function()        // this.props.name(xxxx) == function(msg)        // xxxx == msg        console.log(this.refs.ipt.value)        this.props.name(this.refs.ipt.value)    }    render(){        return (            &lt;div&gt;                &lt;h2&gt;子组件&lt;/h2&gt;                &lt;input type=&quot;text&quot; ref=&quot;ipt&quot;/&gt;                &lt;button onClick={()=&gt;this.tap()}&gt;发送子组件数据&lt;/button&gt;            &lt;/div&gt;        )    }}</code></pre><p>父组件</p><pre><code>import React,{Component} from &#39;react&#39;import Child1 from &#39;./Child1&#39;export default class Parent1 extends Component{    constructor(props){        super(props)        this.state = {            str:&#39;&#39;        }    }    render(){        var _this = this        return (            &lt;div&gt;                &lt;h2&gt;父组件&lt;/h2&gt;                &lt;p&gt;子组件数据：{this.state.str}&lt;/p&gt;                &lt;hr/&gt;                &lt;Child1 name={function(msg){                    _this.setState({str:msg})                }}/&gt;            &lt;/div&gt;        )    }}</code></pre><h4 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h4><ul><li><p>三个阶段</p><ul><li><code>mounted</code> 阶段 加载阶段 或者说舒适化阶段 这个阶段组件有 <code>jsx</code> 转换成真是 <code>DOM</code></li><li><code>update</code> 阶段 组件运行中阶段 或者更新阶段 当组件修改自身状态，或者父组件修改子组件属性的时候发生的阶段</li><li><code>umount</code> 阶段 组件卸载阶段 这个一般是组件被浏览器回收的阶段</li></ul></li><li><p>第一阶段 实例化</p><ul><li>getDefaultProps 取消默认属性</li><li>getInitialState 初始化状态</li><li>componentWillMount 即将进入DOM</li><li>render 描画DOM</li><li>componentDidMount 已经进入DOM</li></ul></li><li><p>第二阶段 具体的声明函数周期–运行中阶段 数据更新过程<br>运行汇总阶段只有在父组件修改了子组件的属性或者说一个组件修改自身的状态才会发生的情况</p><ul><li>组件将要接收新值 componentWillReceiveProps (已加载组件收到新的参数是调用)</li><li>组价是否更新 shouldComponentUpdate (影响整个项目的性能，决定视图的更新)</li><li>组件即将更新 componentWillUpdate</li><li>必不可少的 render</li><li>组件更新完毕时运行的函数 componentDidUpdate</li></ul></li><li><p>销毁时 componentWillUnmount</p><ul><li>卸载组件 ReactDOM.unmountComponentAtNode(‘DOM节点’)</li></ul></li></ul><h4 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h4><p>传统：找找到两颗任意的树之间最小的修改时一个复杂度为 O(n^3) 的问题<br>因为需要不同的层级<br>Facebook算法：<br>React 用了一种简单但是强大的技巧，达到了接近 O(n) 的成都<br>把树按照层级分解<br><img src="./01.png" alt=""></p><p>列表比较：写一个 key 属性帮助 React 来处理他们之间的对应关系<br>实际中，在子元素中找到唯一的 key 通常很容易<br><img src="./02.png" alt=""></p><p>Component比较：React app 通常有用户定义的 component 组合而成，<br>通常结果是一个主要是很多的 div 组成的 DOM 树<br>这个信息也被 React 的 diff 算法考虑进去， React 只会匹配相同类型(ES6 class)的 component<br><img src="./03.png" alt=""></p><p>合并操作：当调用 component 的 setState 方法的时候， React 将其标记为 dirty<br>到每一个时间循环结束， React 检查所有标记 dirty 的 component 重新绘制<br><img src="./04.png" alt=""></p><p>选择性子树渲染：在组件上实现下面的方法<br>boolean shouldComponentUpdate(object nextProps,object nextState)<br>根据 component 的前一个和下一个 props/state<br>你可以告诉 React 这个 component  没有封信，也不需要重新绘制<br>实现得好的话，可以带来巨大的性能提升<br><img src="./05.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;纯组件&quot;&gt;&lt;a href=&quot;#纯组件&quot; class=&quot;headerlink&quot; title=&quot;纯组件&quot;&gt;&lt;/a&gt;纯组件&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;import React ,{useState,useEffect} from &amp;#39;react&amp;#39;;
c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>js动画</title>
    <link href="http://1512034032.github.io/2019/11/11/JsAnimation/"/>
    <id>http://1512034032.github.io/2019/11/11/JsAnimation/</id>
    <published>2019-11-11T01:43:27.659Z</published>
    <updated>2019-11-11T01:47:02.941Z</updated>
    
    <content type="html"><![CDATA[<h4 id="运动也可以叫做动画"><a href="#运动也可以叫做动画" class="headerlink" title="运动也可以叫做动画"></a>运动也可以叫做动画</h4><h6 id="1：运动原理"><a href="#1：运动原理" class="headerlink" title="1：运动原理"></a>1：运动原理</h6><p>通过连续不断的改变物体的位置，而发生移动变化。</p><p>使用<code>setInterval</code>实现。</p><p>匀速运动：速度值一直保持不变。</p><p>多物体同时运动：将定时器绑设置为对象的一个属性。</p><p>注：物体每次运动都应该把之前的定时器清除掉。</p><pre><code class="js">//box为绝对定位var speedX = 2box.timer = setInterval(function(){    box.style.left = box.offsetLeft + speedX +&#39;px&#39;;},80)</code></pre><h6 id="2：边界处理"><a href="#2：边界处理" class="headerlink" title="2：边界处理"></a>2：边界处理</h6><p>遇到边界是应该停止掉还是反弹，方向相反。</p><p>改变物体运动方向：将物体的速度值取反。</p><pre><code class="js">//边界属性  浏览器视口宽高//返回当前视口的高度（即浏览器窗口的高度）console.log(document.documentElement.clientHeight)console.log(document.documentElement.clientWidth)// 网页总高度     body默认有margin，记得重置console.log(document.body.clientHeight)console.log(document.body.clientWidth)</code></pre><pre><code class="js">var speedX = 2 box.timer = setInterval(function(){    box.style.left = box.offsetLeft + speedX +&#39;px&#39;;    //左右边界    if(box.offsetLeft &lt;=0 || box.offsetLeft &gt;= cWidth - box.offsetWidth){        speedX = -speedX;    }},80)</code></pre><h6 id="3：加速减速"><a href="#3：加速减速" class="headerlink" title="3：加速减速"></a>3：加速减速</h6><p>加速：速度越来越快。</p><p>减速：速度越来越慢。</p><pre><code class="js">box.timer = setInterval(function() {    speedX = speedX + 2;    div.style.left = div.offsetLeft + speedX + &#39;px&#39;;}, 50);</code></pre><h6 id="4：抛物线"><a href="#4：抛物线" class="headerlink" title="4：抛物线"></a>4：抛物线</h6><p>水平方向有一速度，垂直方向有一速度，并做自由落体。</p><pre><code class="js">var speedY = 0;var speedX = 10;// x 方向  匀速// y 方向  匀加速box.timer = setInterval(function() {    speedY += 9.8    box.style.left = box.offsetLeft + speedX + &#39;px&#39;;    box.style.top = box.offsetTop + speedY + &#39;px&#39;;}, 80)</code></pre><h6 id="5：透明度的变换"><a href="#5：透明度的变换" class="headerlink" title="5：透明度的变换"></a>5：透明度的变换</h6><p>box逐渐消失</p><pre><code class="js">//使用css将box的opacity 设置为1var op = 1;box.timer = setInterval(function() {    op = op - 0.01;    div.style.opacity = op    //或者    //div.style.opacity = getComputedStyle(div).opacity - 0.01;}, 80);</code></pre><h6 id="6：缓冲运动"><a href="#6：缓冲运动" class="headerlink" title="6：缓冲运动"></a>6：缓冲运动</h6><p>速度一开始很大，然后慢慢变小，比较类似自然界中的缓冲运动</p><pre><code class="js">//一开始box 在 （0，0）位置，我们将box运动到（300,0）位置var target = 300; //目标位置box.timer = setInterval(function() {    //target - div.offsetLeft 是元素距离目标的路程，随着越来越靠近目标，这个值就越来越小，如果把这个值当做速度，速度一开始很大，然后慢慢变小，比较类似自然界中的缓冲运动。如果把这个值直接当速度，一下子就到，所以除以8以后当做速度    var speed = (target - div.offsetLeft) / 8;    //所以要对速度向上取整得到速度1，当speed小于0.375的时候，div就不会移动了    speed = Math.ceil(speed);    box.style.left = div.offsetLeft + speed + &#39;px&#39;;    if(box.offsetLeft == target) {        //到达目标清除定时器        clearInterval(box.timer);    }}, 30);</code></pre><p>考虑到运动的时候可能往前，也可以能往后，增加判断</p><pre><code class="js">//一开始box 在 （0，0）位置，我们将box运动到（300,0）位置var target = 300; //目标位置div.timer = setInterval(function() {    var speed = (target - div.offsetLeft) / 8;    //当speed小于0.375的时候，div就不会移动了    //所以要对速度向上取整或者向下取整    if(speed &gt; 0) {        //speed大于0 说明是往前运动        //当speed小于0.375的时候，div就不会移动了        //所以要对速度向上取整或者向下取整        speed = Math.ceil(speed);    } else {        //speed大于0 说明是往后运动        speed = Math.floor(speed);    }    div.style.left = div.offsetLeft + speed + &#39;px&#39;;    if(div.offsetLeft == target) {        clearInterval(div.timer);    }}, 30);</code></pre><p>上面代码封装为函数</p><pre><code class="js">function animate(div,targetX) {    var target = targetX;    div.timer =  setInterval(function () {        var speed = (target - div.offsetTop)/8;        speed = (speed&gt;0? Math.ceil(speed): Math.floor(speed));        div.style.top = div.offsetTop + speed +&#39;px&#39;;        if(div.offsetTop == target){            clearInterval(div.timer);        }    },30);}</code></pre><h6 id="7：多属性缓冲运动函数封装"><a href="#7：多属性缓冲运动函数封装" class="headerlink" title="7：多属性缓冲运动函数封装"></a>7：多属性缓冲运动函数封装</h6><p>上面的封装只能固定的在x方向做动画</p><p>如果想让一个div 从一个点运动到另一个点，怎么办？</p><p>比如从（0，0）到（100，200）这个时候我们把第二个参数改为一个这样的对象<code>{left:100;top:200}</code></p><pre><code class="js">function animate(div, obj) {    //{left:100;top:200}    //{left:100}    clearInterval(div.timer);    div.timer = setInterval(function() {        var flag = true; //假设已经到了目的地        for(var key in obj) {            console.log(key) //left   top            console.log(obj[key]) //300            var target = obj[key]; //目标值            // getComputedStyle[&#39;left&#39;]  元素left 属性 当前值            var speed = (target - parseInt(getComputedStyle(div)[key])) / 8;                          speed = (speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed));                              div.style[key] = parseInt(getComputedStyle(div)[key]) + speed + &#39;px&#39;;            if(parseInt(getComputedStyle(div)[key]) != target) {                flag = false;            }        }        //必须等到所有的 属性都到达目的地 才能结束定时器        if(flag == true) {            clearInterval(div.timer);        }    }, 30);}</code></pre><p>上面咱们就封装了一个运动函数，也可以叫运动框架，说白了，就是封装一次以后，我们再做一些动画就非常方便！前人栽树后人乘凉，便是框架的好处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;运动也可以叫做动画&quot;&gt;&lt;a href=&quot;#运动也可以叫做动画&quot; class=&quot;headerlink&quot; title=&quot;运动也可以叫做动画&quot;&gt;&lt;/a&gt;运动也可以叫做动画&lt;/h4&gt;&lt;h6 id=&quot;1：运动原理&quot;&gt;&lt;a href=&quot;#1：运动原理&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="前端" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Js" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/Js/"/>
    
    
      <category term="Js" scheme="http://1512034032.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>Math&amp;&amp;Date</title>
    <link href="http://1512034032.github.io/2019/11/11/MathAndDate/"/>
    <id>http://1512034032.github.io/2019/11/11/MathAndDate/</id>
    <published>2019-11-11T01:43:27.656Z</published>
    <updated>2019-11-11T01:40:48.972Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><h5 id="一、Math介绍"><a href="#一、Math介绍" class="headerlink" title="一、Math介绍"></a>一、Math介绍</h5><pre><code class="js">Math是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。Math对象的属性，提供以下一些数学常数。（了解）Math.E：常数e。Math.PI：常数 Pi。</code></pre><h5 id="二、Math方法"><a href="#二、Math方法" class="headerlink" title="二、Math方法"></a>二、Math方法</h5><h6 id="Math-abs"><a href="#Math-abs" class="headerlink" title="Math.abs"></a>Math.abs</h6><pre><code class="js">//Math.abs方法返回参数值的绝对值。Math.abs(1) // 1Math.abs(-1) // 1</code></pre><h6 id="Math-max-min"><a href="#Math-max-min" class="headerlink" title="Math.max/min"></a>Math.max/min</h6><pre><code class="js">Math.max方法返回参数之中最大的那个值，Math.min返回最小的那个值。如果参数为空, Math.min返回Infinity, Math.max返回-Infinity。Infinity 用于存放表示正无穷大的数值Math.max(2, -1, 5) // 5Math.min(2, -1, 5) // -1Math.min() // InfinityMath.max() // -Infinity</code></pre><h6 id="Math-floor-ceil最大-最小整数值"><a href="#Math-floor-ceil最大-最小整数值" class="headerlink" title="Math.floor/ceil最大/最小整数值"></a>Math.floor/ceil最大/最小整数值</h6><pre><code class="js">Math.floor方法小于参数值的最大整数（地板值）。Math.floor(3.2) // 3Math.floor(-3.2) // -4Math.ceil方法返回大于参数值的最小整数（天花板值）。Math.ceil(3.2) // 4Math.ceil(-3.2) // -3</code></pre><h6 id="Math-round四舍五入"><a href="#Math-round四舍五入" class="headerlink" title="Math.round四舍五入"></a>Math.round四舍五入</h6><pre><code class="js">Math.round方法用于四舍五入。Math.round(0.1) // 0Math.round(0.5) // 1Math.round(0.6) // 1Math.round(-1.1) // -1Math.round(-1.5) // -1Math.round(-1.6) // -2</code></pre><h6 id="Math-pow平方"><a href="#Math-pow平方" class="headerlink" title="Math.pow平方"></a>Math.pow平方</h6><pre><code class="js">Math.pow方法返回以第一个参数为底数、第二个参数为幂的指数值。// 等同于 2 ** 2Math.pow(2, 2) // 4// 等同于 2 ** 3Math.pow(2, 3) // 8</code></pre><h6 id="Math-sqrt平方根"><a href="#Math-sqrt平方根" class="headerlink" title="Math.sqrt平方根"></a>Math.sqrt平方根</h6><pre><code class="js">Math.sqrt方法返回参数值的平方根。如果参数是一个负值，则返回NaN。Math.sqrt(4) // 2Math.sqrt(-4) // NaN勾股定理复习a^2+b^2=c^2</code></pre><h6 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h6><pre><code class="js">Math对象还提供一系列三角函数方法Math.sin()：返回参数的正弦（参数为弧度值）Math.cos()：返回参数的余弦（参数为弧度值）Math.tan()：返回参数的正切（参数为弧度值）30*Math.PI/180   角度转为弧度Math.sin(0) // 0Math.cos(0) // 1Math.tan(0) // 0Math.sin(Math.PI / 2) // 1</code></pre><h6 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h6><pre><code class="js">Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。Math.random() // 0.7151307314634323任意范围的随机整数生成函数如下。function getRandomInt(min, max) {  return parseInt(Math.random() * (max - min + 1)) + min;}getRandomInt(1, 6) // 5</code></pre><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><pre><code class="js">作为构造函数时，Date对象可以接受多种格式的参数，返回一个该参数对应的时间实例。// 参数为时间零点开始计算的毫秒数new Date(1378218728000)（最常用）// Tue Sep 03 2013 22:32:08 GMT+0800 (CST)/ 参数为多个整数，// 代表年、月、日、小时、分钟、秒、毫秒new Date(2013, 0, 1, 0, 0, 0, 0)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)参数也可以是一个字符串（最常用）日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即YYYY-MM-DDTHH:mm:ss.sssZ格式new Date(&#39;2013-2-15&#39;)new Date(&#39;2013/2/15&#39;)new Date(&#39;02/15/2013&#39;)new Date(&#39;2013-FEB-15&#39;)new Date(&#39;FEB, 15, 2013&#39;)new Date(&#39;Feberuary, 15, 2013&#39;)new Date(&#39;15 Feb 2013&#39;)new Date(&#39;15, Feberuary, 2013&#39;) 上面多种日期字符串的写法，返回的都是同一个时间</code></pre><h6 id="Date日期处理"><a href="#Date日期处理" class="headerlink" title="Date日期处理"></a>Date日期处理</h6><pre><code class="js">//获取:            oDate.getDate()            //返回一个月中的某一天 (1 ~ 31)            oDate.getDay()            //返回一周中的某一天 (0 ~ 6)            oDate.getMonth()        //返回月份 (0 ~ 11)            oDate.getFullYear()        //以四位数字返回年份            oDate.getHours()        //返回当前小时（0-23）            oDate.getMinutes()        //返回当前分钟 (0 ~ 59)            oDate.getSeconds()        //返回当前秒(0 ~ 59)            oDate.getMillisenconds()//返回当前毫秒(0 ~ 999)            //注意，月份从0开始计算，但是，天数从1开始计算。另外，除了日期的默认值为1，小时、分钟、秒钟和毫秒的默认值都是0。            new Date(2013, 15)            // Tue Apr 01 2014 00:00:00 GMT+0800 (CST)//设置：            oDate.getTime()返回1970年1月1日至今的毫秒数            oDate.setDate();        //设置月中的某一天 (1 ~ 31)            oDate.setMonth();        //设置月份 (0 ~ 11)            //例：oDate.setMonth(9);  alert(oDate.getMonth())            oDate.setFullYear();    //设置年份（四位数）            oDate.setHours();        //设置小时（0-23）            oDate.setMinutes();        //设置分钟 (0 ~ 59)            oDate.setSeconds();        //设置秒(0 ~ 59)            oDate.setMillisenconds();//设置毫秒(0 ~ 999)            oDate.setTime();        //设置1970年1月1日至今的毫秒数            //这些参数如果超出了正常范围，会被自动折算。比如，如果月设为15，就折算为下一年的4月</code></pre><h6 id="Date静态方法"><a href="#Date静态方法" class="headerlink" title="Date静态方法"></a>Date静态方法</h6><pre><code class="js">Date.parse方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即YYYY-MM-DDTHH:mm:ss.sssZ格式，其中最后的Z表示时区。但是，其他格式也可以被解析，请看下面的例子。Date.parse(&#39;Aug 9, 1995&#39;)Date.parse(&#39;January 26, 2011 13:51:50&#39;)Date.parse(&#39;Mon, 25 Dec 1995 13:30:00 GMT&#39;)Date.parse(&#39;Mon, 25 Dec 1995 13:30:00 +0430&#39;)Date.parse(&#39;2011-10-10&#39;)Date.parse(&#39;2011-10-10T14:48:00&#39;)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Math&quot;&gt;&lt;a href=&quot;#Math&quot; class=&quot;headerlink&quot; title=&quot;Math&quot;&gt;&lt;/a&gt;Math&lt;/h4&gt;&lt;h5 id=&quot;一、Math介绍&quot;&gt;&lt;a href=&quot;#一、Math介绍&quot; class=&quot;headerlink&quot; title=&quot;一
      
    
    </summary>
    
    
      <category term="前端" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Js" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/Js/"/>
    
    
      <category term="Js" scheme="http://1512034032.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>ES6</title>
    <link href="http://1512034032.github.io/2019/11/11/es6/"/>
    <id>http://1512034032.github.io/2019/11/11/es6/</id>
    <published>2019-11-11T01:43:27.652Z</published>
    <updated>2019-11-11T01:48:27.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ul><li>重点知识<ul><li>this关键字以及bind</li><li>let/const</li><li>变量解构</li><li>箭头函数</li><li>模板字符串</li><li>class和继承</li></ul></li></ul><hr><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言</p><hr><h6 id="1：this关键字"><a href="#1：this关键字" class="headerlink" title="1：this关键字"></a>1：this关键字</h6><p><code>this</code>可以用在构造函数之中，表示实例对象。除此之外，<code>this</code>还可以用在别的场合。但不管是什么场合，<code>this</code>都有一个共同点：它总是返回一个对象简单说，<code>this</code>就是属性或方法“当前”所在的对象。</p><pre><code class="js">var person = {    name: &#39;张三&#39;,    describe: function (){        return &#39;姓名：&#39;+ this.name;    }};person.describe()// &quot;姓名：张三&quot;</code></pre><p>上面代码中，<code>this.name</code>表示<code>name</code>属性所在的那个对象。由于<code>this.name</code>是在<code>describe</code>方法中调用，而<code>describe</code>方法所在的当前对象是<code>person</code>，因此<code>this</code>指向<code>person</code>，<code>this.name</code>就是<code>person.name</code>。</p><p><code>this</code>主要有以下几个使用场合</p><p><strong>（1）全局环境</strong></p><pre><code class="js">//全局环境使用this，它指的就是顶层对象window。this === window // truefunction f() {    console.log(this === window);}f() // true//注：严格模式下 普通函数内部 this 等于 undefined</code></pre><p><strong>（2）构造函数</strong></p><p>构造函数中的<code>this</code>，指的是实例对象</p><pre><code class="js">function Person(p) {    this.p = p;};var obj = new Person()</code></pre><p><strong>（3）对象的方法</strong></p><p>如果对象的方法里面包含<code>this</code>，<code>this</code>的指向就是方法运行时所在的对象。</p><pre><code class="js">var obj ={    foo: function () {        console.log(this);    }};obj.foo() // obj </code></pre><hr><h6 id="2：bind方法"><a href="#2：bind方法" class="headerlink" title="2：bind方法"></a>2：bind方法</h6><p><code>bind</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数。</p><pre><code class="js">var dog ={    name:&#39;wangcai&#39;,    age:18,    wang:function(){        console.log(this)    }}var person = {name:&#39;小明&#39;}var func = dog.wang.bind(person)func();//上面代码将person绑定到了func函数内部</code></pre><hr><h6 id="3：let-const"><a href="#3：let-const" class="headerlink" title="3：let/const"></a>3：<strong>let/const</strong></h6><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><pre><code class="js">{    let a = 10;  var b = 1;}a // ReferenceError: a is not defined.b // 1</code></pre><p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p><p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p><pre><code class="js">var oLis = document.getElementsByTagName(&#39;li&#39;)for (let i = 0; i &lt; oLis.length; i++) {    // ...    oLis[i].onclick = function(){        console.log(i)// 0 1 2 3 4    }}console.log(i);// ReferenceError: i is not defined//上面代码相当与产生了几个块级作用域{    var i=0;    oLis[i].onclick = function(){        console.log(i)    }}{    var i=1;    oLis[i].onclick = function(){        console.log(i)    }}</code></pre><p>上面代码中，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外引用就会报错。</p><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景，let实际上为 JavaScript 新增了块级作用域<strong>。</strong></p><p><code>var</code>命令会发生”变量提升“现象，即变量可以在声明之前使用，值为<code>undefined</code>。</p><p>这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p><p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p><h6 id="4：const命令"><a href="#4：const命令" class="headerlink" title="4：const命令"></a>4：const命令</h6><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p><p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值</p><pre><code class="js">const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable.</code></pre><p>上面代码表明改变常量的值会报错。</p><hr><h6 id="5：箭头函数-gt"><a href="#5：箭头函数-gt" class="headerlink" title="5：箭头函数 =&gt;"></a>5：箭头函数 =&gt;</h6><p>ES6 允许使用“箭头”（=&gt;）定义函数。</p><pre><code class="js">var f = v =&gt; v;// 等同于var f = function (v) {    return v;};</code></pre><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p><pre><code class="js">var f = () =&gt; 5;// 等同于var f = function () {     return 5 };var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) {    return num1 + num2;};</code></pre><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。</p><pre><code class="js">var sum = (num1, num2) =&gt; { return num1 + num2; }</code></pre><p>箭头函数使得表达更加简洁。</p><pre><code class="js">const isEven = n =&gt; n % 2 == 0;const square = n =&gt; n * n;</code></pre><p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p><p>箭头函数的一个用处是简化回调函数。</p><pre><code class="js">// 正常函数写法[1,2,3].map(function (x) {      return x * x;});// 箭头函数写法[1,2,3].map(x =&gt; x * x);// 正常函数写法var result = values.sort(function (a, b) {    return a - b;});// 箭头函数写法var result = values.sort((a, b) =&gt; a - b);</code></pre><p>箭头函数有几个使用注意点。</p><p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p><p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p><p>（3）不可以使用arguments对象，该对象在函数体内不存在。</p><hr><h6 id="6：变量解构（解构赋值）"><a href="#6：变量解构（解构赋值）" class="headerlink" title="6：变量解构（解构赋值）"></a>6：变量解构（解构赋值）</h6><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构</p><p>以前，为变量赋值，只能直接指定值。</p><pre><code class="js">let a = 1;let b = 2;let c = 3;</code></pre><p>ES6 允许写成下面这样。</p><pre><code class="js">let [a, b, c] = [1, 2, 3];</code></pre><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值<br>解构不仅可以用于数组，还可以用于对象</p><pre><code class="js">let { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };foo // &quot;aaa&quot;bar // &quot;bbb&quot;</code></pre><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值</p><pre><code class="js">let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };foo // &quot;aaa&quot;bar // &quot;bbb&quot;let { foo} = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };foo // &quot;aaa&quot;</code></pre><h6 id="7：字符串扩展"><a href="#7：字符串扩展" class="headerlink" title="7：字符串扩展"></a>7：字符串扩展</h6><blockquote><p>模板字符串（template string）是增强版的字符串</p></blockquote><p>传统的 JavaScript 语言，输出模板通常是这样写的。</p><pre><code class="js">var a = 1var b = 2;var sum = a + b;var res = a + &#39;+&#39; + b + &#39;的和是&#39; + c+&#39;&#39;;console.log(res)box.innerHTML = res;var obj=  {name:&#39;zhangsan&#39;,age:18};var str = &#39;姓名：&#39;+obj.name+&#39;年龄:&#39;+obj.age;div.innerHTML = str;</code></pre><p>上面这种写法(拼字符串)相当繁琐不方便，ES6 引入了模板字符串解决这个问题。模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，可以在字符串中嵌入变量， 模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。</p><pre><code class="js">var a = 1var b = 2;var sum = a + b;var res =`a+b的和是&lt;b&gt;{c}&lt;/b&gt;`;console.log(res)box.innerHTML = res;var obj=  {name:&#39;zhangsan&#39;,age:18};var str =`&lt;b&gt;姓名&lt;/b&gt;：{obj.name}年龄:{obj.age}`div.innerHTML = str;</code></pre><p>上面代码中的模字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义</p><pre><code class="js">let greeting = `\`Yo\` World!`;</code></pre><p> 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中</p><pre><code class="js">oDiv.innerHTML = `    &lt;ul&gt;      &lt;li&gt;first&lt;/li&gt;      &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`</code></pre><p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p><pre><code class="js">et x = 1;let y = 2;`${x} + ${y} = ${x + y}`// &quot;1 + 2 = 3&quot;`${x} + ${y * 2} = ${x + y * 2}`// &quot;1 + 4 = 5&quot;let obj = {x: 1, y: 2};`${obj.x + obj.y}`</code></pre><p>模板字符串之中还能调用函数</p><pre><code class="js">function fn() {    return &quot;Hello World&quot;;}`foo ${fn()} bar`// foo Hello World bar</code></pre><p>字符串扩张方法</p><hr><p>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p><p>​    <code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</p><p>​    <code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</p><p>​    <code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</p><pre><code class="js">let s = &#39;Hello world!&#39;;s.startsWith(&#39;Hello&#39;) // trues.endsWith(&#39;!&#39;) // trues.includes(&#39;o&#39;) // true</code></pre><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复n次</p><pre><code class="js">&#39;x&#39;.repeat(3) // &quot;xxx&quot;&#39;hello&#39;.repeat(2) // &quot;hellohello&quot;&#39;na&#39;.repeat(0) // &quot;&quot;</code></pre><hr><h6 id="7-1：数组新增方法"><a href="#7-1：数组新增方法" class="headerlink" title="7.1：数组新增方法"></a>7.1：数组新增方法</h6><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（ES6 新增的数据结构 <code>Set</code> 和 <code>Map</code>）</p><p>下面是一个类似数组的对象，Array.from将它转为真正的数组</p><pre><code class="js">let arrayLike = {        &#39;0&#39;: &#39;a&#39;,        &#39;1&#39;: &#39;b&#39;,        &#39;2&#39;: &#39;c&#39;,        length: 3};let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre><p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。</p><p>Array.from都可以将它们转为真正的数组<br>对象扩展<br>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p><pre><code class="js">const foo = &#39;bar&#39;;const baz = {foo};baz // {foo: &quot;bar&quot;}// 等同于const baz = {foo: foo};</code></pre><p>除了属性简写，方法也可以简写。</p><pre><code class="js">const o = {      method() {            return &quot;Hello!&quot;;      }};// 等同于const o = {      method: function() {            return &quot;Hello!&quot;;      }};</code></pre><hr><h6 id="8：扩展运算符"><a href="#8：扩展运算符" class="headerlink" title="8：扩展运算符"></a>8：扩展运算符</h6><p>扩展运算符三个点（…）<br>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p><pre><code class="js">let z = { a: 3, b: 4 };let n = { ...z };n // { a: 3, b: 4 }</code></pre><p>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</p><pre><code class="js">let foo = { ...[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] };foo// {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;}</code></pre><p>对象的扩展运算符等同于使用Object.assign()方法。</p><pre><code class="js">let aClone = { ...a };// 等同于let aClone = Object.assign({}, a);</code></pre><pre><code class="js">function add(x, y) {     return x + y; } var numbers = [4, 38]; add(...numbers) ////该运算符将一个数组，变为参数序列 var arr1 = [&#39;a&#39;, &#39;b&#39;]; var arr2 = [&#39;c&#39;]; var arr3 = [&#39;d&#39;, &#39;e&#39;];// 合并数组 [...arr1, ...arr2, ...arr3]</code></pre><hr><h6 id="9：函数参数默认值"><a href="#9：函数参数默认值" class="headerlink" title="9：函数参数默认值"></a>9：函数参数默认值</h6><p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p><pre><code class="js">function log(x, y) {      y = y || &#39;World&#39;;      console.log(x, y);}log(&#39;Hello&#39;) // Hello Worldlog(&#39;Hello&#39;, &#39;China&#39;) // Hello China //这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。</code></pre><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><pre><code class="js">function log(x, y = &#39;World&#39;) {      console.log(x, y);}log(&#39;Hello&#39;) // Hello Worldlog(&#39;Hello&#39;, &#39;China&#39;) // Hello China</code></pre><p>可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。</p><hr><h6 id="10：Symbol类型"><a href="#10：Symbol类型" class="headerlink" title="10：Symbol类型"></a>10：Symbol类型</h6><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p><p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。</p><p>它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（<code>Boolean</code>）、字符串（<code>String</code>）、数值（<code>Number</code>）、对象（<code>Object</code>）</p><p>Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。</p><p>凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突</p><pre><code class="js">let s = Symbol();typeof s// &quot;symbol&quot;</code></pre><p>上面代码中，变量<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是 Symbol 数据类型，而不是字符串之类的其他类型注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。</p><p>这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><pre><code class="js">let s1 = Symbol(&#39;foo&#39;);let s2 = Symbol(&#39;bar&#39;);s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // &quot;Symbol(foo)&quot;s2.toString() // &quot;Symbol(bar)&quot;</code></pre><p>上面代码中，<code>s1</code>和<code>s2</code>是两个 Symbol 值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。<br>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p><pre><code class="js">// 没有参数的情况let s1 = Symbol();let s2 = Symbol();s1 === s2 // false// 有参数的情况let s1 = Symbol(&#39;foo&#39;);let s2 = Symbol(&#39;foo&#39;);s1 === s2 // false</code></pre><p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的。Symbol 值也可以转为布尔值，但是不能转为数值</p><pre><code class="js">let sym = Symbol();Boolean(sym) // true!sym // falseif (sym) {    // ...}Number(sym) // TypeErrorsym + 2 // TypeError</code></pre><p>作为属性名的 Symbol由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性，能防止某一个键被不小心改写或覆盖。</p><pre><code class="js">// 第一种写法let a = {};a[mySymbol] = &#39;Hello!&#39;;// 第二种写法let a = {    [mySymbol]: &#39;Hello!&#39;};// 以上写法都得到同样结果a[mySymbol] // &quot;Hello!&quot;注意，Symbol 值作为对象属性名时，不能用点运算符。const mySymbol = Symbol();const a = {};a.mySymbol = &#39;Hello!&#39;;a[mySymbol] // undefineda[&#39;mySymbol&#39;] // &quot;Hello!&quot;</code></pre><p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p><pre><code class="js">let s = Symbol();let obj = {    [s]: function (arg) {        ...    }};obj[s];</code></pre><p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个 Symbol 值。</p><hr><h6 id="11：Set和Map结构"><a href="#11：Set和Map结构" class="headerlink" title="11：Set和Map结构"></a>11：Set和Map结构</h6><p>ES6 提供了新的数据结构 <code>Set</code>。</p><blockquote><p>它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p></blockquote><pre><code class="js">const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) {    console.log(i);}// 2 3 5 4</code></pre><p>上面代码通过<code>add</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。<br>Set 函数可以接受一个数组（获取dom的nodelist对象）作为参数，用来初始化。</p><pre><code class="js">// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 8// 例三const set = new Set(document.querySelectorAll(&#39;div&#39;));set.size // 56</code></pre><p>上面代码也展示了一种去除数组重复成员的方法。</p><pre><code class="js">// 去除数组的重复成员[...new Set(array)]</code></pre><p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。</p><p>Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p><pre><code class="js">let set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // Set {NaN}</code></pre><p>Set 结构的实例有以下属性</p><p>​    <code>constructor</code>：构造函数，默认就是<code>Set</code>函数。</p><p>​    <code>size</code>：返回<code>Set</code>实例的成员总数。</p><p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。</p><ul><li>下面四个操作方法<ul><li>- add(value)：添加某个值，返回 Set 结构本身。</li><li>-delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li><li>-has(value)：返回一个布尔值，表示该值是否为Set的成员。</li><li>-clear()：清除所有成员，没有返回值。</li></ul></li></ul><pre><code class="js">s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false</code></pre><p><code>Array.from</code>方法可以将 Set 结构转为数组。</p><pre><code class="js">const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items);Set 结构的实例默认可遍历let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);for (let x of set) {  console.log(x);}// red// green// blue</code></pre><p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p><pre><code class="js">set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))// 1 : 1// 4 : 4// 9 : 9</code></pre><p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。</p><p>这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p><p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p><pre><code class="js">let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2]</code></pre><p><strong>map结构</strong></p><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><p>ES6 提供了 <code>Map</code> 数据结构。</p><p>它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><p>Map 结构的实例有以下属性和操作方法。</p><p><strong>（1）size 属性</strong><br><code>size</code>属性返回 Map 结构的成员总数。</p><pre><code class="js">const map = new Map();map.set(&#39;foo&#39;, true);map.set(&#39;bar&#39;, false);map.size // 2</code></pre><p><strong>（2）set(key, value)</strong><br><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p><pre><code class="js">const m = new Map();m.set(&#39;edition&#39;, 6)// 键是字符串m.set(262, &#39;standard&#39;)// 键是数值m.set(undefined, &#39;nah&#39;)// 键是 undefined</code></pre><p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p><pre><code class="js">let map = new Map().set(1, &#39;a&#39;).set(2, &#39;b&#39;).set(3, &#39;c&#39;);</code></pre><p><strong>（3）get(key)</strong><br><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p><pre><code class="js">const m = new Map();const hello = function() {    console.log(&#39;hello&#39;);};m.set(hello, &#39;Hello ES6!&#39;) // 键是函数m.get(hello) // Hello ES6!</code></pre><p><strong>（4）has(key)</strong><br><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p><pre><code class="js">const m = new Map();m.set(&#39;edition&#39;, 6);m.set(262, &#39;standard&#39;);m.set(undefined, &#39;nah&#39;);m.has(&#39;edition&#39;)    // truem.has(&#39;years&#39;)      // falsem.has(262)          // truem.has(undefined)    // true</code></pre><p><strong>（5）delete(key)</strong><br><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p><pre><code class="js">const m = new Map();m.set(undefined, &#39;nah&#39;);m.has(undefined)    // truem.delete(undefined)m.has(undefined)      // false</code></pre><p><strong>（6）clear()</strong><br><code>clear</code>方法清除所有成员，没有返回值。</p><pre><code class="js">let map = new Map();map.set(&#39;foo&#39;, true);map.set(&#39;bar&#39;, false);map.size // 2map.clear()map.size // 0</code></pre><p>遍历map<br>需要特别注意的是，Map 的遍历顺序就是插入顺序</p><pre><code class="js">const map = new Map([  [&#39;F&#39;, &#39;no&#39;],  [&#39;T&#39;,  &#39;yes&#39;],]);for (let [key, value] of map) {    console.log(key, value);}// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;</code></pre><h6 id="12：Generators生成器函数"><a href="#12：Generators生成器函数" class="headerlink" title="12：Generators生成器函数"></a>12：Generators生成器函数</h6><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p><p> Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p><p> 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><ul><li>形式上，Generator 函数是一个普通函数，但是有两个特征。<ul><li>一是，<code>function</code>关键字与函数名之间有一个星号；</li><li>二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）</li></ul></li></ul><pre><code class="js">function* helloWorldGenerator() {    yield &#39;hello&#39;;    yield &#39;world&#39;;    return &#39;ending&#39;;}var hw = helloWorldGenerator();</code></pre><p>上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p><p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。</p><p>不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象<br><strong>yield 表达式</strong><br>由于 Generator 函数返回的遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。</p><p><code>yield</code>表达式就是暂停标志。</p><p>（1）遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</p><p>（2）下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</p><p>（3）如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</p><p>（4）如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code></p><p>下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p><pre><code class="js">hw.next()// { value: &#39;hello&#39;, done: false }hw.next()// { value: &#39;world&#39;, done: false }hw.next()// { value: &#39;ending&#39;, done: true }hw.next()// { value: undefined, done: true }</code></pre><p>上面代码一共调用了四次<code>next</code>方法。</p><blockquote><p>第一次调用，Generator 函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p></blockquote><blockquote><p>第二次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到下一个<code>yield</code>表达式。<code>next</code>方法返回的对象的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>world</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p></blockquote><blockquote><p>第三次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到<code>return</code>语句（如果没有<code>return</code>语句，就执行到函数结束）。<code>next</code>方法返回的对象的<code>value</code>属性，就是紧跟在<code>return</code>语句后面的表达式的值（如果没有<code>return</code>语句，则<code>value</code>属性的值为<code>undefined</code>），<code>done</code>属性的值<code>true</code>，表示遍历已经结束。</p></blockquote><blockquote><p>第四次调用，此时 Generator 函数已经运行完毕，<code>next</code>方法返回对象的<code>value</code>属性为<code>undefined</code>，<code>done</code>属性为<code>true</code>。以后再调用<code>next</code>方法，返回的都是这个值。</p></blockquote><p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。</p><p>以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。</p><p><code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p><hr><h6 id="13：class的写法及继承"><a href="#13：class的写法及继承" class="headerlink" title="13：class的写法及继承"></a>13：class的写法及继承</h6><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子</p><pre><code class="js">function Point(x, y) {    this.x = x;    this.y = y;}Point.prototype.toString = function () {    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;};var p = new Point(1, 2);</code></pre><p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。<br>通过<code>class</code>关键字，可以定义类。<br>基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><p>上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</p><pre><code class="js">//定义类class Point {    constructor(x, y) {        this.x = x;        this.y = y;    }      toString() {          return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;        }}</code></pre><p>上面代码定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。也就是说，ES5 的构造函数<code>Point</code>，对应 ES6 的<code>Point</code>类的构造方法<br><code>point</code>类除了构造方法，还定义了一个<code>toString</code>方法。</p><p>注意，定义“类”的方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p><pre><code class="js">//hasOwnProperty 可以用来判断对象是否有每一个属性point.hasOwnProperty(&#39;x&#39;) // truepoint.hasOwnProperty(&#39;y&#39;) // true</code></pre><p>ES6 的类，完全可以看作构造函数的另一种写法</p><pre><code class="js">class Point {    // ...}typeof Point // &quot;function&quot;</code></pre><p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数</p><p>类的属性名，可以采用表达式。</p><pre><code class="js">let methodName = &#39;getArea&#39;;class Square {    constructor(length){        // ...    }      methodName {        // ...    }}</code></pre><p>上面代码中，<code>Square</code>类的方法名<code>getArea</code>，是从表达式得到的。</p><p>类内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。<br>考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p><p><strong>constructor 方法</strong><br><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p><pre><code class="js">class Point {}// 等同于class Point {    constructor() {    }}</code></pre><p>上面代码中，定义了一个空的类<code>Point</code>，JavaScript 引擎会自动为它添加一个空的<code>constructor</code>方法。<br><code>constructor</code>方法默认返回实例对象（即<code>this</code>）</p><p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p><pre><code class="js">class Foo {    constructor() {    }}Foo()// TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;</code></pre><p>生成类的实例对象的写法，与 ES5 完全一样，也是使用<code>new</code>命令。前面说过，如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错。</p><pre><code class="js">class Point {    // ...}// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3);</code></pre><p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p><pre><code class="js">new Foo(); // ReferenceErrorclass Foo {}</code></pre><p>类方法<br>加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><pre><code class="js">class Foo {    static classMethod() {        return &#39;hello&#39;;    }}Foo.classMethod() // &#39;hello&#39;var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function</code></pre><p>上面代码中，Foo类的classMethod方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（<code>Foo.classMethod()</code>），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p><p>类的继承Class 可以通过<code>extends</code>关键字实现继承 这比 ES5 的通过修改原型链（在后面章节会讲解）实现继承，要清晰和方便很多。</p><pre><code class="js">class Point {}class ColorPoint extends Point {}</code></pre><p>上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。下面，我们在<code>ColorPoint</code>内部加上代码。</p><pre><code class="js">class ColorPoint extends Point {    constructor(x, y, color) {        super(x, y); // 调用父类的constructor(x, y)        this.color = color;    }    toString() {        return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()    }}</code></pre><p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。<br>ES6 要求，子类的构造函数必须执行一次<code>super</code>函数</p><p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p><pre><code class="js">class Point { /* ... */ }class ColorPoint extends Point {    constructor() {  }}let cp = new ColorPoint(); // ReferenceError</code></pre><p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super</code>方法，导致新建实例时报错。</p><p>需要注意的地方是，在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有<code>super</code>方法才能返回父类实例</p><pre><code class="js">class Point {    constructor(x, y) {        this.x = x;        this.y = y;    }}class ColorPoint extends Point {    constructor(x, y, color) {        this.color = color; // ReferenceError        super(x, y);        this.color = color; // 正确    }}</code></pre><p>上面代码中，子类的<code>constructor</code>方法没有调用<code>super</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super</code>方法之后就是正确的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;重点知识&lt;ul&gt;
&lt;li&gt;this关键字以及bind&lt;/li&gt;
&lt;li&gt;let/const&lt;/li&gt;
&lt;li&gt;变量解构&lt;
      
    
    </summary>
    
    
      <category term="前端" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Js" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/Js/"/>
    
    
      <category term="ES6" scheme="http://1512034032.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>js正则</title>
    <link href="http://1512034032.github.io/2019/11/11/regular/"/>
    <id>http://1512034032.github.io/2019/11/11/regular/</id>
    <published>2019-11-11T01:43:27.649Z</published>
    <updated>2019-11-11T01:32:41.178Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1：正则的概念"><a href="#1：正则的概念" class="headerlink" title="1：正则的概念"></a>1：正则的概念</h4></li></ul><blockquote><p>正则表达式(regular expression)是一个描述字符规则的对象。可以用来检查一个字符串是否含有某个子字符串，将匹配的子字符串做替换或者从某个字符串中取出符合某个条件的子串等。</p></blockquote><p>为什么要用正则：</p><blockquote><p>前端往往有大量的表单数据校验工作，采用正则表达式会使得数据校验的工作量大大减轻。常用效果：邮箱、手机号、身份证号等。</p></blockquote><ul><li><h4 id="2：创建方式"><a href="#2：创建方式" class="headerlink" title="2：创建方式"></a>2：创建方式</h4></li></ul><p>第一种方式：</p><pre><code class="js">var reg = new RegExp(“study”，“ig”);   // 第二个参数为修饰符</code></pre><p> i：表示忽略大小写ignore。</p><p>g：表示全局匹配，查找所有匹配而非在找到第一个匹配后停止 global。</p><p>第二种方式：</p><pre><code class="js">var reg = /study/ig;</code></pre><ul><li><h4 id="3：正则对象方法"><a href="#3：正则对象方法" class="headerlink" title="3：正则对象方法"></a>3：正则对象方法</h4></li></ul><p>test： 正则实例对象的<code>test</code>方法返回一个布尔值，表示当前模式是否能匹配参数字符串</p><pre><code>/cat/.test(&#39;cats and dogs&#39;) // true</code></pre><p>上面代码验证参数字符串之中是否包含<code>cat</code>，结果返回<code>true</code>。</p><p>如果正则表达式带有<code>g</code>修饰符，则每一次<code>test</code>方法都从上一次结束的位置开始向后匹配</p><pre><code class="js">var r = /x/g;var s = &#39;x_x&#39;;r.lastIndex // 0r.test(s) // truer.lastIndex // 2r.test(s) // truer.lastIndex // 4r.test(s) // false</code></pre><p>上面代码的正则表达式使用了<code>g</code>修饰符，表示是全局搜索，会有多个结果。接着，三次使用<code>test</code>方法，每一次开始搜索的位置都是上一次匹配的后一个位置。</p><p>带有<code>g</code>修饰符时，可以通过正则对象的<code>lastIndex</code>属性指定开始搜索的位置</p><pre><code class="js">var r = /x/g;var s = &#39;x_x&#39;;r.lastIndex = 4;r.test(s) // false</code></pre><p>上面代码指定从字符串的第五个位置开始搜索，这个位置是没有字符的，所以返回<code>false</code>。</p><p>exec：用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为null。</p><pre><code class="js">var s = &#39;x_x&#39;;var r1 = /x/;var r2 = /y/;r1.exec(s) // [&quot;x&quot;]r2.exec(s) // null</code></pre><p>上面代码中，正则对象<code>r1</code>匹配成功，返回一个数组，成员是匹配结果；正则对象<code>r2</code>匹配失败，返回<code>null</code>。</p><ul><li><h4 id="4：字符串函数"><a href="#4：字符串函数" class="headerlink" title="4：字符串函数"></a>4：字符串函数</h4></li></ul><p>replace： 按照给定的正则表达式进行替换，返回替换后的字符串。</p><p>​        字符串对象的<code>replace</code>方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。</p><pre><code class="js">str.replace(search, replacement)</code></pre><p>正则表达式如果不加<code>g</code>修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。</p><pre><code class="js">&#39;aaa&#39;.replace(&#39;a&#39;, &#39;b&#39;) // &quot;baa&quot;&#39;aaa&#39;.replace(/a/, &#39;b&#39;) // &quot;baa&quot;&#39;aaa&#39;.replace(/a/g, &#39;b&#39;) // &quot;bbb&quot;//上面代码中，最后一个正则表达式使用了g修饰符，导致所有的b都被替换掉了。</code></pre><p>match： 字符串实例对象的<code>match</code>方法对字符串进行正则匹配，返回匹配结果。</p><pre><code class="js">var s = &#39;_x_x&#39;;var r1 = /x/;var r2 = /y/;s.match(r1) //[&quot;x&quot;]s.match(r2) // null//从上面代码可以看到，字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回null。</code></pre><p>如果正则表达式带有<code>g</code>修饰符，则该方法与正则对象的<code>exec</code>方法行为不同，会一次性返回所有匹配成功的结果</p><pre><code class="js">var s = &#39;abba&#39;;var r = /a/g;s.match(r) // [&quot;a&quot;, &quot;a&quot;]r.exec(s) // [&quot;a&quot;]</code></pre><p>search：检索与正则表达式相匹配的值。返回字符串中第一个与正则表达式相匹配的子串的起始位置。如果没有找到则返回-1。</p><pre><code class="js">&#39;_x_x&#39;.search(/x/)// 1//上面代码中，第一个匹配结果出现在字符串的1号位置。</code></pre><ul><li><h4 id="5：正则表达式构成"><a href="#5：正则表达式构成" class="headerlink" title="5：正则表达式构成"></a>5：正则表达式构成</h4></li></ul><p>大部分字符在正则表达式中，就是字面的含义，比如<code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的<code>a</code>和<code>b</code>），那么它们就叫做“字面量字符”。</p><pre><code class="js">/dog/.test(&#39;old dog&#39;) // true</code></pre><p>上面代码中正则表达式的<code>dog</code>，就是字面量字符，所以<code>/dog/</code>匹配<code>old dog</code>，因为它就表示<code>d</code>、<code>o</code>、<code>g</code>三个字母连在一起。</p><p>除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”，主要有以下几个</p><p>正则表达式是由普通字符（例如字符a到z）以及特殊字符（称为元字符）组成的文字模式。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p><p>元字符—限定符：</p><p>限定符可以指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。</p><ul><li>​            *：匹配前面的子表达式零次或多次。</li><li>​            +：匹配前面的子表达式一次或多次。</li><li>​            ？：匹配前面的子表达式零次或一次。</li><li>​            {n}：匹配确定n次。</li><li>​            {n,}：至少匹配n次。</li><li>​            {n, m}：最少匹配n次且最多匹配m次。</li></ul><pre><code class="js">// t 出现0次或1次/t?est/.test(&#39;test&#39;) // true/t?est/.test(&#39;est&#39;) // true// t 出现1次或多次/t+est/.test(&#39;test&#39;) // true/t+est/.test(&#39;ttest&#39;) // true/t+est/.test(&#39;est&#39;) // false// t 出现0次或多次/test/t*est(&#39;test&#39;) // true/t*est/.test(&#39;ttest&#39;) // true/t*est/.test(&#39;tttest&#39;) // true/t*est/.test(&#39;est&#39;) // true/lo{2}k/.test(&#39;look&#39;) // true/lo{2,5}k/.test(&#39;looook&#39;) // true//上面代码中，第一个模式指定o连续出现2次，第二个模式指定o连续出现2次到5次之间</code></pre><p>元字符—字符匹配符：</p><p>字符匹配符用于匹配某个或某些字符。</p><p>[xyz]：字符集合。匹配所包含的任意一个字符。</p><pre><code class="js">/[abc]/.test(&#39;hello world&#39;) // false/[abc]/.test(&#39;apple&#39;) // true//上面代码中，字符串hello world不包含a、b、c这三个字母中的任一个，所以返回false；字符串apple包含字母a，所以返回true</code></pre><p>[^xyz]： 表示除了<code>x</code>、<code>y</code>、<code>z</code>之外都可以匹配。</p><pre><code class="js">/abc/.test(&#39;hello world&#39;) // true/abc/.test(&#39;bbc&#39;) // false//上面代码中，字符串hello world不包含字母a、b、c中的任一个，所以返回true；字符串bbc不包含a、b、c以外的字母，所以返回false。</code></pre><p>[a-z]：字符范围。匹配指定范围内的任意字符。</p><p><code>[abc]</code>可以写成<code>[a-c]</code>，<code>[0123456789]</code>可以写成<code>[0-9]</code>，同理<code>[A-Z]</code>表示26个大写字母。</p><pre><code class="js">/[a-z]/.test(&#39;b&#39;) // true</code></pre><p>这样也可以：[0-9]、[0-9a-z]、[0-9a-zA-Z]</p><p>[0-9a-zA-Z]  表示数字0-9，大小字母</p><p>[^a-z]：表示不包含小写字母。</p><blockquote><p>\d 匹配0-9之间的任一数字，相当于[0-9]。</p></blockquote><blockquote><p>\D 匹配所有0-9以外的字符，相当于[^0-9]。</p></blockquote><blockquote><p>\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。</p></blockquote><blockquote><p>\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。 </p></blockquote><blockquote><p>\s 匹配空格（包括换行符、制表符、空格符等）。 </p></blockquote><blockquote><p>\S 匹配非空格的字符。</p></blockquote><blockquote><p>.：匹配除”\n”之外的任何单个字符。</p></blockquote><p>元字符—定位符：</p><p>定位符可以将一个正则表达式固定在一行的开始或结束。也可以创建只在单词内或只在单词的开始或结尾处出现的正则表达式。</p><p>^：匹配输入字符串的开始位置。</p><p>$：匹配输入字符串的结束位置。</p><pre><code class="js">// test必须出现在开始位置/^test/.test(&#39;test123&#39;) // true// test必须出现在结束位置/test$/.test(&#39;new test&#39;) // true// 从开始位置到结束位置只有test/^test/.test(&#39;test&#39;) // true/^test/.test(&#39;test test&#39;) // false</code></pre><p>元字符—转义符：</p><p>\：用于匹配某些特殊字符。</p><p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配<code>+</code>，就要写成<code>\+</code>。</p><pre><code class="js">/1+1/.test(&#39;1+1&#39;)// false/1+1/.test(&#39;1+1&#39;)// true//上面代码中，第一个正则表达式之所以不匹配，因为加号是元字符，不代表自身。第二个正则表达式使用反斜杠对加号转义，就能匹配成功。</code></pre><p>元字符—选择匹配符：</p><p><code>|</code>：可以匹配多个规则。竖线符号（<code>|</code>）在正则表达式中表示“或关系”（OR），即<code>cat|dog</code>表示匹配<code>cat</code>或<code>dog</code>。</p><pre><code class="js">/11|22/.test(&#39;911&#39;) // true//上面代码中，正则表达式指定必须匹配11或22// 匹配fred、barney、betty之中的一个/fred|barney|betty/</code></pre><p>应用：</p><ol><li>掌握正则的创建方式。</li><li>掌握正则表达式的语言。</li></ol><p>常用正则</p><blockquote><p>邮政编码检测</p></blockquote><pre><code class="js">/^\d{6}$/</code></pre><blockquote><p>文件格式监测</p></blockquote><pre><code class="js">/^.+.(jpeg|png|gif|jpg)$/</code></pre><blockquote><p>字符串首尾去空格。</p></blockquote><pre><code class="js">var str = &#39;      avaasdf &#39;;var reg = /^\s+|\s+$/g;        console.log(str.replace(reg,&#39;&#39;))</code></pre><blockquote><p>邮件格式监测。</p></blockquote><pre><code class="js">/^\w+[-+.]\w@([a-z0-9A-Z\u2E80-\u9FFF]-?)+(.\w{2,6})+/</code></pre><blockquote><p>手机号监测</p></blockquote><pre><code class="js">/^(13[0-9]|14[0-9]|15[0-9]|18[0-9]|17[0-9])\d{8}$/</code></pre><blockquote><p>身份证监测</p></blockquote><pre><code class="js">/(^\d{15}|^\d{18})|^\d{17}X$/</code></pre><blockquote><p>中文监测</p><p>unicode编码中文监测</p></blockquote><pre><code class="js">/^[\u2E80-\u9FFF]+$/</code></pre><blockquote><p>用户名监测（规则数字字母下划线-组成，3-16位）</p></blockquote><pre><code class="js">/^[a-z0-9_-]{3,16}$/</code></pre><h4 id="正则分组"><a href="#正则分组" class="headerlink" title="正则分组"></a>正则分组</h4><pre><code class="js">//1-什么是分组var reg = /(\d{2})/reg.test(&#39;12&#39;);  //true// 这里reg中的(/d{2})就表示一个分组，匹配两位数字/*/hahaha//(ha){3}/这两个表达式是等效的，但有了分组之后可以更急简洁*///2- 捕获型 分组 ()// 被正则表达式捕获(匹配)到的字符串会被暂存起来，其中，由分组捕获到的字符串会从1开始编号，于是我们可以引用这些字符串：var reg = /(\d{4})-(\d{2})-(\d{2})/;var dateStr = &#39;2018-04-18&#39;;reg.test(dateStr);  //true//引用捕获到的内容使用 $1 代表第一个分组的捕获到的内容RegExp.$1   //2018RegExp.$2   //04RegExp.$3   //18// 3-非捕获型 (?:)// 有的时候只是为了分组并不需要捕获的情况下就可以使用非捕获型分组var reg = /(?:\d{4})-(\d{2})-(\d{2})/var date = &#39;2012-12-21&#39;reg.test(date)RegExp.$1 // 12RegExp.$2 // 21// 4- 结合replace方法做字符串自定义替换var dateStr = &#39;2018/04/18&#39;;var reg = /(\d{4})\/(\d{2})\/(\d{2})/;dateStr = dateStr.replace(reg, &#39;$1-$2-$3&#39;) //&quot;2018-04-18&quot;//不过这里需要注意的是/是需要用\转义的// 5- 结合正则exec方法来使用//通俗来说，分组就是在正则表达式中用（）包起来的内容代表了一个分组        var s;        var re = new RegExp(&quot;d(b+)(d)&quot;, &quot;ig&quot;);        var str = &quot;cdbBdbsbdbdz&quot;;        var arr = re.exec(str);        console.log(arr)/*0: &quot;dbBd&quot;  正则整体匹配到的字符1: &quot;bB&quot;    第一个小括号(分组)匹配到的字符2: &quot;d&quot;     第二个小括号（分组）匹配到的字符*/    //  第一个分组的结果也可以用 RegExp.$1   获取        s = &quot;$1 contains: &quot; + RegExp.$1 + &quot;\n&quot;;        s += &quot;$2 contains: &quot; + RegExp.$2 + &quot;\n&quot;;        console.log(s)// 6- 结合字符串match方法使用        var str = &quot;http://www.taobao.com:80/cuxiao/hongbao.html&quot;;        var patt1 = /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/;        arr = str.match(patt1);        console.log(arr);/*0: &quot;http://www.taobao.com:80/cuxiao/hongbao.html&quot;  整个正则匹配到的字符串1: &quot;http&quot;     第一个分组 匹配到的字符串2: &quot;www.taobao.com&quot;   第二个分组 匹配到的字符串3: &quot;:80&quot;      第三个分组 匹配到的字符串4: &quot;/cuxiao/hongbao.html&quot;   第四个分组 匹配到的字符串*/        //第一个分组的结果也可以用 RegExp.$1   获取        console.log(RegExp.$1)//http//把url参数转对象        var parseQuery = function (query) {            var reg = /([^=&amp;\s]+)[=\s]*([^&amp;\s]*)/g;            var obj = {};            while (reg.exec(query)) {                obj[RegExp.$1] = RegExp.$2;            }            console.log(obj)            return obj;        }parseQuery(&quot;userID=JeoOrCXxyiOFxbYaGL40kw&amp;userPwd=sdFo2ziUw8HyLRKd4i6GAQ&amp;userName=aa&quot;)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;1：正则的概念&quot;&gt;&lt;a href=&quot;#1：正则的概念&quot; class=&quot;headerlink&quot; title=&quot;1：正则的概念&quot;&gt;&lt;/a&gt;1：正则的概念&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;正则表达式(regular ex
      
    
    </summary>
    
    
      <category term="前端" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Js" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/Js/"/>
    
    
      <category term="Js" scheme="http://1512034032.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="http://1512034032.github.io/2019/11/11/string/"/>
    <id>http://1512034032.github.io/2019/11/11/string/</id>
    <published>2019-11-11T01:43:27.645Z</published>
    <updated>2019-11-11T01:28:53.878Z</updated>
    
    <content type="html"><![CDATA[<p>字符串：</p><pre><code>//创建 属性 方法:            //字面量            var username = &#39;zhangsan&#39;            //es6 模板字符串  中间可以使用${变量}            let str = `            afa            asdfa            姓名是${username},年龄是${age}            `;            //字符串对象  包装对象 像数组  伪数组            let str2 = new String(&#39;aadsd&#39;)//方法:            charAt//下标            slice//复制(取出)            substring//复制(取出)            substr//复制(取出)            indexOf,lastIndexOf//查找下标            trim//去除空格            toLowerCase//大小写            replace//替换            split//分割</code></pre><h6 id="字符串的创建"><a href="#字符串的创建" class="headerlink" title="字符串的创建"></a>字符串的创建</h6><pre><code class="js">字符串的创建方式var s1 = &#39;abc&#39;;var s2 = new String(&#39;abc&#39;);typeof s1 // &quot;string&quot;typeof s2 // &quot;object&quot;所以,String对象也叫包装对象除了用作构造函数，String对象还可以当作工具方法使用，将任意类型的值转为字符串。String(true) // &quot;true&quot;String(5) // &quot;5&quot;上面代码将布尔值ture和数值5，分别转换为字符串var a=&#39;abc&#39;;//字面量字符串var b=``;字符串实例的length属性返回字符串的长度。&#39;abc&#39;.length // 3字符串对象是一个类似数组的对象（很像数组，但不是数组）。new String(&#39;abc&#39;)// String {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3}(new String(&#39;abc&#39;))[1] // &quot;b&quot;上面代码中，字符串abc对应的字符串对象，有数值键（0、1、2）和length属性，所以可以像数组那样取值。</code></pre><h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h4><h6 id="charAt下标"><a href="#charAt下标" class="headerlink" title="charAt下标"></a>charAt下标</h6><pre><code class="js">charAt方法返回指定位置的字符，参数是从0开始编号的位置。var s = new String(&#39;abc&#39;);这个方法完全可以用数组下标替代。&#39;abc&#39;.charAt(1) // &quot;b&quot;&#39;abc&#39;[1] // &quot;b&quot;</code></pre><h6 id="slice复制1"><a href="#slice复制1" class="headerlink" title="slice复制1"></a>slice复制1</h6><pre><code class="js">slice方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。&#39;JavaScript&#39;.slice(0, 4) // &quot;Java&quot;如果省略第二个参数，则表示子字符串一直到原字符串结束。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。如果第一个参数大于第二个参数，slice方法返回一个空字符串。 </code></pre><h6 id="substring复制2"><a href="#substring复制2" class="headerlink" title="substring复制2"></a>substring复制2</h6><pre><code class="js">substring方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。如果省略第二个参数，则表示子字符串一直到原字符串的结束。如果第二个参数大于第一个参数，substring方法会自动更换两个参数的位置。&#39;JavaScript&#39;.substring(10, 4) // &quot;Script&quot;// 等同于&#39;JavaScript&#39;.substring(4, 10) // &quot;Script&quot;</code></pre><h6 id="substr复制3"><a href="#substr复制3" class="headerlink" title="substr复制3"></a>substr复制3</h6><pre><code>substr方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice和substring方法的作用相同。substr方法的第一个参数是子字符串的开始位置（从0开始计算），第二个参数是子字符串的长度。如果省略第二个参数，则表示子字符串一直到原字符串的结束。&#39;JavaScript&#39;.substr(4) // &quot;Script&quot;如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。&#39;JavaScript&#39;.substr(-6) // &quot;Script&quot;</code></pre><h6 id="indexOf-lastIndexOf查找下标"><a href="#indexOf-lastIndexOf查找下标" class="headerlink" title="indexOf,lastIndexOf查找下标"></a>indexOf,lastIndexOf查找下标</h6><pre><code class="js">indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。&#39;hello world&#39;.indexOf(&#39;o&#39;) // 4&#39;JavaScript&#39;.indexOf(&#39;script&#39;) // -1indexOf方法还可以接受第二个参数，表示从该位置开始向后匹配。&#39;hello world&#39;.indexOf(&#39;o&#39;, 6) // 7lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。&#39;hello world&#39;.lastIndexOf(&#39;o&#39;) // 7另外，lastIndexOf的第二个参数表示从该位置起向前匹配。&#39;hello world&#39;.lastIndexOf(&#39;o&#39;, 6) // 4</code></pre><h6 id="trim去除空格"><a href="#trim去除空格" class="headerlink" title="trim去除空格"></a>trim去除空格</h6><pre><code class="js">trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。&#39;  hello world  &#39;.trim()// &quot;hello world&quot;该方法去除的不仅是空格，还包括制表符（\t、\v）、换行符（\n）和回车符（\r）。&#39;\r\nabc \t&#39;.trim() // &#39;abc&#39;</code></pre><h6 id="toLowerCase-toUpperCase大小写"><a href="#toLowerCase-toUpperCase大小写" class="headerlink" title="toLowerCase,toUpperCase大小写"></a>toLowerCase,toUpperCase大小写</h6><pre><code class="js">toLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。它们都返回一个新字符串，不改变原字符串。&#39;Hello World&#39;.toLowerCase()// &quot;hello world&quot;&#39;Hello World&#39;.toUpperCase()// &quot;HELLO WORLD&quot;</code></pre><h6 id="replace替换"><a href="#replace替换" class="headerlink" title="replace替换"></a>replace替换</h6><pre><code class="js">replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。&#39;aaa&#39;.replace(&#39;a&#39;, &#39;b&#39;) // &quot;baa&quot;&#39;aaa&#39;.replace(/a/g, &#39;b&#39;) // &quot;bbb&quot;</code></pre><h6 id="split分割"><a href="#split分割" class="headerlink" title="split分割"></a>split分割</h6><pre><code class="js">split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。&#39;a|b|c&#39;.split(&#39;|&#39;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。&#39;a|b|c&#39;.split(&#39;&#39;) // [&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;]//注：数组join可将数组转为字符串split，join可互换</code></pre><h6 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h6><pre><code class="js">ASCII码和字符集字符串常见API(charCodeAt\fromCharCode)charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。&#39;abc&#39;.charCodeAt(1) // 98上面代码中，abc的1号位置的字符是b，它的 Unicode 码点是98。String.fromCharCode()String对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。String.fromCharCode() // &quot;&quot;String.fromCharCode(97) // &quot;a&quot;String.fromCharCode(104, 101, 108, 108, 111)// &quot;hello&quot;统计字符串中每个字符的个数</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//创建 属性 方法:
            //字面量
            var username = &amp;#39;zhangsan&amp;#39;
            //es6 模板字符串  中间可以使用${变量}
    
      
    
    </summary>
    
    
      <category term="前端" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Js" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/Js/"/>
    
    
      <category term="Js" scheme="http://1512034032.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://1512034032.github.io/2019/11/11/array/"/>
    <id>http://1512034032.github.io/2019/11/11/array/</id>
    <published>2019-11-11T01:43:27.641Z</published>
    <updated>2019-11-11T01:37:32.097Z</updated>
    
    <content type="html"><![CDATA[<h6 id="1-数组的概念"><a href="#1-数组的概念" class="headerlink" title="1- 数组的概念"></a>1- 数组的概念</h6><pre><code class="javascript">数组的概念：所谓数组，是有序的元素序列。（一组有序 数据）JavaScript的Array可以包含任意数据类型。注：一般来说数组中元素的类型相同数组的创建方式1-字面量var arr = [1, 2];//数组中有两个元素arr.length ;//获取数组的长度arr[i]//获取数组中的第i个元素，i称为数组的下标或者索引，下标从0开始arr[0]//获取数组中的第一个元素arr[0] = 100;//修改数组中第一个元素的值为100</code></pre><h6 id="2-构造函数方式创建数组"><a href="#2-构造函数方式创建数组" class="headerlink" title="2- 构造函数方式创建数组"></a>2- 构造函数方式创建数组</h6><pre><code class="javascript">Array是一个构造函数，可以用它生成新的数组var arr = new Array(2);arr.length // 2arr[0]//undefined上面代码中，Array构造函数的参数2，表示生成一个两个成员的数组。 Array构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。// 单个非数值（比如字符串、布尔值、对象等）作为参数，// 则该参数是返回的新数组的成员new Array(&#39;abc&#39;) // [&#39;abc&#39;]// 多参数时，所有参数都是返回的新数组的成员new Array(1, 2) // [1, 2]new Array(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]可以看到，Array作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。</code></pre><h4 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h4><pre><code class="javascript">数组的操作//push/pop/unshift/shift</code></pre><h6 id="push-pop-末增-删"><a href="#push-pop-末增-删" class="headerlink" title="push/pop(末增/删)"></a>push/pop(末增/删)</h6><pre><code class="javascript">push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组var arr = [];arr.push(1)         // 1arr.push(&#39;a&#39;)        // 2arr.push(true, {})    // 4arr        // [1, &#39;a&#39;, true, {}]pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];arr.pop() // &#39;c&#39;arr // [&#39;a&#39;, &#39;b&#39;]对空数组使用pop方法，不会报错，而是返回undefined。push和pop结合使用，就构成了“后进先出”的栈结构（stack）。var arr = [];arr.push(1, 2);arr.push(3);//1,2,3arr.pop();arr // [1, 2]上面代码中，3是最后进入数组的，但是最早离开数组。</code></pre><h6 id="concat合并"><a href="#concat合并" class="headerlink" title="concat合并"></a>concat合并</h6><pre><code class="js">concat  合并数组(不改变原数组)var arr2=[1,3];var arr3=[2,4];arr2.concat(arr3);//arr2不变，arr3变成1,2,3,4</code></pre><h6 id="shift-unshift-首增-删"><a href="#shift-unshift-首增-删" class="headerlink" title="shift/unshift(首增/删)"></a>shift/unshift(首增/删)</h6><pre><code class="javascript">shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];a.shift() // &#39;a&#39;a // [&#39;b&#39;, &#39;c&#39;]push和shift结合使用，就构成了“先进先出”的队列结构（queue）。unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];a.unshift(&#39;x&#39;); // 4a // [&#39;x&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre><h6 id="slice复制"><a href="#slice复制" class="headerlink" title="slice复制"></a>slice复制</h6><pre><code class="javascript">slice方法用于复制目标数组的一部分，返回一个新数组，原数组不变。arr.slice(start, end);它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];a.slice(0) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]a.slice(1) // [&quot;b&quot;, &quot;c&quot;]a.slice(1, 2) // [&quot;b&quot;]a.slice(2, 6) // [&quot;c&quot;]a.slice() // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]//上面代码中，最后一个例子slice没有参数，实际上等于返回一个原数组的拷贝。如果slice方法的参数是负数，则表示倒数计算的位置。var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];a.slice(-2) // [&quot;b&quot;, &quot;c&quot;]a.slice(-2, -1) // [&quot;b&quot;]//上面代码中，-2表示倒数计算的第二个位置，-1表示倒数计算的第一个位置。如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];a.slice(4) // []a.slice(2, 1) // []如果slice方法的参数是负数，则表示倒数计算的位置。var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];a.slice(-2) // [&quot;b&quot;, &quot;c&quot;]a.slice(-2, -1) // [&quot;b&quot;]//上面代码中，-2表示倒数计算的第二个位置，-1表示倒数计算的第一个位置。如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];a.slice(4) // []a.slice(2, 1) // []</code></pre><h6 id="splice删除"><a href="#splice删除" class="headerlink" title="splice删除"></a>splice删除</h6><pre><code class="javascript">var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;];a.splice(-4, 2) // [&quot;c&quot;, &quot;d&quot;]//上面代码表示，从倒数第四个位置c开始删除两个成员。如果只是单纯地插入元素，splice方法的第二个参数可以设为0。var a = [1, 1, 1];a.splice(1, 0, 2) // []  在 删除位置的前面添加了a // [1, 2, 1, 1]如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。var a = [1, 2, 3, 4];a.splice(2) // [3, 4]a // [1, 2]</code></pre><h6 id="reverse-sort颠倒-排序"><a href="#reverse-sort颠倒-排序" class="headerlink" title="reverse/sort颠倒/排序"></a>reverse/sort颠倒/排序</h6><pre><code class="javascript">reverse方法用于颠倒排列数组元素，返回改变后的数组(还是原数组)。注意，该方法将改变原数组。var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];a.reverse() // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]a // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;].sort();// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;][4, 3, 2, 1].sort();// [1, 2, 3, 4][11, 101].sort();// [101, 11][10111, 1101, 111].sort();// [10111, 1101, 111]//上面代码的最后两个例子，需要特殊注意。sort方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。[10111, 1101, 111].sort(function (a, b) {  return a - b;//升序})// [111, 1101, 10111]//上面代码中，sort的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面</code></pre><h6 id="join分隔符"><a href="#join分隔符" class="headerlink" title="join分隔符"></a>join分隔符</h6><pre><code class="javascript">//join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。var a = [1, 2, 3, 4];a.join(&#39; &#39;) // &#39;1 2 3 4&#39;a.join(&#39; | &#39;) // &quot;1 | 2 | 3 | 4&quot;a.join() // &quot;1,2,3,4&quot;//如果数组成员是undefined或null或空位，会被转成空字符串。[undefined, null].join(&#39;#&#39;)// &#39;#&#39;[&#39;a&#39;,, &#39;b&#39;].join(&#39;-&#39;)// &#39;a--b&#39;</code></pre><h4 id="ES5数组新增方法"><a href="#ES5数组新增方法" class="headerlink" title="ES5数组新增方法"></a>ES5数组新增方法</h4><h6 id="静态方法isArray"><a href="#静态方法isArray" class="headerlink" title="静态方法isArray"></a>静态方法isArray</h6><pre><code class="javascript">静态方法Array.isArray()Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足。var arr = [1, 2, 3];typeof arr // &quot;object&quot;Array.isArray(arr) // true上面代码中，typeof运算符只能显示数组的类型是Object，而Array.isArray方法可以识别数组。</code></pre><h6 id="for-in遍历"><a href="#for-in遍历" class="headerlink" title="for in遍历"></a>for in遍历</h6><h6 id="map方法-遍历"><a href="#map方法-遍历" class="headerlink" title="map方法-遍历"></a>map方法-遍历</h6><pre><code class="js">map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身。[1, 2, 3].map(function(elem, index, arr) {  return elem * index;});// [0, 2, 6]上面代码中，map方法的回调函数有三个参数，elem为当前成员的值，index为当前成员的位置，arr为原数组（[1, 2, 3]）</code></pre><h6 id="forEach-遍历"><a href="#forEach-遍历" class="headerlink" title="forEach-遍历"></a>forEach-遍历</h6><pre><code class="js">//forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。forEach的用法与map方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。function log(element, index, array) {  console.log(&#39;[&#39; + index + &#39;] = &#39; + element);}[2, 5, 9].forEach(log);// [0] = 2// [1] = 5// [2] = 9//注意，forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。var arr = [1, 2, 3];for (var i = 0; i &lt; arr.length; i++) {  if (arr[i] === 2) break;  console.log(arr[i]);}</code></pre><h6 id="filter过滤"><a href="#filter过滤" class="headerlink" title="filter过滤"></a>filter过滤</h6><pre><code class="js">filter()filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。filter方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。var res = [1, 2, 3, 4, 5].filter(function (elem, index, arr) {  return index % 2 === 0;});res// [1, 3, 5]上面代码返回偶数位置的成员组成的新数组。</code></pre><h6 id="reduce依次处理数组成员"><a href="#reduce依次处理数组成员" class="headerlink" title="reduce依次处理数组成员"></a>reduce依次处理数组成员</h6><pre><code class="js">reduce方法依次处理数组的每个成员，最终累计为一个值。reduce是从左到右处理（从第一个成员到最后一个成员）reduce方法参数是一个函数,该函数接受以下两个参数。1累积变量，默认为数组的第一个成员2当前变量，默认为数组的第二个成员var res = [1, 2, 3, 4, 5].reduce(function (a, b) {  console.log(a, b);  return a + b;})// 1 2// 3 3// 6 4// 10 5res//最后结果：15上面代码中，reduce方法求出数组所有成员的和。第一次执行，a是数组的第一个成员1，b是数组的第二个成员2。第二次执行，a为上一轮的返回值3，b为第三个成员3。第三次执行，a为上一轮的返回值6，b为第四个成员4。第四次执行，a为上一轮返回值10，b为第五个成员5。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值15。</code></pre><h6 id="indexOf-lastIndexOf"><a href="#indexOf-lastIndexOf" class="headerlink" title="indexOf(),lastIndexOf()"></a>indexOf(),lastIndexOf()</h6><pre><code class="js">//indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];a.indexOf(&#39;b&#39;) // 1a.indexOf(&#39;y&#39;) // -1//indexOf方法还可以接受第二个参数，表示搜索的开始位置。[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].indexOf(&#39;a&#39;, 1) // -1//上面代码从1号位置开始搜索字符a，结果为-1，表示没有搜索到。------------------------------------------lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。var a = [2, 5, 9, 2];a.lastIndexOf(2) // 3a.lastIndexOf(7) // -1注意，这两个方法不能用来搜索NaN的位置，即它们无法确定数组成员是否包含NaN。[NaN].indexOf(NaN) // -1[NaN].lastIndexOf(NaN) // -1这是因为这两个方法内部，使用严格相等运算符（===）进行比较，而NaN是唯一一个不等于自身的值</code></pre><h4 id="数组小总结"><a href="#数组小总结" class="headerlink" title="数组小总结"></a>数组小总结</h4><pre><code class="javascript">数组：储存一组有序的数据数组的作用：一次性储存多个数据数组的定义方式： 1.构造函数定义数组：var 数组名 = new Array(); 2.字面量方式定义数组：var 数组名 = [];var 数组名=new Array();//空数组var 数组名=new Array(值);//数组定义了，有长度var 数组名=new Array(值1，值2，值3...);//数组定义并且有多个数据var 数组名=[];//空数组var 数组名=[值1，值2，值3]；//有三个数据数组元素：就是数组中储存的数据数组长度：就是数组中元素的个数数组索引(下标)：从0开始，到数组的长度减1结束通过下标设置数组的元素值：数组名[索引]=值通过下标访问数组的元素值：数组名[索引]var arr1=new Array();//空数组var arr2=new Array(5);//数组的长度为5var arr3=new Array(1,2,3,4,5);//数组长度为5，并且有5个值var arr4=[];//空数组var arr5=[1,2,3]//三个值var arr6=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,1,true];//数组内的值的类型可以不一样var arr7=[];//设置数组元素的值arr7[0]=10;arr7[1]=20;方法：push//数组尾部新增pop//数组尾部删除unshift//数组头部新增shift//数组头部删除slice//复制数组中的一部分splice//删除数组中的一部分reverse//颠倒数组sort//排序join//设置链接符号--分隔符，链接数组元素返回字符串isArray//静态方法 判断数组map//遍历数组进行传值--有返回值forEach//遍历数组进行传值--无返回值filter//过滤reduce//依次处理数组元素indexOf,lastIndexOf//查找下标</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;1-数组的概念&quot;&gt;&lt;a href=&quot;#1-数组的概念&quot; class=&quot;headerlink&quot; title=&quot;1- 数组的概念&quot;&gt;&lt;/a&gt;1- 数组的概念&lt;/h6&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;数组的概念：
所谓数组，是有序的元素序列。
      
    
    </summary>
    
    
      <category term="前端" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Js" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/Js/"/>
    
    
      <category term="Js" scheme="http://1512034032.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>websocket</title>
    <link href="http://1512034032.github.io/2019/11/08/websocket/"/>
    <id>http://1512034032.github.io/2019/11/08/websocket/</id>
    <published>2019-11-08T12:13:25.571Z</published>
    <updated>2019-11-09T11:48:11.465Z</updated>
    
    <content type="html"><![CDATA[<p>网络上的两个程序通过一个双向的通信链接实现数据的交换，这个链接的一端称为一个socket。<br>WebSocket是html5新增加的一种双工通信协议，目前流行的浏览器都支持这个协议</p><p>new WebSocket(“ws://echo.websocket.org”);<br>申请一个WebSocket对象，参数是需要连接的服务器端的地址，默认本机地址</p><blockquote><p>WebSocket对象一共支持四个消息 onopen, onmessage, onclose和onerror。当Browser和WebSocketServer连接成功后，会触发onopen消息；如果连接失败，发送、接收数据失败或者处理数据出现错误，browser会触发onerror消息；当Browser接收到WebSocketServer发送过来的数据时，就会触发onmessage消息，参数evt中包含server传输过来的数据；当Browser接收到WebSocketServer端发送的关闭连接请求时，就会触发onclose消息。我们可以看出所有的操作都是采用消息的方式触发的，这样就不会阻塞UI，使得UI有更快的响应时间，得到更好的用户体验。</p></blockquote><p>先创建服务端 server.js</p><pre><code>var ws =require(&#39;ws&#39;).Server;//引入 Websocket 依赖var server = new ws({port:3000});//初始化创建 Websocket 服务器var obj = {};var i=0;server.on(&#39;connection&#39;,(client)=&gt;{ //监听客户端的请求，client 为客户端    client.name = ++i;    obj[client.name]=client;    client.on(&#39;message&#39;,(data)=&gt;{ // data 为收到的客户端信息        console.log(&#39;接受客户端：&#39;+data)        huifu(client,data) // 收到客户端的信息请求后给予回复 ↓↓↓    })})function huifu(client,message){    for(let i in obj){        obj[i].send(client.name+&quot;说：&quot;+message)    }}</code></pre><p>客户端 index.html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        *{margin: 0;padding: 0;}        #out{width: 500px;height: 500px;border: 1px solid #000;overflow: auto;}    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;o    &lt;h2&gt;聊天室&lt;/h2&gt;    &lt;div id=&quot;out&quot;&gt;&lt;/div&gt;    &lt;input type=&quot;text&quot; id=&quot;ipt&quot;&gt;    &lt;button id=&quot;btn&quot;&gt;发送&lt;/button&gt;    &lt;script&gt;        var client = new WebSocket(&#39;ws:localhost:3000&#39;)//链接本机通讯服务器        client.onopen = function(){            console.log(&#39;success&#39;)        }        client.onerror = function(){            console.log(&#39;success&#39;)        }        client.onmessage = function(e){            out.innerHTML+=&#39;&lt;p&gt;&#39;+e.data+&#39;&lt;/p&gt;&#39;        }        client.onclose = function(){            console.log(&#39;close&#39;)        }        btn.onclick = function(){            client.send(ipt.value)        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>终端运行服务端</p><pre><code>node server.js</code></pre><p>打开两个客户端页面进行通讯</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网络上的两个程序通过一个双向的通信链接实现数据的交换，这个链接的一端称为一个socket。&lt;br&gt;WebSocket是html5新增加的一种双工通信协议，目前流行的浏览器都支持这个协议&lt;/p&gt;
&lt;p&gt;new WebSocket(“ws://echo.websocket.or
      
    
    </summary>
    
    
      <category term="Node" scheme="http://1512034032.github.io/categories/Node/"/>
    
    
      <category term="websocket" scheme="http://1512034032.github.io/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>express-session</title>
    <link href="http://1512034032.github.io/2019/11/08/express-session/"/>
    <id>http://1512034032.github.io/2019/11/08/express-session/</id>
    <published>2019-11-08T12:13:25.563Z</published>
    <updated>2019-11-09T11:47:22.986Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p></blockquote><p>安装依赖</p><pre><code>npm install express-session -gnpm install express-session -D// express装载express-sessionapp.use(session({     secret: &#39;recommend 128 bytes random string&#39;,    cookie: { maxAge: 20 * 60 * 1000 },    resave: true,    saveUnintialized: true}))</code></pre><p>在 session 中存入需要的数据</p><pre><code>var session = require(&#39;express-session&#39;)// 在方法中使用router.get(&#39;/&#39;,(req,res)=&gt;{// 存入    req.session.username = req.body.username // username// 使用    let a = req.session.username;//销毁session//1.    req.session.username = undefined;//2.    2)req.session.destroy(function(err){        if(err){            console.log(err)        }else{            res.redirect(&quot;/&quot;)        }    })})</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装依赖&lt;/p&gt;
&lt;pre&gt;&lt;co
      
    
    </summary>
    
    
      <category term="Node" scheme="http://1512034032.github.io/categories/Node/"/>
    
    
      <category term="Node" scheme="http://1512034032.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>状态码</title>
    <link href="http://1512034032.github.io/2019/11/08/code/"/>
    <id>http://1512034032.github.io/2019/11/08/code/</id>
    <published>2019-11-08T11:05:13.155Z</published>
    <updated>2019-11-08T11:04:58.309Z</updated>
    
    <content type="html"><![CDATA[<p>状态码<br>字段名称为：code<br>200 OK [GET] 服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）<br>201 CREATED [POST/PUT/PATCH] 用户新建或修改数据成功<br>202 ACCEPTED [<em>] 表示一个请求已经进入后台排队（异步任务）<br>204 NO CONTENT [DELETE] 用户删除数据成功<br>400 INVALID REQUEST [POST/PUT/PATCH] 用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的<br>401 UNAUTHORIZED [</em>] 表示用户没有权限（令牌、用户名、密码错误）<br>403 FORBIDDEN [<em>] 表示用户得到授权（与401错误相对），但是访问是被禁止的<br>404 NOT FOUND [</em>] 用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的<br>406 NOT ACCEPTABLE [GET] 用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）<br>410 GONE [GET] 用户请求的资源被永久删除，且不会再得到的<br>422 UNPROCESABLE ENTITY [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误<br>500 INTERNAL SERVER ERROR [*] 服务器发生错误，用户将无法判断发出的请求是否成功</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;状态码&lt;br&gt;字段名称为：code&lt;br&gt;200 OK [GET] 服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）&lt;br&gt;201 CREATED [POST/PUT/PATCH] 用户新建或修改数据成功&lt;br&gt;202 ACCEPTED [&lt;em&gt;] 表
      
    
    </summary>
    
    
      <category term="Node" scheme="http://1512034032.github.io/categories/Node/"/>
    
    
  </entry>
  
  <entry>
    <title>NodeJs 服务器 content-type类型处理</title>
    <link href="http://1512034032.github.io/2019/11/08/serverContent-type/"/>
    <id>http://1512034032.github.io/2019/11/08/serverContent-type/</id>
    <published>2019-11-08T08:54:34.184Z</published>
    <updated>2019-11-09T11:47:46.857Z</updated>
    
    <content type="html"><![CDATA[<p><code>path.join([path1][, path2][, ...])</code></p><h6 id="用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是-quot-quot-，Windows系统是-quot-quot-。"><a href="#用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是-quot-quot-，Windows系统是-quot-quot-。" class="headerlink" title="用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是&quot;/&quot;，Windows系统是&quot;\&quot;。"></a>用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是<code>&quot;/&quot;</code>，Windows系统是<code>&quot;\&quot;</code>。</h6><p><code>path.extname(p)</code></p><h6 id="返回路径中文件的后缀名，即路径中最后一个’-‘之后的部分。如果一个路径中并不包含’-‘或该路径只包含一个’-‘-且这个’-‘为路径的第一个字符，则此命令返回空字符串。"><a href="#返回路径中文件的后缀名，即路径中最后一个’-‘之后的部分。如果一个路径中并不包含’-‘或该路径只包含一个’-‘-且这个’-‘为路径的第一个字符，则此命令返回空字符串。" class="headerlink" title="返回路径中文件的后缀名，即路径中最后一个’.‘之后的部分。如果一个路径中并不包含’.‘或该路径只包含一个’.‘ 且这个’.‘为路径的第一个字符，则此命令返回空字符串。"></a>返回路径中文件的后缀名，即路径中最后一个’<code>.</code>‘之后的部分。如果一个路径中并不包含’<code>.</code>‘或该路径只包含一个’<code>.</code>‘ 且这个’<code>.</code>‘为路径的第一个字符，则此命令返回空字符串。</h6><h6 id="fs-exists-判断文件是否存在"><a href="#fs-exists-判断文件是否存在" class="headerlink" title="fs.exists() 判断文件是否存在"></a>fs.exists() 判断文件是否存在</h6><h6 id="nodejs服务器-content-type类型"><a href="#nodejs服务器-content-type类型" class="headerlink" title="nodejs服务器 content-type类型"></a>nodejs服务器 content-type类型</h6><pre><code>  &quot;css&quot;: &quot;text/css&quot;,  &quot;gif&quot;: &quot;image/gif&quot;,  &quot;html&quot;: &quot;text/html&quot;,  &quot;ico&quot;: &quot;image/x-icon&quot;,  &quot;jpeg&quot;: &quot;image/jpeg&quot;,  &quot;jpg&quot;: &quot;image/jpeg&quot;,  &quot;js&quot;: &quot;text/javascript&quot;,  &quot;json&quot;: &quot;application/json&quot;,  &quot;pdf&quot;: &quot;application/pdf&quot;,  &quot;png&quot;: &quot;image/png&quot;,  &quot;svg&quot;: &quot;image/svg+xml&quot;,  &quot;swf&quot;: &quot;application/x-shockwave-flash&quot;,  &quot;tiff&quot;: &quot;image/tiff&quot;,  &quot;txt&quot;: &quot;text/plain&quot;,  &quot;wav&quot;: &quot;audio/x-wav&quot;,  &quot;wma&quot;: &quot;audio/x-ms-wma&quot;,  &quot;wmv&quot;: &quot;video/x-ms-wmv&quot;,  &quot;xml&quot;: &quot;text/xml&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;path.join([path1][, path2][, ...])&lt;/code&gt;&lt;/p&gt;
&lt;h6 id=&quot;用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是-quot-quot-，Windows系统是-quot-quot-。&quot;&gt;
      
    
    </summary>
    
    
      <category term="Node" scheme="http://1512034032.github.io/categories/Node/"/>
    
    
  </entry>
  
  <entry>
    <title>解决跨域问题</title>
    <link href="http://1512034032.github.io/2019/11/08/CrossDomainIssues/"/>
    <id>http://1512034032.github.io/2019/11/08/CrossDomainIssues/</id>
    <published>2019-11-08T08:51:53.583Z</published>
    <updated>2019-11-09T11:47:07.509Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-让后台开启权限"><a href="#1-让后台开启权限" class="headerlink" title="1.让后台开启权限"></a>1.让后台开启权限</h3><pre><code>res.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;)</code></pre><h3 id="2-使用-nodejs-作为中间件设置代理服务器解决"><a href="#2-使用-nodejs-作为中间件设置代理服务器解决" class="headerlink" title="2.使用 nodejs 作为中间件设置代理服务器解决"></a>2.使用 nodejs 作为中间件设置代理服务器解决</h3><pre><code>var express = require(&#39;express&#39;);var proxy = require(&#39;http-proxy-middleware&#39;);var app = express();app.use(&#39;/api&#39;, proxy({target: &#39;http://10.119.168.87:4000&#39;, changeOrigin: true}));app.listen(3000);</code></pre><p>http-proxy-middleware用于后台将请求转发给其它服务器。</p><pre><code>例如：我们当前主机A为http://localhost:3000/，现在浏览器发送一个请求，请求接口/api，这个请求的数据在另外一台服务器B上（http://10.119.168.87:4000），这时，就可通过在A主机设置代理，直接将请求发送给B主机。简单实现代码如下var proxy = require(&#39;http-proxy-middleware&#39;);var apiProxy = proxy(&#39;/api&#39;, {target: &#39;http://www.example.org&#39;});//                   \____/   \_____________________________///                     |                    |//                需要转发的请求           目标服务器说明：我们利用express在3000端口启动了一个小型的服务器，利用了app.use(&#39;/api&#39;, proxy({target: &#39;http://10.119.168.87:4000/&#39;, changeOrigin: true}))这句话，使发到3000端口的/api请求转发到了4000端口。即请求http://localhost:3000/api相当于请求http://10.119.168.87:4000/api。</code></pre><p>下边是一个完整地址划分：</p><pre><code>foo://example.com:8042/over/there?name=ferret#nose \_/  \______________/\_________/ \_________/ \__/  |           |            |            |       |协议          主机         路径          查询     碎片</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-让后台开启权限&quot;&gt;&lt;a href=&quot;#1-让后台开启权限&quot; class=&quot;headerlink&quot; title=&quot;1.让后台开启权限&quot;&gt;&lt;/a&gt;1.让后台开启权限&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;res.setHeader(&amp;#39;Access-Control-
      
    
    </summary>
    
    
      <category term="Node" scheme="http://1512034032.github.io/categories/Node/"/>
    
    
      <category term="Node" scheme="http://1512034032.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Cookis</title>
    <link href="http://1512034032.github.io/2019/11/08/cookis/"/>
    <id>http://1512034032.github.io/2019/11/08/cookis/</id>
    <published>2019-11-08T08:37:56.607Z</published>
    <updated>2019-11-09T11:46:56.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建-能替换"><a href="#创建-能替换" class="headerlink" title="创建 能替换"></a>创建 能替换</h2><pre><code>Cookies.set(&#39;name&#39;,&#39;xiaoGao&#39;)Cookies.set(&#39;name&#39;,&#39;123&#39;)Cookies.set(&#39;name&#39;,&#39;xiaoLiu&#39;,{expires:7})Cookies.set(&#39;password&#39;,&#39;xiaoLiu&#39;,{expires:7})//设置时效Cookies.set(&#39;id&#39;,&#39;11&#39;,{expires:7,path:&#39;&#39;})//设置根路径</code></pre><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><pre><code>//有参数时,就读取对应键名的键值console.log(Cookies.get(&#39;name&#39;))// =&gt;value 有对应的值console.log(Cookies.get(&#39;ss&#39;))// =&gt;undefined 没有对应的值//没有参数时,把所有的cookie全部读取出来console.log(Cookies.get())//返回一个对象 属性名是键名,属性值是键值console.log(Cookies.get(&#39;name&#39;,{path:&#39;/&#39;}))//属性（第二个参数）对其没有影响</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre><code>Cookies.remove(&#39;name&#39;)Cookies.set(&#39;id&#39;,&#39;1234&#39;,{path:&#39;&#39;})Cookies.remove(&#39;name&#39;) //无法删除Cookies.remove(&#39;id&#39;,{path:&#39;&#39;}) //成功删除</code></pre><h2 id="json和cookie"><a href="#json和cookie" class="headerlink" title="json和cookie"></a>json和cookie</h2><pre><code>Cookies.set(&#39;ss&#39;,{pname:&#39;xiaomi&#39;})console.log(Cookies.get(&#39;ss&#39;))//键值是JSON对象console.log(Cookies.get())//普通对象（全部cookies内容）console.log(Cookies.getJSON(&#39;carts&#39;))//普通对象; 刷新之后容易出现bug//JSON字符串转化为数组let arr = JSON.parse(jsonStr)//数组转化为JSON字符串let str = JSON.stringify(arr)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建-能替换&quot;&gt;&lt;a href=&quot;#创建-能替换&quot; class=&quot;headerlink&quot; title=&quot;创建 能替换&quot;&gt;&lt;/a&gt;创建 能替换&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Cookies.set(&amp;#39;name&amp;#39;,&amp;#39;xiaoGao&amp;#39;)

      
    
    </summary>
    
    
      <category term="前端" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Js" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/Js/"/>
    
    
      <category term="cookis" scheme="http://1512034032.github.io/tags/cookis/"/>
    
  </entry>
  
  <entry>
    <title>ES6---new Promise()讲解，Promise对象是用来干嘛的?</title>
    <link href="http://1512034032.github.io/2019/11/07/promise/"/>
    <id>http://1512034032.github.io/2019/11/07/promise/</id>
    <published>2019-11-07T07:23:03.235Z</published>
    <updated>2019-11-09T11:47:37.432Z</updated>
    
    <content type="html"><![CDATA[<p>ES2015正式发布（也就是ES6，ES6是它的乳名），其中Promise被列为正式规范。作为ES6中最重要的特性之一，我们有必要掌握并理解透彻。本文将由浅到深，讲解Promise的基本概念与使用方法。</p><h1 id="ES6-Promise-先拉出来遛遛"><a href="#ES6-Promise-先拉出来遛遛" class="headerlink" title="ES6 Promise 先拉出来遛遛"></a>ES6 Promise 先拉出来遛遛</h1><p>复杂的概念先不讲，我们先简单粗暴地把Promise用一下，有个直观感受。那么第一个问题来了，Promise是什么玩意呢？是一个类？对象？数组？函数？</p><p>别猜了，直接打印出来看看吧，console.dir(Promise)，就这么简单粗暴。<br><img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311003722741-755677508.png" alt=""></p><p>这么一看就明白了，Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。这么说用Promise new出来的对象肯定就有then、catch方法喽，没错。</p><p>那就new一个玩玩吧。</p><pre><code>var p = new Promise(function(resolve, reject){    //做一些异步操作    setTimeout(function(){        console.log(&#39;执行完成&#39;);        resolve(&#39;随便什么数据&#39;);    }, 2000);});</code></pre><p>Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。</p><p>在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并且调用resolve方法。</p><p>运行代码，会在2秒后输出“执行完成”。注意！我只是new了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数，如：</p><pre><code>function runAsync(){    var p = new Promise(function(resolve, reject){        //做一些异步操作        setTimeout(function(){            console.log(&#39;执行完成&#39;);            resolve(&#39;随便什么数据&#39;);        }, 2000);    });    return p;}runAsync()</code></pre><p>这时候你应该有两个疑问：1.包装这么一个函数有毛线用？2.resolve(‘随便什么数据’);这是干毛的？</p><p>我们继续来讲。在我们包装好的函数最后，会return出Promise对象，也就是说，执行这个函数我们得到了一个Promise对象。还记得Promise对象上有then、catch方法吧？这就是强大之处了，看下面的代码：</p><pre><code>runAsync().then(function(data){    console.log(data);    //后面可以用传过来的数据做些其他操作    //......});</code></pre><p>在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“随便什么数据”。</p><p>这时候你应该有所领悟了，原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。</p><p>你可能会不屑一顾，那么牛逼轰轰的Promise就这点能耐？我把回调函数封装一下，给runAsync传进去不也一样吗，就像这样：</p><pre><code>function runAsync(callback){    setTimeout(function(){        console.log(&#39;执行完成&#39;);        callback(&#39;随便什么数据&#39;);    }, 2000);}runAsync(function(data){    console.log(data);});</code></pre><p>效果也是一样的，还费劲用Promise干嘛。那么问题来了，有多层回调该怎么办？如果callback也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个callback2，然后给callback传进去吧。而Promise的优势在于，可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。</p><p>#链式操作的用法<br>所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：</p><pre><code>runAsync1().then(function(data){    console.log(data);    return runAsync2();}).then(function(data){    console.log(data);    return runAsync3();}).then(function(data){    console.log(data);});</code></pre><p>这样能够按顺序，每隔两秒输出每个异步回调中的内容，在runAsync2中传给resolve的数据，能在接下来的then方法中拿到。运行结果如下：<br><img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004311507-221152206.png" alt=""><br>猜猜runAsync1、runAsync2、runAsync3这三个函数都是如何定义的？没错，就是下面这样:</p><pre><code>function runAsync1(){    var p = new Promise(function(resolve, reject){        //做一些异步操作        setTimeout(function(){            console.log(&#39;异步任务1执行完成&#39;);            resolve(&#39;随便什么数据1&#39;);        }, 1000);    });    return p;}function runAsync2(){    var p = new Promise(function(resolve, reject){        //做一些异步操作        setTimeout(function(){            console.log(&#39;异步任务2执行完成&#39;);            resolve(&#39;随便什么数据2&#39;);        }, 2000);    });    return p;}function runAsync3(){    var p = new Promise(function(resolve, reject){        //做一些异步操作        setTimeout(function(){            console.log(&#39;异步任务3执行完成&#39;);            resolve(&#39;随便什么数据3&#39;);        }, 2000);    });    return p;}</code></pre><p>在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了，比如我们把上面的代码修改成这样：</p><pre><code>runAsync1().then(function(data){    console.log(data);    return runAsync2();}).then(function(data){    console.log(data);    return &#39;直接返回数据&#39;;  //这里直接返回数据}).then(function(data){    console.log(data);});</code></pre><p>那么输出就变成了这样：<br><img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004444163-67067993.png" alt=""></p><h1 id="reject的用法"><a href="#reject的用法" class="headerlink" title="reject的用法"></a>reject的用法</h1><p>到这里，你应该对“Promise是什么玩意”有了最基本的了解。那么我们接着来看看ES6的Promise还有哪些功能。我们光用了resolve，还没用reject呢，它是做什么的呢？事实上，我们前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。</p><pre><code>function getNumber(){    var p = new Promise(function(resolve, reject){        //做一些异步操作        setTimeout(function(){            var num = Math.ceil(Math.random()*10); //生成1-10的随机数            if(num&lt;=5){                resolve(num);            }            else{                reject(&#39;数字太大了&#39;);            }        }, 2000);    });    return p;}getNumber().then(    function(data){        console.log(&#39;resolved&#39;);        console.log(data);    },     function(reason, data){        console.log(&#39;rejected&#39;);        console.log(reason);    });</code></pre><p>getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。</p><p>运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：<br><img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004607960-1156803894.png" alt=""><br>或者<br><img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004616257-1024778840.png" alt=""></p><h1 id="catch的用法"><a href="#catch的用法" class="headerlink" title="catch的用法"></a>catch的用法</h1><p>我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调，用法是这样：</p><pre><code>getNumber().then(function(data){    console.log(&#39;resolved&#39;);    console.log(data);}).catch(function(reason){    console.log(&#39;rejected&#39;);    console.log(reason);});</code></pre><p>效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。请看下面的代码：</p><pre><code>getNumber().then(function(data){    console.log(&#39;resolved&#39;);    console.log(data);    console.log(somedata); //此处的somedata未定义}).catch(function(reason){    console.log(&#39;rejected&#39;);    console.log(reason);});</code></pre><p>在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：<br><img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004747147-1508291069.png" alt=""><br>也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能。</p><h1 id="all的用法"><a href="#all的用法" class="headerlink" title="all的用法"></a>all的用法</h1><p>Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。我们仍旧使用上面定义好的runAsync1、runAsync2、runAsync3这三个函数，看下面的例子：</p><pre><code>Promise.all([runAsync1(), runAsync2(), runAsync3()]).then(function(results){    console.log(results);});</code></pre><p>用Promise.all来执行，all接收一个数组参数，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。所以上面代码的输出结果就是：<br><img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004843491-346782307.png" alt=""><br>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</p><h1 id="race的用法"><a href="#race的用法" class="headerlink" title="race的用法"></a>race的用法</h1><p>all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思。race的用法与all一样，我们把上面runAsync1的延时改为1秒来看一下：</p><pre><code>Promise.race([runAsync1(), runAsync2(), runAsync3()]).then(function(results){    console.log(results);});</code></pre><p>这三个异步操作同样是并行执行的。结果你应该可以猜到，1秒后runAsync1已经执行完了，此时then里面的就执行了。结果是这样的：<br><img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004946022-706413123.png" alt=""><br>你猜对了吗？不完全，是吧。在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧再执行。于是再过1秒后，输出了他们结束的标志。</p><p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下：</p><pre><code>//请求某个图片资源function requestImg(){    var p = new Promise(function(resolve, reject){        var img = new Image();        img.onload = function(){            resolve(img);        }        img.src = &#39;xxxxxx&#39;;    });    return p;}//延时函数，用于给请求计时function timeout(){    var p = new Promise(function(resolve, reject){        setTimeout(function(){            reject(&#39;图片请求超时&#39;);        }, 5000);    });    return p;}Promise.race([requestImg(), timeout()]).then(function(results){    console.log(results);}).catch(function(reason){    console.log(reason);});</code></pre><p>requestImg函数会异步请求一张图片，我把地址写为”xxxxxx”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。运行结果如下：<br><img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311005040272-341718790.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我怎么还见过done、finally、success、fail等，这些是啥？这些并不在Promise标准中，而是我们自己实现的语法糖。</p><p>本文中所有异步操作均以setTimeout为例子，之所以不使用ajax是为了避免引起混淆，因为谈起ajax，很多人的第一反应就是jquery的ajax，而jquery又有自己的Promise实现。如果你理解了原理，就知道使用setTimeout和使用ajax是一样的意思。说起jquery，我不得不吐槽一句，jquery的Promise实现太过垃圾，各种语法糖把人都搞蒙了，我认为Promise之所以没有全面普及和jquery有很大的关系。后面我们会细讲jquery。</p><p>关于Promise还有一些内容是需要讲的，限于篇幅，本文就只作ES6 Promise的讲解，接下来还会有大白话讲解系列：</p><ul><li>Promise/A+规范</li><li>jquery中的Promise</li></ul><p>此文转自：<a href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html" target="_blank" rel="noopener">https://www.cnblogs.com/lvdabao/p/es6-promise-1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ES2015正式发布（也就是ES6，ES6是它的乳名），其中Promise被列为正式规范。作为ES6中最重要的特性之一，我们有必要掌握并理解透彻。本文将由浅到深，讲解Promise的基本概念与使用方法。&lt;/p&gt;
&lt;h1 id=&quot;ES6-Promise-先拉出来遛遛&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="前端" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Js" scheme="http://1512034032.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>js小知识点</title>
    <link href="http://1512034032.github.io/2019/11/07/js/"/>
    <id>http://1512034032.github.io/2019/11/07/js/</id>
    <published>2019-11-06T23:51:21.037Z</published>
    <updated>2019-11-11T01:43:15.943Z</updated>
    
    <content type="html"><![CDATA[<h3 id="js的基础介绍"><a href="#js的基础介绍" class="headerlink" title="js的基础介绍"></a>js的基础介绍</h3><ul><li>js的组成<ul><li>ECMAscript</li><li>BOM</li><li>DOM</li></ul></li></ul><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><ul><li><p>javascript的数据类型</p><ul><li>数值</li><li>字符串</li><li>布尔值</li><li>undefined</li><li>null</li><li>对象</li></ul></li><li><p>JavaScript的数据类型转换</p><ul><li>显性转换</li><li>隐性转换</li></ul></li></ul><h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><ul><li><p>算术运算符</p><ul><li>+  -   *  /      %</li></ul></li><li><p>赋值运算符</p><ul><li>=   +=  -=  *=   /=  %=</li></ul></li><li><p>关系运算符</p><ul><li>&gt;    &lt;   &gt;=   &lt;=   ==  !=    ===   !== </li></ul></li></ul><pre><code>var num = 3.11111num.toFixed(3)// toFixed(n) 保留n位小数</code></pre><h5 id="变量及命名规则"><a href="#变量及命名规则" class="headerlink" title="变量及命名规则"></a>变量及命名规则</h5><p>变量的声明和定义</p><pre><code>var  a = 10;</code></pre><p>var是关键字， a是变量名， </p><p>=是赋值符号 10是值<br>变量的命名规则<br>    变量是由数字、字母、下划线（_）和美元符号（$）的一种或者几种组成，且不能以数字开头,严格区分大小写。<br>    （驼峰法则，见名知义）<br>关键字</p><pre><code>script标签写在body结束标签之前praseInt（1.67）取整为1,不四舍五入let num = 1.8888;console.log(num.toFixed(2));保留两位小数为1.89，并四舍五入字符转转数字parseInt() //数字，取整parseFloat() //浮点数，小数Number()//数字数字转字符串parseString</code></pre><h2 id="逻辑分支"><a href="#逻辑分支" class="headerlink" title="逻辑分支"></a>逻辑分支</h2><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><pre><code>顺序结构    从上到下执行逻辑分支结构    if语句    switch语句循环结构    while循环    for循环</code></pre><h6 id="逻辑分支结构if语句"><a href="#逻辑分支结构if语句" class="headerlink" title="逻辑分支结构if语句"></a>逻辑分支结构if语句</h6><pre><code>逻辑分支结构，选择结构也叫条件语句一 、if 结构（单分支）if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，true表示真，false表示伪。if (布尔值)  语句;// 或者if (布尔值) 语句;上面是if结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为true，就执行紧跟在后面的语句；如果结果为false，则跳过紧跟在后面的语句。</code></pre><h6 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h6><pre><code class="javascript">//!a 单目//a+b 双目//表达式1? 表达式2 : 表达式3//如果表达式1为true，表达式2的值就是整个式子的值，反之表达式3就是整个式子的值var a = 1;let b = 0;b = a == 1 ?2 : 3; //三目</code></pre><h6 id="二、八、十六进制"><a href="#二、八、十六进制" class="headerlink" title="二、八、十六进制"></a>二、八、十六进制</h6><pre><code class="javascript">//二进制    console.log(011)//1*2^0+1*2^1 = 3//八进制（0-7）    console.log(071)//1*8^0+7*8^1 = 071//十六进制（0-9/a-f）    console.log(0x11a)//10*16^0+1*16^1+1*16^2//十进制转任意进制//tostring(进制值)；    let a = 100;    console.log(aa.toString(2));    console.log(aa.toString(8));    console.log(aa.toString(16));</code></pre><h6 id="switch结构"><a href="#switch结构" class="headerlink" title="switch结构"></a>switch结构</h6><pre><code class="javascript">switch (变量名) {  case &quot;变量值1&quot;:    // ...当变量的值为变量值1的时候所执行的代码    break;//跳出循环，不往下执行  case &quot;变量值1&quot;:    // ...当变量的值为变量值2的时候所执行的代码    break;  default:    // ...除了上面的变量值的所有情况而执行的代码}//上面代码根据变量fruit的值，选择执行相应的case。//如果所有case都不符合，则执行最后的default部分。//注意：每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。//case代码块之中没有break语句，导致不会跳出switch结构，而会一直执行下去。这种效果叫穿透。</code></pre><h6 id="NaN转换类型"><a href="#NaN转换类型" class="headerlink" title="NaN转换类型"></a>NaN转换类型</h6><pre><code class="javascript">console.log(parseInt(&quot;12px&quot;));//12 只转开头的整数console.log(parseInt(&quot;aa12px&quot;));//NaNconsole.log(Number(&quot;12px&quot;));//NaN ：not a numberconsole.log(NaN == NaN);//falseconsole.log(typeof NaN)//numberconsole.log(typeof typeof NaN)//stringconsole.log(typeof typeof aaa)//stringconsole.log(typeof typeof null)//stringconsole.log(typeof typeof undefined)//stringconsole.log(isNaN(NaN))//trueconsole.log(isNaN(&quot;11&quot;))//falseconsole.log(isNaN(&quot;11px&quot;))//true/*isNaN(x)返回值如果 x 是特殊的非数字值 NaN（或者能被转换为这样的值），返回的值就是 true。如果 x 是其他值,则返回 false。说明isNaN() 函数可用于判断其参数是否是 NaN，该值表示一个非法的数字（比如被 0 除后得到的结果）。如果把 NaN 与任何值（包括其自身）相比得到的结果均是 false，所以要判断某个值是否是 NaN，不能使用 == 或 === 运算符。正因为如此，isNaN() 函数是必需的。*/</code></pre><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h6 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h6><pre><code class="javascript">let i = 0;while(i&lt;10){    //执行的语句}</code></pre><h6 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h6><pre><code class="javascript">//先执行一次，再去判断条件let i = 0;do{    i++;}while{    //执行的语句}</code></pre><h6 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h6><pre><code class="javascript">for(var i=0;i&lt;10;i++){    //执行的语句}</code></pre><h6 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h6><pre><code>break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。break语句用于跳出代码块或结束循环。continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="函数的概念及创建"><a href="#函数的概念及创建" class="headerlink" title="函数的概念及创建"></a>函数的概念及创建</h4><h6 id="函数的概念"><a href="#函数的概念" class="headerlink" title="函数的概念"></a>函数的概念</h6><pre><code>函数是一段可以反复调用的代码块。作用：    在程序设计中，常将一些常用的功能模块编写成函数，以减少重复编写程序段的工作量。    提高代码的复用性、可读性等</code></pre><h6 id="函数的创建"><a href="#函数的创建" class="headerlink" title="函数的创建"></a>函数的创建</h6><pre><code class="javascript">函数的创建方式（函数的声明）（1）function 命令function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号。函数体放在大括号里面。    function 函数名称() {            //函数中要执行的代码;     }    function print() {          console.log(1);    }上面的代码命名了一个print函数，以后使用print()这种形式，就可以调用相应的代码。这叫做函数的声明（2）函数表达式除了用function命令声明函数，还可以采用变量赋值的写法。    var print = function() {          console.log(1);    };这种写法将一个匿名函数（没有名字的函数）赋值给变量。这时，这个匿名函数又称函数表达式（3）立即调用函数，即直接执行的函数：(function(){})()</code></pre><h4 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h4><pre><code class="javascript">函数的执行(调用)：函数定义好之后，函数中的代码在程序运行过程中不会执行；function print() {     console.log(1);}通过函数名称调用函数，调用时执行函数中的代码；调用函数时，要使用圆括号运算符function(){    print();}</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><h6 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h6><pre><code class="javascript">/*onclick            鼠标单击ondblclick        鼠标双击onmousedown        鼠标按键按下onmouseup        鼠标按键抬起onmousemove        鼠标在元素上移动onmouseout        鼠标移出Onmouseenter    鼠标移入*/</code></pre><h6 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h6><pre><code class="javascript">/* Onkeydown        键盘按键按下Onkeyup            键盘按键抬起onkeypress        键盘按键按住*/</code></pre><h6 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h6><pre><code class="javascript">/*Onblur        失去焦点Onfocus        获取焦点Onchange    内容修改*/</code></pre><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><h6 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h6><pre><code class="javascript">函数名后面是一对圆括号，里面是传入函数的参数function 函数名称(参数列表){    函数体中的代码;}函数定义的时候的参数，称为形参function print(s) {   console.log(s);}function add(a,b) {   console.log(a+b);}参数的传递    print（1）；调用函数的时候，传入了 参数  1，1的值给了形参s。函数调用时候传入的参数叫做实参</code></pre><h6 id="变量的声明提升"><a href="#变量的声明提升" class="headerlink" title="变量的声明提升"></a>变量的声明提升</h6><pre><code class="javascript">函数内部会产生“变量提升”现象。在函数内部使用var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。function foo(x) {  if (x &gt; 100) {    var tmp = x - 100;  }}// 等同于function foo(x) {  var tmp;  if (x &gt; 100) {    tmp = x - 100;  };}</code></pre><h6 id="arguments参数"><a href="#arguments参数" class="headerlink" title="arguments参数"></a>arguments参数</h6><pre><code class="javascript">由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。var f = function (one) {  console.log(arguments[0]);  console.log(arguments[1]);  console.log(arguments[2]);}f(1, 2, 3)通过arguments对象的length属性，可以判断函数调用时到底带几个参数。</code></pre><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><pre><code class="javascript">JavaScript 引擎遇到return语句，就直接返回return后面的那个表达式的值,后面即使还有语句，也不会得到执行。也就是说，return语句所带的那个表达式，就是函数的返回值。注、return语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回undefined。function add(x, y) {  return x + y; //返回x+y的和}var res = add(1, 1) ;//把函数的返回值 赋值给 变量resconsole.log(res);//2</code></pre><h6 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h6><pre><code class="javascript">作用域:作用域（scope）指的是变量存在的范围。局部作用域和全局作用域          在 ES5 的规范中，Javascript 只有两种作用域：    一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；    另一种是函数作用域，变量只在函数内部存在。  函数外部声明的变量就是全局变量（global variable）在函数内部定义的(使用var)变量，外部无法读取，顾称为“局部变量”（local variable）var v = 1;//全局变量function f() {  var b = 2;//局部变量  console.log(b);  console.log(v);//它在函数内部可以读取全局变量，但是局部变量的不能再函数外部访问}f()上面的代码表明，函数f内部可以读取全局变量v。列子：</code></pre><h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6><pre><code class="js">构造函数及对象类型（了解）：    面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。    面向对象编程的第一步，就是要生成对象。对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成    JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。    构造函数就是一个普通的函数，但是有自己的特征和用法。function Vehicle  () {  this.price = 1000;};上面代码中，Vehicle就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。构造函数的特点有两个。         函数体内部使用了this关键字，代表了所要生成的对象实例。生成对象的时候，必须使用new命令new命令的作用，就是执行构造函数，返回一个实例对象。function Vehicle  () {  this.price = 1000;};var v = new Vehicle();v.price // 1000    上面代码通过new命令，让构造函数Vehicle生成一个实例对象，保存在变量v中。这个新生成的实例对象，从构造函数Vehicle得到了price属性。new命令执行时，构造函数内部的this，就代表了新生成的实例对象，this.price表示实例对象有一个price属性，值是1000。function Dog(){}</code></pre><h2 id="ES5严格模式"><a href="#ES5严格模式" class="headerlink" title="ES5严格模式"></a>ES5严格模式</h2><h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><pre><code class="js">//严格模式:除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行。设计目的早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。严格模式是从 ES5 进入标准的，主要目的有以下几个。明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。提高编译器效率，增加运行速度。为未来新版本的 JavaScript 语法做好铺垫。总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向//启用方法:进入严格模式的标志，是一行字符串use strict。&#39;use strict&#39;;老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。严格模式可以用于整个脚本，也可以只用于单个函数（1） 整个脚本文件use strict放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。(严格地说，只要前面不是产生实际运行结果的语句，use strict可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。)</code></pre><h6 id="eval作用域"><a href="#eval作用域" class="headerlink" title="eval作用域"></a>eval作用域</h6><pre><code class="js">创设 eval 作用域正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，eval所生成的变量只能用于eval内部。(function () {  &#39;use strict&#39;;  var x = 2;  console.log(eval(&#39;var x = 5; x&#39;)) // 5  console.log(x) // 2})()上面代码中，由于eval语句内部是一个独立作用域，所以内部的变量x不会泄露到外部</code></pre><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><pre><code class="js">setInterval（func，time）有两个参数，第一个参数是一个函数，第二个参数是时间间隔，单位是毫秒每间隔time毫秒，会执行一次函数setInterval的返回值是一个数字function box（）{    console.log(1)}var timer = setInerval(box,1000);上面代码意思是，没间隔1000毫秒，box函数执行一次。取消定时器的执行如果想要取消定时器的执行我们需要拿到setInerval定时器函数的返回值，调用clearInterval，清除定时器clearInterval（timer），调用之后box函数就不会再执行了！</code></pre><h2 id="BOM-amp-amp-DOM"><a href="#BOM-amp-amp-DOM" class="headerlink" title="BOM&amp;&amp;DOM"></a>BOM&amp;&amp;DOM</h2><h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><h6 id="BOM概念"><a href="#BOM概念" class="headerlink" title="BOM概念"></a>BOM概念</h6><pre><code class="js">BOM的概念提供了独立于页面内容而与浏览器进行交互的对象，其核心对象是window在浏览器中，window对象（注意，w为小写）指当前的浏览器窗口。它也是所有对象的顶层对象。“顶层对象”指的是最高一层的对象，所有其他对象都是它的下属。JavaScript规定，浏览器环境的所有全局变量，都是window对象的属性。var a = 1;window.a // 1上面代码中，变量a是一个全局变量，但是实质上它是window对象的属性。声明一个全局变量，就是为window对象的同名属性赋值</code></pre><h6 id="navigator-userAgent浏览器类型"><a href="#navigator-userAgent浏览器类型" class="headerlink" title="navigator.userAgent浏览器类型"></a>navigator.userAgent浏览器类型</h6><pre><code class="js">//浏览器代理检测，可以检测出来用户使用的浏览器类型，也可以检测浏览器所在的操作系统    navigator.userAgent//判断浏览器类型            var t = navigator.userAgent;            if(t.indexOf(&#39;Trident&#39;)!= -1){                console.log(&#39;ie内核&#39;)            }else if(t.indexOf(&#39;Presto&#39;)!= -1){                console.log(&#39;欧朋&#39;)            }else if(t.indexOf(&#39;Chrome&#39;)!= -1){                console.log(&#39;chrome &#39;)            }else if(t.indexOf(&#39;Safari&#39;)!= -1){                console.log(&#39;Safari &#39;)            }else{                console.log(&#39;其他&#39;)            }</code></pre><h6 id="手机类型"><a href="#手机类型" class="headerlink" title="手机类型"></a>手机类型</h6><pre><code class="js">//判断是移动端还是PC（重要）//移动端            var ua = navigator.userAgent.toLowerCase();            if (ua.indexOf(&#39;mob&#39;) != -1) {                console.log(&#39;手机&#39;);                if (ua.indexOf(&#39;android&#39;) != -1) {                    console.log(&#39;移动端 安卓&#39;);                } else if (ua.indexOf(&#39;opod&#39;) != -1 ||                    ua.indexOf(&#39;iphone&#39;) != -1 ||                    ua.indexOf(&#39;ipad&#39;) != -1) {                    console.log(&#39;移动端 苹果手机&#39;);                }            } else {                console.log(&#39;非手机&#39;);            }</code></pre><h4 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h4><h6 id="localhost对象"><a href="#localhost对象" class="headerlink" title="localhost对象"></a>localhost对象</h6><pre><code class="js">location对象包含有关当前 URL 的信息。location对象是 Window 对象的一个部分，可通过 window.location 属性来访问。属性：hash、host、hostname、href、pathname、port、protocol、searchhref：        //设置或返回完整的 URL。（常用）hash：        //设置或返回从井号 (#) 开始的 URL（锚）。search：        //设置或返回从问号 (?) 开始的 URL（查询部分？id=1&amp;name=abb）。（常用）host        //设置或返回主机名和当前 URL 的端口号。hostname    //设置或返回当前 URL 的主机名。pathname    //设置或返回当前 URL 的路径部分。port        //设置或返回当前 URL 的端口号。protocol    //设置或返回当前 URL 的协议。</code></pre><h6 id="location对象-方法"><a href="#location对象-方法" class="headerlink" title="location对象 方法"></a>location对象 方法</h6><pre><code class="js">location对象 方法：assign(url), replace(url) , reload()assign()            //加载新的文档。reload()            //重新加载当前文档。replace()            //用新的文档替换当前文档。window.open();        //打开一个新的浏览器窗口。window.close();        //关闭浏览器窗口。alert(arg1)            //显示带有一段消息和一个确认按钮的警告框。prompt(arg1,arg2)    //显示可提示用户输入的对话框。confirm(arg1)         //（偶尔）显示带有一段消息以及确认按钮和取消按钮的对话框。history对象：   history对象保存着用户上网的历史记录,从窗口被 打开的那一刻算起.   后退一页  history.go(-1)     history.back()   前进一页  history.go(1)      history.forward()   前进两页  history.go(2) window.onload：    load事件发生在文档在浏览器窗口加载完毕时。window.onload属性可以指定这个事件的回调函数。    window.onload = function() {        console.log(&#39;页面加载完毕&#39;)    };</code></pre><h4 id="定时器和延时器"><a href="#定时器和延时器" class="headerlink" title="定时器和延时器"></a>定时器和延时器</h4><pre><code class="js">定时器和延时器：JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由setTimeout()和setInterval()这两个函数来完成。</code></pre><h6 id="1、延时器"><a href="#1、延时器" class="headerlink" title="1、延时器"></a>1、延时器</h6><pre><code class="js">延时器：    setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。    var timerId = setTimeout(func, delay);上面代码中，setTimeout函数接受两个参数，第一个参数func是将要推迟执行的函数名，第二个参数delay是推迟执行的毫秒数。            console.log(1);            //推迟执行            setTimeout(function(){                console.log(2)            },1000);            console.log(3);</code></pre><h6 id="2、定时器"><a href="#2、定时器" class="headerlink" title="2、定时器"></a>2、定时器</h6><pre><code class="js">定时器：    setInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。            var timer = setInterval(function() {                console.log(2);            }, 1000)    上面代码中，每隔1000毫秒就输出一个2，会无限运行下去，直到关闭当前窗口。</code></pre><h6 id="3、清除定时器"><a href="#3、清除定时器" class="headerlink" title="3、清除定时器"></a>3、清除定时器</h6><pre><code class="js">清除定时器：    setTimeout和setInterval函数，都返回一个整数值，表示计数器编号。将该整数传入clearTimeout和clearInterval函数，就可以取消对应的定时器。            var id1 = setTimeout(f, 1000);            var id2 = setInterval(f, 1000);clearTimeout(id1);clearInterval(id2);上面代码中，回调函数f不会再执行了，因为两个定时器都被取消了。</code></pre><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><h6 id="滚动监听"><a href="#滚动监听" class="headerlink" title="滚动监听"></a>滚动监听</h6><pre><code class="js">document.scrollingElementdocument.scrollingElement属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。这个属性返回的文档的根元素document.documentElement（即&lt;html&gt;）。获取可视区域距离页面顶部的距离document.scrollingElement.scrollTop;设置滚动条的距离页面顶面的距离document.scrollingElement.scrollTop = 0或者也可以像下面    获取  scrollTop = document.scrollingElement.scrollTop  scrollTop=document.documentElement.scrollTop  || document.body.scrollTop设置document.documentElement.scrollTop  = 0 document.body.scrollTop = 0；</code></pre><h4 id="DOM的基本操作-查询、创建、添加，修改，删除"><a href="#DOM的基本操作-查询、创建、添加，修改，删除" class="headerlink" title="DOM的基本操作(查询、创建、添加，修改，删除)"></a>DOM的基本操作(查询、创建、添加，修改，删除)</h4><h6 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h6><pre><code class="js">document.getElementById//方法返回匹配指定id属性的元素节点。如果没有发现匹配的节点，则返回null。document.getElementsByClassName//方法返回一个类似数组的对象（HTMLCollection实例），包括了所有class名字符合指定条件的元素（兼容问题，低版本ie）document.getElementsByTagName//方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（HTMLCollection实例）document.querySelector//方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。document.querySelectorAll方法与querySelector用法类似，区别是返回一个NodeList对象，包含所有匹配给定选择器的节点。</code></pre><pre><code class="js">var id = document.getElementById(&quot;id&quot;);//idvar box = document.getElementsByClassName(&quot;box&quot;);//classvar div = document.getElementsByTagName(&quot;div&quot;);//标签名var el1 = document.querySelector(&#39;.myclass&#39;);//css选择器elementList = document.querySelectorAll(&#39;.myclass&#39;);//css选择器都可以</code></pre><h6 id="创建、添加"><a href="#创建、添加" class="headerlink" title="创建、添加"></a>创建、添加</h6><pre><code class="js">//创建：document.createElement方法用来生成元素节点，并返回该节点。var newDiv = document.createElement(&#39;div&#39;);createElement方法的参数为元素的标签名，即元素节点的tagName属性，对于 HTML 网页大小写不敏感，即参数为div或DIV返回的是同一种节点//添加：oDiv.appendChild(newDiv);把newDiv添加到oDiv内部的最后面Element.innerHTML属性返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括&lt;HTML&gt;和&lt;body&gt;元素。如果将innerHTML属性设为空，等于删除所有它包含的所有节点。</code></pre><h6 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h6><pre><code class="js">//两个参数 新元素 老元素box.replaceChild(&quot;newNode&quot;,&quot;oldNode&quot;)</code></pre><h6 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h6><pre><code class="js">var el = document.getElementById(&#39;mydiv&#39;);el.remove();box.removeChild(oldNode)</code></pre><p>DOM节点类型(元素和文本)</p><blockquote><p>DOM节点类型(元素和文本)</p><p>DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。</p><p>Element：网页的各种HTML标签（比如<body>、<a>等）<br>Text：标签之间或标签包含的文本  （创建Text）<br>注释也是节点 </p><p>通过 nodeType属性可以查看类型<br>如果节点是一个元素节点，nodeType 属性返回 1。<br>如果节点是属性节点, nodeType 属性返回 2。<br>如果节点是一个文本节点，nodeType 属性返回 3。<br>如果节点是一个注释节点，nodeType 属性返回 8</p></blockquote><h6 id="文档碎片"><a href="#文档碎片" class="headerlink" title="文档碎片"></a>文档碎片</h6><pre><code class="js"> 文档碎片  document.createDocumentFragment()  作为容器使用，可以避免频繁操作dom</code></pre><h2 id="DOM-1"><a href="#DOM-1" class="headerlink" title="DOM"></a>DOM</h2><h4 id="属性节点"><a href="#属性节点" class="headerlink" title="属性节点"></a>属性节点</h4><h6 id="属性节点-1"><a href="#属性节点-1" class="headerlink" title="属性节点"></a>属性节点</h6><pre><code>    Element.className    className属性用来读写当前元素节点的class属性。它的值是一个字符串，每个class之间用空格分割。</code></pre><pre><code class="js">// HTML 代码 &lt;div class=&quot;one two three&quot; id=&quot;myDiv&quot;&gt;&lt;/div&gt;var div = document.getElementById(&#39;myDiv&#39;);div.className// &quot;one two three&quot;</code></pre><h6 id="Element-style"><a href="#Element-style" class="headerlink" title="Element.style"></a>Element.style</h6><pre><code class="js">每个元素节点都有style用来读写该元素的行内样式信息不过，连词号需要变成骆驼拼写法。var divStyle = document.querySelector(&#39;div&#39;).style;divStyle.backgroundColor = &#39;red&#39;;divStyle.border = &#39;1px solid black&#39;;divStyle.width = &#39;100px&#39;;divStyle.height = &#39;100px&#39;;divStyle.fontSize = &#39;10em&#39;;divStyle.backgroundColor // reddivStyle.border // 1px solid blackdivStyle.height // 100pxdivStyle.width // 100pxElement.style返回的只是行内样式，并不是该元素的全部样式。通过样式表设置的样式，或者从父元素继承的样式，无法通过这个属性得到。元素的全部样式要通过window.getComputedStyle()得到。</code></pre><h6 id="获取属性和设置属性（自定义属性）"><a href="#获取属性和设置属性（自定义属性）" class="headerlink" title="获取属性和设置属性（自定义属性）"></a>获取属性和设置属性（自定义属性）</h6><blockquote><p>Element.getAttribute方法接受一个字符串作为参数，返回同名属性的值。如果没有该属性，则返回null。</p></blockquote><pre><code class="js">var mydiv = document.getElementById(&#39;mydiv&#39;);var id = mydiv.getAttribute(&#39;id&#39;);</code></pre><blockquote><p>Element.setAttribute方法用于为当前节点设置属性。如果属性已经存在，将更新属性值，否则将添加该属性。该方法没有返回值。</p></blockquote><pre><code class="js">// HTML 代码为// &lt;button&gt;Hello World&lt;/button&gt;var b = document.querySelector(&#39;button&#39;);b.setAttribute(&#39;name&#39;, &#39;myButton&#39;);b.setAttribute(&#39;disabled&#39;, true);</code></pre><blockquote><p>Element.removeAttribute方法移除指定属性。该方法没有返回值。</p></blockquote><pre><code class="js">document.getElementById(&#39;div1&#39;).removeAttribute(&#39;id&#39;)</code></pre><blockquote><p>outerHTML/innerText</p></blockquote><pre><code class="js">outerHTML outerHTML  包括整个标签，而不仅限于标签内部的内容innerTextinnerText只获取元素内的文本内容，html标签将被忽略</code></pre><h6 id="获取孩子节点-childNodes和children"><a href="#获取孩子节点-childNodes和children" class="headerlink" title="获取孩子节点  childNodes和children"></a>获取孩子节点  childNodes和children</h6><ul><li>Element.children属性返回一个类似数组的对象（HTMLCollection实例），包括当前元素节点的所有子元素。如果当前元素没有子元素，则返回的对象包含零个成员</li><li>这个属性与Node.childNodes属性的区别是，它只包括元素类型的子节点，不包括其他类型的子节点。而childNodes属性包含空白节点</li></ul><h5 id="offsetWidth-offsetHeight"><a href="#offsetWidth-offsetHeight" class="headerlink" title="offsetWidth/offsetHeight"></a>offsetWidth/offsetHeight</h5><ul><li>Element.offsetHeight属性返回一个整数，表示元素的 CSS 垂直高度（单位像素），包括元素本身的高度、padding 和 border</li><li>Element.offsetWidth属性表示元素的 CSS 水平宽度（单位像素），其他都与Element.offsetHeight一致。<br>这两个属性都是只读属性<br>如果元素的 CSS 设为不可见（比如display: none;），则返回0</li><li>Element.offsetParent属性返回最靠近当前元素的、并且 CSS 的position属性不等于static的上层元素。</li></ul><pre><code class="html">&lt;div style=&quot;position: absolute;&quot;&gt;  &lt;p&gt;    &lt;span&gt;Hello&lt;/span&gt;  &lt;/p&gt;&lt;/div&gt;</code></pre><blockquote><p>上面代码中，span元素的offsetParent属性就是div元素。</p></blockquote><blockquote><p>该属性主要用于确定子元素位置偏移的计算基准，<br>Element.offsetTop和Element.offsetLeft就是offsetParent元素计算的。</p></blockquote><blockquote><p>offsetLeft/offsetTop</p></blockquote><blockquote><p>Element.offsetLeft返回当前元素左上角相对于Element.offsetParent节点的水平位移，Element.offsetTop返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移</p></blockquote><h4 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h4><ul><li><p>鼠标事件</p><ul><li>onclick:用户单击鼠标按钮</li><li>ondblclick:当用户双击主鼠标按钮时触发</li><li>onmousedown:当用户按下鼠标还未弹起时触发</li><li>onmouseup：当用户释放鼠标按钮时触发</li><li>onmouseover：当鼠标移到某个元素上方时触发</li><li>onmouseout：当鼠标移出某个元素上方时触发</li><li>onmousemove：当鼠标指针在元素上移动时触发</li></ul></li><li><p>HTML 事件</p><ul><li>onload：当页面或者资源完全加载后在 window 上面触发</li><li>onselect：当用户选择文本框(input 或 textarea)中的一个或多个字符触发</li><li>onchange：当文本框(input 或 textarea)内容改变且失去焦点后触发</li><li>onfocus：当页面或者元素获得焦点时在 window 及相关元素上面触发</li><li>onblur：当页面或元素失去焦点时在 window 及相关元素上触发</li><li>onresize：当窗口或框架的大小变化时在 window 或框架上触发</li><li>onscroll：当用户滚动带滚动条的元素时触发</li></ul></li><li><p>键盘事件keyup、keydown、keypress</p><ul><li>onkeydown：当用户按下键盘上任意键触发，如果按住不放，会重复触发</li><li>onkeypress：当用户按下键盘上的字符键触发，如果按住不放，会重复触发</li><li>onkeyup：当用户释放键盘上的键触发</li><li>组合键ctrkey、altkey、shiftkey</li><li>altKey属性，bool类型，表示发生事件的时候alt键是否被按下</li><li>ctrlKey属性，bool类型，表示发生事件的时候ctrl键是否被按下</li><li>shiftKey属性，bool类型，表示发生事件的时候shift键是否被按下 </li><li>keyCode/which兼容</li><li>事件源（事件在哪个元素上产生）</li></ul></li></ul><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><ul><li><p>当触发某个事件时，会产生一个事件对象，这个对象包含着所有与事件有关的信息 。包括导致事件的元素、事件的类型、以及其它与特定事件相关的信息。</p></li><li><p>通过事件绑定的执行函数是可以得到一个隐藏参数的 。说明，浏览器会自动分配一个参数，这个参数其实就是 event 对象。</p></li></ul><p>Event对象获取方式    （兼容性）</p><pre><code class="js">el.onclick=function(evt){    let e = evt || window.event}</code></pre><ul><li><p>属性</p><ul><li><p>event.button属性<br>当前事件触发时哪个鼠标按键被点击</p></li><li><p>clientX、clientY属性<br>鼠标在可视区X坐标和Y坐标，即距离左边框和上边框的距离</p></li><li><p>screenX、screenY属性<br>鼠标在屏幕区X坐标和Y坐标，即距离左屏幕和上屏幕的距离</p></li><li><p>offsetX、offsetY属性<br>鼠标相对于事件源的X坐标和Y坐标</p></li><li><p>pageX、pageY<br>鼠标相对于文档的X坐标和Y坐标</p></li></ul></li></ul><pre><code class="js">console.log(evt.clientX,evt.clientY);</code></pre><p>事件的冒泡</p><blockquote><p>事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。</p></blockquote><p>阻止事件冒泡</p><pre><code class="js">//阻止事件冒泡e.stopPropagation();//低版本iee.cancelBubble = true</code></pre><p>事件默认行为及阻止方式</p><blockquote><p>浏览器的默认行为 </p><p>JavaScript事件本身所具有的属性，例如a标签的跳转，Submit按钮的提交，右键菜单，文本框的输入等。 </p><p>阻止默认行为的方式<br> w3c的方法是<code>e.preventDefault()</code></p><p>IE则是使用<code>e.returnValue = false;</code></p><p> <code>return false;</code></p><p>自定义右键菜单 <code>oncontextmenu</code></p></blockquote><ul><li><p>DOM2级事件处理程序</p><ul><li><p>添加事件监听器：</p><ul><li><p>ele.addEventListener(事件名，处理函数，布尔值)<br>现代浏览器（IE9、10、11 | ff, chorme, safari, opera）</p></li><li><p>注意：事件名不带on，处理函数为函数引用，布尔值代表冒泡(内到外)或捕获（外到内）<br>element.addEventListener(“click”,function(){},false);//false 事件冒泡<br>element.addEventListener(“click”,function(){},true);//true事件捕获<br>  移除事件监听器：removeEventListener(事件名，处理函数)</p></li><li><p>IE8及以下的事件监听器：attachEvent(事件名，处理函数)，detachEvent(事件名，处理函数)<br>注意：事件名带on</p></li></ul></li><li><p>事件委托机制:</p><ul><li><p>拖拽效果<br>拖拽原理<br>三个事件：onmousedown、onmousemove、onmouseup<br>实现思路：</p><p>1：给目标元素添加onmousedown事件，拖拽的前提是在目标元素按下鼠标左键。</p><p>2：当onmousedown发生以后，此刻给document添加onmousemove事件，意味着此刻鼠标在网页的移动都将改变目标元素的位置。</p><p>3：在onmousemove事件中，设定目标元素的left和top，公式：<br>目标元素的left = 鼠标的clientX – （鼠标和元素的横坐标差，即offsetX）<br>目标元素的top = 鼠标的clientY– （鼠标和元素的纵坐标差，即offsetY）。</p><p>4：当onmousedown发生以后，此刻给document添加onmouseup事件，意味着此刻鼠标在网页的任意位置松开鼠标，都会放弃拖拽的效果。</p><p>5：在onmouseup事件中，取消document的onmousemove事件即可。</p></li></ul></li></ul></li></ul><p>如果想让框架支持透明度动画怎么办呢？无非是增加更多的判断运动框架最终封装见<code>animateBak.js</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;js的基础介绍&quot;&gt;&lt;a href=&quot;#js的基础介绍&quot; class=&quot;headerlink&quot; title=&quot;js的基础介绍&quot;&gt;&lt;/a&gt;js的基础介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;js的组成&lt;ul&gt;
&lt;li&gt;ECMAscript&lt;/li&gt;
&lt;li&gt;BOM&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="前端" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Js" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/Js/"/>
    
    
      <category term="Js" scheme="http://1512034032.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>HTML</title>
    <link href="http://1512034032.github.io/2019/11/06/html/"/>
    <id>http://1512034032.github.io/2019/11/06/html/</id>
    <published>2019-11-06T11:15:21.705Z</published>
    <updated>2019-11-09T11:47:27.892Z</updated>
    
    <content type="html"><![CDATA[<h4 id="html的语法"><a href="#html的语法" class="headerlink" title="html的语法"></a>html的语法</h4><ol><li>标签对/常规标签</li><li>单标签/空标签<br>1）写在&lt;&gt;中的第一个单词叫做标记，标签，元素。<br>2）标记和属性用空格隔开，属性和属性值用等号连接，属性值必须放在“”号内。<br>3）一个标记可以没有属性也可以有多个属性，属性和属性之间不分先后顺序。<br>4）空标记没有结束标签，用“/”代替。</li></ol><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><pre><code class="html">&lt;table&gt;&lt;/table&gt;表格&lt;tr&gt;&lt;/tr&gt;一行&lt;td&gt;&lt;/td&gt;一个单元格form表单的三个组成部分表单域&lt;form name =&quot;&quot; method=&quot;&quot; action=&quot;&quot;&gt;表单控件&lt;input type=&quot;text&quot;&gt;表单信息action用于设定表单数据文件的URL地址method指定数据传送到服务器的方式name用于设定表单名称</code></pre><pre><code>border-spacing：；单元格与单元格之间的间隙empty-cells：hidd；无内容的单元格隐藏table-layout：fixed；固定单元格宽高&lt;caption&gt;&lt;/caption&gt;table标题copiton-side:top/bottom/left/rihgt;标题位置rules：all；行列分割线1）colspan=&quot;value&quot;    合并列）rowspan=&quot;value&quot;  合并行）valign=&quot;top/bottom/middle/baseline&quot; 垂直对齐方式4）rules=&quot;rows/cols/all/none/groups&quot;    添加组分隔线    说明：    rows:位于行之间的线条    cols:位于列之间的线条    all：位于行和列之间的线条    none:没有线条    groups:位于行组和列组之间的线条&lt;colgroup span=&quot;value&quot;&gt;&lt;/colgroup&gt;&lt;col  span=&quot;value&quot; /&gt;说明：   1）col和colgroup元素会根据从左到右的顺序依次对数据表格进行分组。   2）span属性显示指定相邻几列组成一组，span属性值默认为1，默认时仅定义一列为一组。    3）可以通过给table添加rules=&quot;groups&quot;属性来给分组列添加组分割线。注意：虽然col和colgroup具有相同的功能，但是，我们只能使用colgroup元素来决定表格内容部分分割线（rules）应该处于的位置，而col没有这个功能。数据行分组&lt;thead&gt;&lt;/thead&gt;表头&lt;tbody&gt;&lt;/tbody&gt;表体&lt;tfoot&gt;&lt;/tfoot&gt;表尾</code></pre><h4 id="white-space属性"><a href="#white-space属性" class="headerlink" title="white-space属性"></a>white-space属性</h4><pre><code class="js">white-space：pre空白全要white-space：pre-wrap正常换行white-space：pre-line无空格 正常 换行</code></pre><h4 id="文本省略号"><a href="#文本省略号" class="headerlink" title="文本省略号"></a>文本省略号</h4><pre><code>text-overflow：ellipsos超出隐藏的文本显示为...与white-space：nowrap文字显示为一行，overflow：hidden一起用&amp;gt是”&gt;“&amp;lt是“&lt;”&amp;copy是“© ”</code></pre><h4 id="display元素类型"><a href="#display元素类型" class="headerlink" title="display元素类型"></a>display元素类型</h4><pre><code>display：；18个值block块状inline内联元素inline-block内联块none不显示list-item 列表 li的默认类型块状元素block    1.自己独占一行    2.支持宽高div ,p,ul,ol,dl,dt,dd,li,form,hr,table,tr,td,h1-h6内联/行内inline    1.不支持宽高    2.跟其他内联元素显示在同一行a,span,em,strong,sup,sub,b,i,u,del,img,inputdisplay:;就用检索对象应该生成的类型:blockinlineinline-block(特殊)( img input)nonelist-item  ( li )大部分块状元素的display默认值都是blockli的默认display值为list-itemtable的默认display值为tabletd的默认display值为table-cell大部分内联元素display默认值都为inlineimg和input默认display的值为inline-block</code></pre><h4 id="position定位"><a href="#position定位" class="headerlink" title="position定位"></a>position定位</h4><pre><code>fixed固定定位sticky粘性定位static 默认值absolute绝对定位relative相对定位定位属性属性值 position:static/relative/absolute/fixed/sticky;绝对定位于相对定位的区别absolute绝对定位    参照物：有定位设置的父元素    脱出文档流，无论是否进行移动，都不占据原来的位置    relative相对定位    参照物：自己原来本身的位置    不破坏文档流，无论是否进行移动，都不影响其他元素的显现定位的层叠属性z-index:;position：sticky；//粘性定位top：50px；距离顶部50px时固定元素</code></pre><h4 id="盒模型的组成"><a href="#盒模型的组成" class="headerlink" title="盒模型的组成"></a>盒模型的组成</h4><pre><code>content+padding+border+marginpadding值得四种写法一个值 上下左右四边两个值 上下  左右三个值 上   左右   下四个值 上   右   下  左</code></pre><h4 id="浏览器内核及代表"><a href="#浏览器内核及代表" class="headerlink" title="浏览器内核及代表"></a>浏览器内核及代表</h4><ol><li>IE内核         ：Trident   -ms-</li><li>Opera、Software ：Presto    -o-</li><li>Mozilla Firefox ：Gecko     -moz-</li><li>Chrome、Safari  ：Webkit    -webkit-<br>Google和Opera Software合作开发的排版引擎 Blink</li></ol><ul><li>优雅降级:<ul><li>标准   -webkit-    -moz-    -0-     -ms-  </li></ul></li><li>渐进增强：<ul><li>-ms-    -o-   -moz-   -webkit-    标椎</li></ul></li></ul><h4 id="max-width：768px-手机最大宽度"><a href="#max-width：768px-手机最大宽度" class="headerlink" title="max-width：768px;手机最大宽度"></a>max-width：768px;手机最大宽度</h4><h4 id="width，height：新属性；大多浏览器不兼容"><a href="#width，height：新属性；大多浏览器不兼容" class="headerlink" title="width，height：新属性；大多浏览器不兼容"></a>width，height：新属性；大多浏览器不兼容</h4><pre><code>1.fit-content宽度缩小到内容宽度2.fill-available宽度撑满3.max-content以元素内最大的元素宽度为宽度，简单说文字不换行4.min-content以元素内最小的元素宽度为宽度大部分支持：calc字符之间加空格例子：width：calc（100% - 250px * 2 等等）；</code></pre><h2 id="表单新控件"><a href="#表单新控件" class="headerlink" title="表单新控件"></a>表单新控件</h2><pre><code class="html">  &lt;fieldset&gt;&lt;!--1.dieldest是一个方框，2.可以用来分组，并区别标出文本3，可嵌套--&gt;          &lt;legend&gt;&lt;!--dieldest的标题，必须在dieldest里的第一行--&gt;          &lt;/legend&gt;      &lt;lable for=&quot;aa&quot;&gt;账号&lt;/lable&gt;&lt;!--文本框的提示，for用来绑定文本框--&gt;          &lt;input id=&quot;aa&quot; type=&quot;text&quot;&gt;          &lt;lable for=&quot;bb&quot;&gt;年龄&lt;/lable&gt;          &lt;select id=&quot;bb&quot;&gt;&lt;!--下拉菜单--&gt;                  &lt;option&gt;1&lt;/option&gt;&lt;!--下拉菜单选项--&gt;                  &lt;option&gt;2&lt;/option&gt;                  &lt;option&gt;3&lt;/option&gt;          &lt;/select&gt;          &lt;lable for=&quot;bb&quot;&gt;性别&lt;/lable&gt;          &lt;input name=&quot;&quot; type=&quot;radio&quot;&gt;男&lt;!--radio单选框，name必须是一组的--&gt;          &lt;input name=&quot;&quot; type=&quot;radio&quot; checked=&quot;checked&quot;&gt;女&lt;!--checked默认选中disable禁用--&gt;          &lt;input id=&quot;link&quot; type=&quot;checkbox&quot;&gt;唱&lt;!--多选--&gt;          &lt;input id=&quot;link&quot; type=&quot;checkbox&quot;&gt;跳          &lt;input id=&quot;link&quot; type=&quot;checkbox&quot;&gt;rap          &lt;input id=&quot;link&quot; type=&quot;checkbox&quot;&gt;篮球          &lt;textarea rows=&#39;2&#39; cols=&quot;5&quot;&gt;&lt;/textarea&gt;    &lt;!--rows行数 cols一行字符数--&gt;          &lt;input type=&quot;file&quot;&gt;&lt;!--文件框--&gt;           &lt;input type=&quot;hidden&quot;&gt;&lt;!--隐藏框--&gt;     &lt;/fieldset&gt;&lt;fieldset&gt;&lt;!--1.dieldest是一个方框，2.可以用来分组，并区别标出文本3，可嵌套--&gt;    &lt;legend&gt;&lt;!--dieldest的标题，必须在dieldest里的第一行--&gt;    &lt;/legend&gt;    &lt;lable for=&quot;aa&quot;&gt;账号&lt;/lable&gt;&lt;!--文本框的提示，for用来绑定文本框--&gt;    &lt;input id=&quot;aa&quot; type=&quot;text&quot;&gt;    &lt;lable for=&quot;bb&quot;&gt;年龄&lt;/lable&gt;    &lt;select id=&quot;bb&quot;&gt;&lt;!--下拉菜单--&gt;        &lt;option&gt;1&lt;/option&gt;&lt;!--下拉菜单选项--&gt;        &lt;option&gt;2&lt;/option&gt;        &lt;option&gt;3&lt;/option&gt;    &lt;/select&gt;    &lt;lable for=&quot;bb&quot;&gt;性别&lt;/lable&gt;    &lt;input name=&quot;&quot; type=&quot;radio&quot;&gt;男&lt;!--radio单选框，name必须是一组的--&gt;    &lt;input name=&quot;&quot; type=&quot;radio&quot; checked=&quot;checked&quot;&gt;女&lt;!--checked默认选中disable禁用--&gt;    &lt;input id=&quot;link&quot; type=&quot;checkbox&quot;&gt;唱&lt;!--多选--&gt;    &lt;input id=&quot;link&quot; type=&quot;checkbox&quot;&gt;跳    &lt;input id=&quot;link&quot; type=&quot;checkbox&quot;&gt;rap    &lt;input id=&quot;link&quot; type=&quot;checkbox&quot;&gt;篮球    &lt;textarea rows=&#39;2&#39; cols=&quot;5&quot;&gt;&lt;/textarea&gt;    &lt;!--rows行数 cols一行字符数--&gt;    &lt;input type=&quot;file&quot;&gt;&lt;!--文件框--&gt;     &lt;input type=&quot;hidden&quot;&gt;&lt;!--隐藏框--&gt; &lt;/fieldset&gt;</code></pre><p><code>&lt;input type=&quot;属性&quot;&gt;</code></p><h4 id="表单type"><a href="#表单type" class="headerlink" title="表单type"></a>表单type</h4><ul><li><p>type新属性<br>Search / tel / url / email / number / range / color / Datetime / date / month / week / time / datetime-local</p></li><li><p>新增的表单属性的语法及应用</p><ul><li>required:表示该项是必填项，如果表单未填写，会弹出相应的提示信息‘’；<br>placeholder:占位符，当获取焦点或者输入框中的值输入为空时显示，否则显示自己填写的内容</li><li>autofocus：进入该页面自动获取焦点，原则上只允许设置一个，如果设置多个，则只有第一个有效果</li><li>autocomplete：是否在双击输入框的时候自动补全，默认值为on，另一个值为off</li><li>multiple:支持用户输入多个此类型的文本，以逗号隔开，每个文本均会进行验证,适用于类型type为email属性值和file属性值</li><li>pattern：正则表达式,一般和title属性配合说明该项填写的内容</li><li>min:最小值，适用于属性type为number和range</li><li>max:最大值，适用于属性type为number和range</li><li>step:间隔</li><li>list属性：结合datalist元素使用</li><li>取消验证：可以对form表单添加novalidate属性，即使form表单中的input添加了required，也将不进行验证</li></ul></li></ul><pre><code class="html">&lt;input type=&quot;text&quot; list=&quot;datalist id名aaaaa&quot;&gt;&lt;datalist id=&quot;aaaaa&quot;&gt;    &lt;option value=&quot;值&quot; label=&quot;提示信息&quot;&gt;    &lt;option value=&quot;值&quot; label=&quot;提示信息&quot;&gt;    &lt;option value=&quot;值&quot; label=&quot;提示信息&quot;&gt;    &lt;option value=&quot;值&quot; label=&quot;提示信息&quot;&gt;    &lt;option value=&quot;值&quot; label=&quot;提示信息&quot;&gt;&lt;/datalist&gt;</code></pre><p>1）Datalist ：选项列表<br>input中输入list属性，属性值为该标签的id值，标签中子标签使用option，设置value和label<br>例：</p><pre><code>&lt;input type=“text” list=“id名&quot; /&gt;&lt;datalist id=“id名&quot;&gt;            &lt;option label=“提示信息”     value=“值“ &gt;            &lt;option label=&quot;提示信息&quot;   Value=&quot;值“ &gt;&lt;/datalist&gt;</code></pre><p>提示：option 元素永远都要设置 value 属性。<br>2）output:表示不同类型的输出，比如脚本的输出<br>注：必须从属于某个表单。即，必须将它书写在表单内部，或对它添加form属性。</p><pre><code>&lt;form oninput=&quot;x.value=parseInt(a.value)+parseInt(b.value)&quot; &gt;        &lt;input type=&quot;range&quot; id=&quot;a&quot; value=&quot;50&quot; min=&quot;0&quot; max=&quot;100&quot;/&gt; +        &lt;input type=&quot;number&quot; id=&quot;b&quot; value=&quot;50&quot;/&gt;=        &lt;output name=&quot;x&quot; for=&quot;a b&quot;&gt;&lt;/output&gt;&lt;/form&gt;</code></pre><h4 id="h5新标签"><a href="#h5新标签" class="headerlink" title="h5新标签"></a>h5新标签</h4><pre><code>&lt;!--h5新标签--&gt;&lt;header&gt;头&lt;/header&gt;&lt;footer&gt;尾&lt;/footer&gt;&lt;nav&gt;导航&lt;/nav&gt;&lt;menu&gt;菜单&lt;/menu&gt;&lt;main&gt;主体&lt;/main&gt;&lt;section&gt;大区域块&lt;/section&gt;&lt;aside&gt;侧边栏&lt;/aside&gt;&lt;article&gt;文章&lt;/article&gt;&lt;hgroup&gt;文件中标题的相关信息&lt;/hgroup&gt;&lt;address&gt;地址&lt;/address&gt;&lt;mark&gt;标记颜色&lt;/mark&gt;&lt;time&gt;时间&lt;/time&gt;&lt;canves&gt;动画&lt;/canves&gt;&lt;video 属性&gt;视频&lt;/video&gt;&lt;figure&gt;&lt;/figure&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;output&gt;&lt;/output&gt;&lt;datalist&gt;&lt;/datalist&gt;&lt;audio 属性&gt;音频&lt;/audio&gt;&lt;!--video audio的属性autoplay自动播放controls显示播放等按钮loop循环muted静音poster加载时的图像preload加载完页面后播放sec路径--&gt;</code></pre><h4 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h4><pre><code>设置了display:flex；的元素自动成为flex容器    子元素默认成为flex项目    换行：        flex-wrap:wrap;    .box{        flex-direction: row |row-reverse | column | column-reverse    }    Row(默认值)：主轴为水平方向，起点在左端。    Row-reverse:主轴水平方向，起始点在右端。    Column:主轴为垂直方向，起点在上沿。    Column-reverse:主轴在垂直方向，起点在下沿    容器默认有两根轴：        主轴-默认水平            主轴方向问题：flex-direction:row/column;            主轴的对齐方式justify-content:;                flex-start:默认值 左对齐            flex-end 右对齐            Center居中            Space-between 两端对齐，项目之间的间隔都相等            Space-around 每个项目两侧的间隔相等。            所以，项目之间的间隔比项目与边框的间隔大一倍。            交叉轴-默认垂直            交叉轴的对齐方式                align-content: flex-start/flex-end;多行                align-items:;单行            align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，            该属性不起作用。            flex-start：与交叉轴的起点对齐。            flex-end：与交叉轴的终点对齐。            center：与交叉轴的中点对齐。            space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。            space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间            隔比轴线与边框的间隔大一倍。            stretch（默认值）：轴线占满整个交叉轴。    项目默认沿主轴排列        项目所占据的主轴空间是内容撑出来的        项目所占据的交叉轴空间是撑满的    属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。    .item {    order: &lt;num&gt;;    }    .flex{display:flex;width:800px;margin:0;padding:0;list-style:none;}    .flex :nth-child(1){flex:1 1 300px;}     .flex :nth-child(2){flex:2 2 200px;}     .flex :nth-child(3){flex:3 3 400px;}    本例定义了父容器宽（即主轴宽）为800px，由于子元素设置了伸缩基准值flex-basis，相加300+200+400=900，那么子元素将会溢出900-800=100px；    由于同时设置了收缩因子，所以加权综合可得300*1+200*2+400*3=1900px；    于是我们可以计算a,b,c将被移除的溢出量是多少：    a被移除溢出量：(300*1/1900)*100，即约等于16px    b被移除溢出量：(200*2/1900)*100，即约等于21px    c被移除溢出量：(400*3/1900)*100，即约等于63px    最后a,b,c的实际宽度分别为：300-16=284px, 200-21=179px, 400-63=337px</code></pre><h4 id="瀑布流"><a href="#瀑布流" class="headerlink" title="瀑布流"></a>瀑布流</h4><pre><code>break-inside:avoid;折行column-count 栏目列数 numcolumn-width 栏目宽度 px (必要属性)column-gap   栏目距离  pxcolumn-rule  栏目间隔线 px style colorcolumn-span 栏目合并 all/nonecolumn-fill: auto;  定义栏目高</code></pre><h4 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h4><pre><code>linear-gradient(方向值，颜色值，颜色值，)线性渐变linear-gradient（red 0%, green 50%)，blue 100%）repearing-linear-gradient(方向值，颜色值，颜色值，)重复线性渐变</code></pre><h2 id="pointer-events-none-不成为鼠标事件"><a href="#pointer-events-none-不成为鼠标事件" class="headerlink" title="pointer-events:none;不成为鼠标事件"></a>pointer-events:none;不成为鼠标事件</h2><h2 id="2D-3D"><a href="#2D-3D" class="headerlink" title="2D/3D"></a>2D/3D</h2><pre><code class="html">&lt;style&gt;    perspective: 2000px;/*创建径深*/    perspective-origin:200deg -200deg;/*视线焦点位置*/    transform-style: preserve-3d;/*创建3D*/&lt;/style&gt;</code></pre><h4 id="css3-过渡｛transition：all-5s-｝"><a href="#css3-过渡｛transition：all-5s-｝" class="headerlink" title="css3 过渡｛transition：all 5s;｝"></a>css3 过渡｛transition：all 5s;｝</h4><pre><code>说明：    CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。    要实现这一点，必须规定两项内容：规定您希望把效果添加到哪个 CSS 属性上　　规定效果的时长    通过 CSS3，我们可以在不使用 Flash 动画或 JavaScript 的情况下，使元素从一种样式变换为另一种样式时为元素添加效果。相关属性用法：１）transition-property  要运动的样式  （all || [attr] || none）２）transition-duration 运动时间３）transition-delay 延迟时间４）transition-timing-function 运动形式　　　　ease：（逐渐变慢）默认值　　　　linear：（匀速）　　　　ease-in：(加速)　　　　ease-out：（减速）　　　　ease-in-out：（先加速后减速）</code></pre><h4 id="CSS3-转换"><a href="#CSS3-转换" class="headerlink" title="CSS3 转换"></a>CSS3 转换</h4><p>转换是使元素改变形状、尺寸和位置的一种效果。<br>您可以使用 2D 或 3D 转换来转换您的元素。<br>在咱们的转换概念当中：是没有display这么一说的，通过改变元素的透明度去实现从无到有<br>１）2D转换｛transform：rotate()  skew() scale() translate() ；｝<br>相关值用法：<br>    A、rotate()  旋转函数 取值度数 ,单位：deg<br>　　    通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。<br>    B、skew() 倾斜函数 取值度数 (扭曲)，通过 skew() 方法，元素翻转（倾斜/扭曲）给定的角度，<br>　　    skewX() skewY()<br>    C、scale() 缩放函数 取值 正数、负数和小数，通过 scale() 方法，元素的尺寸会增加或减少，<br>　　    scaleX()scaleY()<br>    D、translate() 位移函数，元素从其当前位置移动，根据给定的left（x 坐标） 和 top（y 坐标） 位置参数：<br>　　    translateX()translateY()</p><p>２）、旋转的基点｛Transform-origin：top left；｝<br>允许你改变被转换元素的位置。</p><h4 id="CSS3动画"><a href="#CSS3动画" class="headerlink" title="CSS3动画"></a>CSS3动画</h4><p>什么是 CSS3 中的动画？<br>    动画是使元素从一种样式逐渐变化为另一种样式的效果。 您可以改变任意多的样式任意多的次数。<br>请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。 0% 是动画的开始，100% 是动画的完成。<br>为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。<br>通过 CSS3，我们能够创建动画， 这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript</p><h3 id="1-CSS3-keyframes-规则"><a href="#1-CSS3-keyframes-规则" class="headerlink" title="1.CSS3 @keyframes 规则"></a>1.CSS3 @keyframes 规则</h3><pre><code>@keyframes myfirst {     from {background: red;} to {background: yellow;} }</code></pre><p>@keyframes 规则用于创建动画。<br>在 @keyframes 中规定某项 CSS 样式， 就能创建由当前样式逐渐改为新样式的动画效果。<br>Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属 性。<br>注释：Internet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。</p><h4 id="2-animation-myfirst-5s"><a href="#2-animation-myfirst-5s" class="headerlink" title="2.animation:myfirst 5s;"></a>2.animation:myfirst 5s;</h4><blockquote><p>当您在 @keyframes 中创建动画时， 请把它捆绑到某个选择器，否则不会产生动画效果。<br>通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器：规定动画的名称 规定动画的时长<br>把 “myfirst” 动画捆绑到 div 元素，时长：5 秒：</p></blockquote><h4 id="3-animation"><a href="#3-animation" class="headerlink" title="3.animation"></a>3.animation</h4><ol><li>animation-name动画名称（关键帧名称）</li><li>animation-duration 动画持续时间</li><li>animation-delay动画延迟</li><li>animation-iteration-count重复次数 infinite为无限次</li><li>animation-direction播放前重置 （动画是否重置后再开始播放）<br>alternate动画直接从上一次停止的位置开始执行<br>normal动画第二次直接跳到0%的状态开始执行</li><li>animation-play-state 播放状态<br>running 播放<br>paused 暂停</li><li>animation-fill-mode规定对象动画时间之外的状态。<br>Forwards 当动画完成后，在最后一个关键帧中<br>Backwards 在 animation-delay 所指定的时间之前，应用在第一个关键帧中<br>Both  向前和向后填充模式都被应用。<br>None 不改变默认行为</li><li>animation-iteration-count: value;一个数字，定义应该播放多少次动画</li><li>animation-timing-function动画运动 形式<br>linear匀速。<br>ease缓冲。<br>ease-in由慢到快。<br>ease-out由快到慢。<br>ease-in-out由慢到快再到慢。<br>step-start 动画分成10步，动画执行时为开始左侧端点的部分为开始。<br>step-end 动画分成10步，动画执行时以结尾端点为开始，默认值为 end。<br>指定在每个间隔的起点或是终点发生阶跃变化，默认为 end。</li></ol><p>｛backface-visibility：hidden｝<br>说明：<br>定义元素在不面对屏幕时是否可见</p><h2 id="HTML5新增多媒体标签"><a href="#HTML5新增多媒体标签" class="headerlink" title="HTML5新增多媒体标签"></a>HTML5新增多媒体标签</h2><p>video/audio</p><ol><li>source 标记定义媒体资源<br> 允许您规定两个视频/音频文件共 浏览器根据它对媒体类型或者编解码器的支持进行选择。</li><li>embed 标记定义外部的可交互的内容或插件 比如flash</li></ol><p>注：HTML5的多媒体标签的出现意味着多媒体的发展以及支持不使用插件的情况下即可操作媒体文件，极大地提升了用户体验<br>HTML5能在完全脱离插件的情况下播放音视频但是不是所有格式都支持。mpeg4/webm/ogg</p><h4 id="vw-rem"><a href="#vw-rem" class="headerlink" title="vw + rem"></a>vw + rem</h4><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><ul><li>1、百分比（弹性）布局的原理及应用及缺陷</li><li>2、vw单位的应用</li><li>3、Vw + rem  实现移动端布局</li><li>4、vw 结合rem 的计算方法</li><li>5、flexible.js 的应用</li></ul><h6 id="移动端页面布局"><a href="#移动端页面布局" class="headerlink" title="移动端页面布局"></a>移动端页面布局</h6><ul><li><p>弹性布局(100%布局)——拉钩网 、天猫首页 </p></li><li><p>等比缩放布局(rem布局)—网易、淘宝首页</p></li><li><p>vw,vh</p><ul><li>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。</li><li>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。</li><li>vmin：vw和vh中较小的那个。vmax：vw和vh中较大的那个。</li><li>vw, vh, vmin, vmax：</li><li>IE9+局部支持， chrome/firefox/safari/opera支持，iOS safari 8+支持， Android browser4.4+支持，chrome for android39支持</li></ul></li></ul><h6 id="1、-Rem配合VW做等比缩放布局"><a href="#1、-Rem配合VW做等比缩放布局" class="headerlink" title="1、 Rem配合VW做等比缩放布局"></a>1、 Rem配合VW做等比缩放布局</h6><ol><li>Remrem是指相对于根元素的字体大小的单位。</li><li>根元素如果根元素是相对设备尺寸自动变换。</li><li>VW视窗宽度，1vw等于视窗宽度的1%。</li><li>VW转换成PX赋值给font-size</li></ol><p>例：设备的分辨率为6401136，逻辑像素为320568    1VW=3.2pxFont-size:100px;转换成VW font-size:31.25vw; 1rem=31.25vw可一起结合写等比例缩放布局。</p><h4 id="CSS3-2D"><a href="#CSS3-2D" class="headerlink" title="CSS3 2D"></a>CSS3 2D</h4><h4 id="学习目标-1"><a href="#学习目标-1" class="headerlink" title="学习目标"></a>学习目标</h4><ul><li>1、渐变</li><li>2、过渡</li><li>3、2D</li></ul><h6 id="1、渐变linear-gradient-to-bottom-red-blue"><a href="#1、渐变linear-gradient-to-bottom-red-blue" class="headerlink" title="1、渐变linear-gradient( to bottom,red,blue)"></a>1、渐变linear-gradient( to bottom,red,blue)</h6><blockquote><p>说明：<br>    CSS3 Gradient 分为线性渐变(linear)和径向渐变(radial)。<br>    为了创建一个线性渐变，你必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以设置一个起点和一个方向（或一个角度）。用法：<br>    1）第一个参数:指定渐变方向，可以用“角度”的关键词或“英文”来表示：<br>    2）CSS3 渐变也支持透明度（transparent），可用于创建减弱变淡的效果。<br>    3）为了添加透明度，我们也可使用 rgba() 来定义颜色结点。<br>    4）repeating-linear-gradient() 函数用于重复线性渐变<br>    5）渐变的形状是 ellipse（表示椭圆） circle    （圆）<br><a href="http://www.colorzilla.com/gradient-editor/" target="_blank" rel="noopener">http://www.colorzilla.com/gradient-editor/</a><br>IE浏览器实现渐变只能使用IE自己的滤镜去实现 filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=＃ 00ffff,endColorstr=＃9fffff,grandientType=1); 第一个参数：渐变起始位置的颜色 第二个参数：渐变终止位置的颜色 第三个参数：渐变的类型 0 代表竖向渐变 1 代表横向渐变</p></blockquote><h6 id="２、css3-过渡｛transition：all-5s-｝"><a href="#２、css3-过渡｛transition：all-5s-｝" class="headerlink" title="２、css3 过渡｛transition：all 5s;｝"></a>２、css3 过渡｛transition：all 5s;｝</h6><blockquote><p>说明：<br>    CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。<br>    要实现这一点，必须规定两项内容：规定您希望把效果添加到哪个 CSS 属性上　　规定效果的时长<br>    通过 CSS3，我们可以在不使用 Flash 动画或 JavaScript 的情况下，使元素从一种样式变换为另一种样式时为元素添加效果。</p></blockquote><ul><li>相关属性用法：<br>  １）transition-property  要运动的样式  （all || [attr] || none）<br>  ２）transition-duration 运动时间<br>  ３）transition-delay 延迟时间<br>  ４）transition-timing-function 运动形式<ul><li>ease：（逐渐变慢）默认值</li><li>linear：（匀速）</li><li>ease-in：(加速)</li><li>ease-out：（减速）</li><li>ease-in-out：（先加速后减速）</li></ul></li></ul><h6 id="3、CSS3-转换"><a href="#3、CSS3-转换" class="headerlink" title="3、CSS3 转换"></a>3、CSS3 转换</h6><pre><code>转换是使元素改变形状、尺寸和位置的一种效果。您可以使用 2D 或 3D 转换来转换您的元素。在咱们的转换概念当中：是没有display这么一说的，通过改变元素的透明度去实现从无到有１）、2D转换｛transform：rotate()  skew() scale() translate() ；｝相关值用法：    A、rotate()  旋转函数 取值度数 ,单位：deg　    　通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。    B、skew() 倾斜函数 取值度数 (扭曲)，通过 skew() 方法，元素翻转（倾斜/扭曲）给定的角度，　　     skewX() skewY()    C、scale() 缩放函数 取值 正数、负数和小数，通过 scale() 方法，元素的尺寸会增加或减少，　　     scaleX()scaleY()    D、translate() 位移函数，元素从其当前位置移动，根据给定的left（x 坐标） 和 top（y 坐标） 位置参数：　　     translateX()translateY()２）、旋转的基点｛Transform-origin：top left；｝允许你改变被转换元素的位置。</code></pre><h6 id="扩展：鼠标"><a href="#扩展：鼠标" class="headerlink" title="扩展：鼠标"></a>扩展：鼠标</h6><pre><code>pointer-events: none;  取消划过状态cursor:pointer; 鼠标手型</code></pre><h4 id="CSS3-3d"><a href="#CSS3-3d" class="headerlink" title="CSS3 3d"></a>CSS3 3d</h4><h4 id="学习目标-2"><a href="#学习目标-2" class="headerlink" title="学习目标"></a>学习目标</h4><ul><li>1、3D</li><li>2、CSS3动画</li></ul><h3 id="一、CSS3-转换"><a href="#一、CSS3-转换" class="headerlink" title="一、CSS3 转换"></a>一、CSS3 转换</h3><pre><code>转换是使元素改变形状、尺寸和位置的一种效果。您可以使用 2D 或 3D 转换来转换您的元素。在咱们的转换概念当中：是没有display这么一说的，通过改变元素的透明度去实现从无到有</code></pre><h4 id="１、3D-转换"><a href="#１、3D-转换" class="headerlink" title="１、3D 转换"></a>１、3D 转换</h4><pre><code>说明：CSS3 允许您使用 3D 转换来对元素进行格式化。</code></pre><p>举例：以下都是再做3D转换</p><h6 id="1）rotate-旋转函数-取值度数-单位：deg"><a href="#1）rotate-旋转函数-取值度数-单位：deg" class="headerlink" title="1）rotate()  旋转函数 取值度数 ,单位：deg"></a>1）rotate()  旋转函数 取值度数 ,单位：deg</h6><pre><code>通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。rotateX() 　rotateY() 　rotateZ()</code></pre><h6 id="2）translate-位移函数，元素从其当前位置移动：这三种写法是等价"><a href="#2）translate-位移函数，元素从其当前位置移动：这三种写法是等价" class="headerlink" title="2）translate() 位移函数，元素从其当前位置移动：这三种写法是等价　　"></a>2）translate() 位移函数，元素从其当前位置移动：这三种写法是等价　　</h6><pre><code>transform:translateZ(800px) translateX(30px) translateY(30px);　　transform:translateZ(800px) translate(30px,30px);　　transform: translate3d(30px,30px,800px)</code></pre><h4 id="２、创建3d场景｛Perspective-800px-｝"><a href="#２、创建3d场景｛Perspective-800px-｝" class="headerlink" title="２、创建3d场景｛Perspective:800px;｝"></a>２、创建3d场景｛Perspective:800px;｝</h4><pre><code>说明：（增加一个维度/窗口）表示浏览器对我将要观察到的三维物体有800px那么远 perspective-origin:; 视角观察三维物体的角度</code></pre><p>用法：</p><h6 id="1、perspective属性有两种书写形式"><a href="#1、perspective属性有两种书写形式" class="headerlink" title="1、perspective属性有两种书写形式"></a>1、perspective属性有两种书写形式</h6><pre><code>1）写在舞台元素上（动画元素们的共同父辈元素）以父元素的视角为中心观看；示例：    .box{        perspective: 1200px;    }</code></pre><pre><code>2）写在当前动画元素上（起效果的那个元素），与transform的其他属性写在一起，以子元素为中心来观看。示例：    .box div{        transform:perspective(1200px) translateZ(300px) translate(30px,30px);    }</code></pre><h6 id="２、规定被嵌套元素如何在-3D-空间中显示。｛transform-style-preserve-3d-｝"><a href="#２、规定被嵌套元素如何在-3D-空间中显示。｛transform-style-preserve-3d-｝" class="headerlink" title="２、规定被嵌套元素如何在 3D 空间中显示。｛transform-style:preserve-3d ｝"></a>２、规定被嵌套元素如何在 3D 空间中显示。｛transform-style:preserve-3d ｝</h6><pre><code>说明：告诉浏览器之后进行的transform都是对3d的世界进行了transform-style:preserve-3d 一定要加给transform的父元素</code></pre><h6 id="２、｛backface-visibility：hidden｝"><a href="#２、｛backface-visibility：hidden｝" class="headerlink" title="２、｛backface-visibility：hidden｝"></a>２、｛backface-visibility：hidden｝</h6><pre><code>说明：定义元素在不面对屏幕时是否可见。</code></pre><h4 id="二、CSS3动画"><a href="#二、CSS3动画" class="headerlink" title="二、CSS3动画"></a>二、CSS3动画</h4><pre><code>什么是 CSS3 中的动画？    动画是使元素从一种样式逐渐变化为另一种样式的效果。 您可以改变任意多的样式任意多的次数。     请用百分比来规定变化发生的时间，或用关键词 &quot;from&quot; 和 &quot;to&quot;，等同于 0% 和 100%。 0% 是动画的开始，100% 是动画的完成。    为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。     通过 CSS3，我们能够创建动画， 这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript</code></pre><h6 id="1-CSS3-keyframes-规则-1"><a href="#1-CSS3-keyframes-规则-1" class="headerlink" title="1.CSS3 @keyframes 规则"></a>1.CSS3 @keyframes 规则</h6><pre><code>@keyframes myfirst {             from {background: red;} to {background: yellow;}}@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式， 就能创建由当前样式逐渐改为新样式的动画效果。Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。 注释：Internet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。 </code></pre><h6 id="2-animation-myfirst-5s-1"><a href="#2-animation-myfirst-5s-1" class="headerlink" title="2.animation:myfirst 5s;"></a>2.animation:myfirst 5s;</h6><pre><code>当您在 @keyframes 中创建动画时， 请把它捆绑到某个选择器，否则不会产生动画效果。通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器：规定动画的名称 规定动画的时长 把 &quot;myfirst&quot; 动画捆绑到 div 元素，时长：5 秒： </code></pre><h6 id="3-animation-1"><a href="#3-animation-1" class="headerlink" title="3.animation"></a>3.animation</h6><pre><code>1）animation-name动画名称（关键帧名称） 2）animation-duration 动画持续时间 3）animation-delay动画延迟 4）animation-iteration-count重复次数 infinite为无限次 5）animation-direction播放前重置 （动画是否重置后再开始播放）       alternate动画直接从上一次停止的位置开始执行         normal动画第二次直接跳到0%的状态开始执行6）animation-play-state 播放状态         running 播放          paused 暂停7）animation-fill-mode规定对象动画时间之外的状态。    Forwards 当动画完成后，在最后一个关键帧中    Backwards 在 animation-delay 所指定的时间之前，应用在第一个关键帧中   Both  向前和向后填充模式都被应用。    None 不改变默认行为8）animation-iteration-count: value;一个数字，定义应该播放多少次动画9）animation-timing-function动画运动 形式         linear匀速。         ease缓冲。         ease-in由慢到快。        ease-out由快到慢。       ease-in-out由慢到快再到慢。step-start 动画分成10步，动画执行时为开始左侧端点的部分为开始。 step-end 动画分成10步，动画执行时以结尾端点为开始，默认值为 end。指定在每个间隔的起点或是终点发生阶跃变化，默认为 end。 </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;html的语法&quot;&gt;&lt;a href=&quot;#html的语法&quot; class=&quot;headerlink&quot; title=&quot;html的语法&quot;&gt;&lt;/a&gt;html的语法&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;标签对/常规标签&lt;/li&gt;
&lt;li&gt;单标签/空标签&lt;br&gt;1）写在&amp;lt;&amp;gt;中的第
      
    
    </summary>
    
    
      <category term="前端" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="H5" scheme="http://1512034032.github.io/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>Swiper</title>
    <link href="http://1512034032.github.io/2019/11/06/Swiper/"/>
    <id>http://1512034032.github.io/2019/11/06/Swiper/</id>
    <published>2019-11-06T06:02:06.608Z</published>
    <updated>2019-11-06T11:16:59.863Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="html">&lt;div class=&quot;swiper-container&quot;&gt;    &lt;div class=&quot;swiper-wrapper&quot;&gt;        &lt;div class=&quot;swiper-slide slide1&quot;&gt;Slide 1&lt;/div&gt;        &lt;div class=&quot;swiper-slide slide2&quot;&gt;Slide 2&lt;/div&gt;        &lt;div class=&quot;swiper-slide slide3&quot;&gt;Slide 3&lt;/div&gt;    &lt;/div&gt;    &lt;!-- 如果需要分页器 --&gt;    &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt;    &lt;!-- 如果需要导航按钮 --&gt;    &lt;div class=&quot;swiper-button-prev swiper-button-black&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;swiper-button-next swiper-button-white&quot;&gt;&lt;/div&gt;    &lt;!-- 如果需要滚动条 --&gt;    &lt;!-- &lt;div class=&quot;swiper-scrollbar&quot;&gt;&lt;/div&gt; --&gt;&lt;/div&gt;&lt;script&gt;    var mySwiper = new Swiper(&#39;.swiper-container&#39;, {        // direction: &#39;vertical&#39;, // 垂直切换选项        // direction: &#39;vertical&#39;, // 垂直切换选项        loop: true, // 循环模式选项        // 如果需要分页器        pagination: {            el: &#39;.swiper-pagination&#39;,        },        // 如果需要前进后退按钮        navigation: {            nextEl: &#39;.swiper-button-next&#39;,            prevEl: &#39;.swiper-button-prev&#39;,        },        // 如果需要滚动条        // scrollbar: {        //   el: &#39;.swiper-scrollbar&#39;,        // },    })&lt;/script&gt;</code></pre><pre><code class="js">freeMode默认为false，普通模式：slide滑动时只滑动一格，并自动贴合wrapper，设置为true则变为free模式，slide会根据惯性滑动可能不止一格且不会贴合。freeModeSticky使得freeMode也能自动贴合。disableOnInteraction用户操作swiper之后，是否禁止autoplay。默认为true：停止。如果设置为false，用户操作swiper之后自动切换不会停止，每次都会重新启动autoplay。操作包括触碰，拖动，点击pagination等。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;div class=&amp;quot;swiper-container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;swiper-wrapper&amp;quot;&amp;gt;
        &amp;lt;div clas
      
    
    </summary>
    
    
      <category term="前端" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue动画</title>
    <link href="http://1512034032.github.io/2019/11/06/VueAnimation/"/>
    <id>http://1512034032.github.io/2019/11/06/VueAnimation/</id>
    <published>2019-11-06T06:02:06.590Z</published>
    <updated>2019-11-09T11:48:02.281Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./transition.png" alt=""></p><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;    .v-enter, // 开始进入动画的状态    .v-leave-to{ // 结束动画时的状态        opacity: 0;        transform: translateX(100px);    }    .v-enter-active, // 进入动画的开始状态到结束状态    .v-leave-active{ // 离开动画的开始状态到结束状态        transition: all 1s ease;    }&lt;/style&gt;&lt;div id=&quot;app&quot;&gt;    &lt;transition&gt; // Vue 动画写在 transition 标签中        &lt;h3&gt;ww&lt;/h3&gt;    &lt;/transition&gt;&lt;/div&gt;</code></pre><p>简写</p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;    &lt;transiton enter-active-class=&quot;animated&quot; leave-active-class=&quot;&quot; :duration=&quot;{enter:3000,leave:5000}&gt;    &lt;!-- //设置进入动画的样式 如果使用 animate.css 需先添加默认样式 animated         //设置离开动画的样式 如果使用 animate.css 需先添加默认样式 animated--&gt;        &lt;v-head&gt;&lt;/v-head&gt;    &lt;/transiton&gt;&lt;/div&gt;</code></pre><p>唯一组件</p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;    &lt;button @click=&quot;isshow=&#39;v-a&#39;&quot;&gt;AAA组件&lt;/button&gt;    &lt;button @click=&quot;isshow=&#39;v-b&#39;&quot;&gt;BBB组件&lt;/button&gt;    &lt;transition     enter-active-class=&quot;animated bounceIn&quot;     leave-active-class=&quot;animated hinge&quot;     :duration=&quot;{enter:3000,leave:5000}&quot;&gt; /* 设置组件的进入离开的样式 */        &lt;component :is=&quot;isshow&quot;&gt;&lt;/component&gt;         /* Vue 自带的组件动画标签 component 一次只能有一个组件在当前标签中 根据 is 绑定组件名称*/    &lt;/transition&gt;&lt;/div&gt;&lt;template id=&#39;a&#39;&gt;    &lt;div&gt;        &lt;h2&gt;AAAAAAAAA组件&lt;/h2&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template id=&#39;b&#39;&gt;    &lt;div&gt;        &lt;h2&gt;BBBBBBBBB组件&lt;/h2&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt;    new Vue({        el: &#39;#app&#39;,        data: {            isshow: &#39;v-a&#39;        },        components:{            &#39;v-a&#39;:{                template:&#39;#a&#39;            },            &#39;v-b&#39;:{                template:&#39;#b&#39;            }        }    })&lt;/script&gt;</code></pre><p>多个标签执行动画</p><pre><code class="html">&lt;transition-group enter-active-class=&quot;animated bounceIn&quot; leave-active-class=&quot;animated hinge&quot; :duration=&quot;{enter:3000,leave:5000}&quot;&gt;    &lt;h3 v-if=&quot;flag&quot; key=&#39;1&#39;&gt;动画Yo.~&lt;/h3&gt;    &lt;h3 v-if=&quot;flag&quot; key=&#39;2&#39;&gt;动画Yo.~&lt;/h3&gt;&lt;/transition-group&gt;&lt;!-- 多个标签执行动画 需要使用 transition-group 标签 并且内部执行动画的标签需要绑定区分唯一的 key 值 --&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;./transition.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
    .v-enter, // 开始进入动画的状态
    .v
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://1512034032.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://1512034032.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>ajax</title>
    <link href="http://1512034032.github.io/2019/11/06/ajax/"/>
    <id>http://1512034032.github.io/2019/11/06/ajax/</id>
    <published>2019-11-06T06:02:06.582Z</published>
    <updated>2019-11-09T11:46:40.299Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原生js"><a href="#原生js" class="headerlink" title="原生js"></a>原生js</h3><pre><code class="js">let xhr = new XMLHttpRequest()xhr.open(&#39;GET/POST&#39;,url)//请求方式和地址xhr.end(null/{})//GET方式为 null POST方式需写要传的参数xhr.onload = function(){    if(status==200){        let obj = xhr.responseText//请求成功后返回的数据    }}</code></pre><h3 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h3><pre><code class="js">$.ajax({    url:&#39;&#39;, // 发起 ajax 请求的地址    data:&#39;GET/POST&#39;, // 请求方式    TypeData:&#39;json&#39;, // 请求成功后返回的数据类型    Headers:{}, // 发送请求时请求头中需要传入的数据    success:function(data){        // data 为请求成功后返回的数据    },    error:function(err){        // err    }})</code></pre><h3 id="Vue1-0"><a href="#Vue1-0" class="headerlink" title="Vue1.0"></a>Vue1.0</h3><p>采用 Vue-resource API</p><pre><code class="js">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue-resource@1.3.4&quot;&gt;&lt;/script&gt;//Eg:百度接口var api=&#39;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=php&#39;;var that=this;this.$http.jsonp(api,{    jsonp:&#39;cb&#39;}).then(function(data){    console.log(data.body);    that.list=data.body.s;},function(){})</code></pre><h3 id="Vue2-0"><a href="#Vue2-0" class="headerlink" title="Vue2.0"></a>Vue2.0</h3><h4 id="fecth："><a href="#fecth：" class="headerlink" title="fecth："></a>fecth：</h4><p>使用方法</p><pre><code class="js">    fetch(&#39;/users&#39;, {        method: &#39;POST&#39;, // 请求方式        headers: { // 头部信息        &#39;Content-Type&#39;: &#39;application/json&#39;        },        body: JSON.stringify({ // 参数            name: &#39;Hubot&#39;,            login: &#39;hubot&#39;,        })    }).then(function(),function())</code></pre><p>简写</p><pre><code class="js">fetch(&#39;/users.json&#39;)    .then(function(response) { // 第一个函数处理返回数据的类型，注意位置        return response.json()    }).then(function(json) { // 第二个函数的参数表示返回值        console.log(&#39;parsed json&#39;, json)    }).catch(function(ex) { // 请求失败后的处理函数及错误的返回值        console.log(&#39;parsing failed&#39;, ex)    })</code></pre><h4 id="axios："><a href="#axios：" class="headerlink" title="axios："></a>axios：</h4><p>使用方法：</p><pre><code class="js">axios({    url:&#39;&#39;,    method:&#39;GET/POST&#39;,    data:{}, // params:{}/data:{},GET请求时传参用 params POST请求时传参用 data    headers:{}}).then(res=&gt;{    // res 请求成功后返回的数据})</code></pre><h4 id="执行多个并发请求"><a href="#执行多个并发请求" class="headerlink" title="执行多个并发请求"></a>执行多个并发请求</h4><pre><code class="js">function getUserAccount() {    return axios.get(&#39;/user/12345&#39;);}function getUserPermissions() {    return axios.get(&#39;/user/12345/permissions&#39;);}axios.all([getUserAccount(), getUserPermissions()])    .then(axios.spread(function (acct, perms) {    // 两个请求现在都执行完成     // 第一个参数表示第一个请求的返回值，第二个参数表示第二个请求的返回值}));</code></pre><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>在请求或响应被 then 或 catch 处理前拦截它们。</p><pre><code class="js">// 添加请求拦截器axios.interceptors.request.use(function (config) {    // 在发送请求之前做些什么    return config;}, function (error) {    // 对请求错误做些什么    return Promise.reject(error);});// 添加响应拦截器axios.interceptors.response.use(function (response) {    // 对响应数据做点什么    return response;}, function (error) {    // 对响应错误做点什么    return Promise.reject(error);});</code></pre><p>如果你想在稍后移除拦截器，可以这样：</p><pre><code class="js">var myInterceptor = axios.interceptors.request.use(function () {/*...*/});axios.interceptors.request.eject(myInterceptor);</code></pre><h4 id="全局的-axios-默认值"><a href="#全局的-axios-默认值" class="headerlink" title="全局的 axios 默认值"></a>全局的 axios 默认值</h4><pre><code class="js">axios.defaults.baseURL = &#39;https://api.example.com&#39;; // 设置全局公共 API 跟地址axios.defaults.headers.common[&#39;Authorization&#39;] = AUTH_TOKEN; // 设置全局 headers 携带的数据axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded&#39;; // 设置 POST 请求头的类型</code></pre><p>某个请求的响应包含以下信息</p><pre><code class="js">{    // `data` 由服务器提供的响应    data: {},    // `status` 来自服务器响应的 HTTP 状态码    status: 200,    // `statusText` 来自服务器响应的 HTTP 状态信息    statusText: &#39;OK&#39;,    // `headers` 服务器响应的头    headers: {},    // `config` 是为请求提供的配置信息    config: {}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原生js&quot;&gt;&lt;a href=&quot;#原生js&quot; class=&quot;headerlink&quot; title=&quot;原生js&quot;&gt;&lt;/a&gt;原生js&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;let xhr = new XMLHttpRequest()
xhr.open(&amp;#3
      
    
    </summary>
    
    
      <category term="前端" scheme="http://1512034032.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ajax" scheme="http://1512034032.github.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>express</title>
    <link href="http://1512034032.github.io/2019/11/06/express/"/>
    <id>http://1512034032.github.io/2019/11/06/express/</id>
    <published>2019-11-06T06:02:06.576Z</published>
    <updated>2019-11-09T11:47:14.657Z</updated>
    
    <content type="html"><![CDATA[<p>全局安装环境 npm install express –g<br>测试安装成功与否  express –h(省略)<br>安装npm install express-generator –g<br>脚手架创建项目 express  -e  project_name（项目名字）<br>安装package.json中的依赖，进入目录cd express，安装依赖npm I<br>启动npm start  浏览器输入localhost:3000 查看</p><ul><li>express 插件<ul><li><code>cosr</code> 全局开启跨域权限</li><li><code>express-session</code> 服务器端 session 储存</li><li><code>jsonwebtoken</code> 生成 token</li></ul></li></ul><h3 id="Package-json依赖解释"><a href="#Package-json依赖解释" class="headerlink" title="Package.json依赖解释"></a>Package.json依赖解释</h3><p>body-parser 对http请求体进行解析<br>cookie-parser 对cookie进行解析的<br>debug 输出debug信息<br>ejs javascript模板引擎<br>morgan 在控制台上显示request url 信息<br>serve-favicon: 解决默认请求favicon.ico问题</p><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><h5 id="设计方式"><a href="#设计方式" class="headerlink" title="设计方式"></a>设计方式</h5><p>HEAD（SELECT）只获取某个资源的头部信息<br>GET（SELECT）获取资源<br>POST（CREATE）创建资源<br>PATCH（UPDATE）更新资源的部分属性（很少用，一般用POST代替）<br>PUT（UPDATE）更新资源，客户端需要提供新建资源的所有属性<br>DELETE（DELETE）删除资源</p><h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><p>GET <a href="http://www.xxxx.com/api/user" target="_blank" rel="noopener">http://www.xxxx.com/api/user</a> # 获取列表<br>POST <a href="http://www.xxxx.com/api/user" target="_blank" rel="noopener">http://www.xxxx.com/api/user</a> # 创建用户<br>PUT <a href="http://www.xxxx.com/api/user/{id}" target="_blank" rel="noopener">http://www.xxxx.com/api/user/{id}</a> # 修改用户信息<br>DELETE <a href="http://www.xxxx.com/api/user/{id}" target="_blank" rel="noopener">http://www.xxxx.com/api/user/{id}</a> # 删除用户信息</p><h5 id="过滤信息"><a href="#过滤信息" class="headerlink" title="过滤信息"></a>过滤信息</h5><p>用于补充规范一些通用字段<br>?limit=10 # 指定返回记录的数量<br>?offset=10 # 指定返回记录的开始位置<br>?page=2&amp;per_page=100 # 指定第几页，以及每页的记录数<br>?sortby=name&amp;order=asc # 指定返回结果按照哪个属性排序，以及排序顺序<br>?state=close # 指定筛选条件</p><h3 id="ssr"><a href="#ssr" class="headerlink" title="ssr"></a>ssr</h3><p>npm install -g ssr  全局环境安装一次<br>ssr # 默认 端口 1987 访问地址：=&gt; <a href="http://localhost:1987" target="_blank" rel="noopener">http://localhost:1987</a><br>ssr -p 2015 # 端口设置 2015 访问地址：=&gt; <a href="http://localhost:2015" target="_blank" rel="noopener">http://localhost:2015</a><br>ssr -cp 2015 #端口设置 2015 并且 可以跨域访问</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;全局安装环境 npm install express –g&lt;br&gt;测试安装成功与否  express –h(省略)&lt;br&gt;安装npm install express-generator –g&lt;br&gt;脚手架创建项目 express  -e  project_name（项目名字
      
    
    </summary>
    
    
      <category term="Node" scheme="http://1512034032.github.io/categories/Node/"/>
    
    
      <category term="Node" scheme="http://1512034032.github.io/tags/Node/"/>
    
  </entry>
  
</feed>
